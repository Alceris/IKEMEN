
lib mes = <alpha/mesdialog.ssz>;
lib sdl = <alpha/sdlplugin.ssz>;
lib s = <string.ssz>;
lib m = <math.ssz>;
lib se = <alpha/sdlevent.ssz>;
lib al = <alert.ssz>;
lib sff = "sff.ssz";
lib stage = "stage.ssz";
lib p1 = "state0p.ssz";
lib p2 = "state1p.ssz";
lib p3 = "state2p.ssz";
lib p4 = "state3p.ssz";
lib chr = "char.ssz";
lib cfg = "config.ssz";
lib com = "common.ssz";
lib fnt = "font.ssz";
lib sha = "share.ssz";
lib tbl = <table.ssz>;
lib file = <file.ssz>;
lib cmd = "command.ssz";

const double lvmul = 2.0**(1.0/12.0);

&WincntMgr
{
  /^/char wincFN = "autolevel.txt";
  &.tbl.NameTable!int? winct;
  ^int zeroAry(int sz)
  {
    ^int a.new(sz);
    loop{index i = 0; while; do: a[i] = 0; i++; while i < sz:}
    ret a;
  }
  public void init()
  {
    if(!.com.autolevel) ret;
    ^char buf;
    buf = .s.u8ToS()<, .file.readAll!ubyte?(`wincFN);
    if(#buf > 0 && buf[0] == '\xfeff') buf = buf[1..-1];
    ^^/char lines = .s.splitLines(buf);
    loop{
      index i = 0;
      ^^/char tmp;
      ^int item;
      while;
    do:
      tmp = .s.split(",", lines[i]);
      if(#tmp < 2) continue;
      item = .s.svToAry!int?(" ", .s.trim(tmp[1]));
      item = item[0..12];
      if(#item < 12) item = item + `zeroAry(12-#item);
      `winct.set(tmp[0], item);
    continue:
      i++;
    while i < #lines:
    }
  }
  delete()
  {:<-
    if(
      !.com.autolevel
      || (.com.p1wins < .com.p1mw && .com.p2wins < .com.p2mw)) ret;
    void foo(index i)
    {
      if(#.chr.chars[i] > 0) branch{
      cond .chr.chars[i][0]~isWin():
        `win(i);
      cond .chr.chars[i][0]~isLose():
        `lose(i);
      }
    }
    foo(0);
    foo(1);
    foo(2);
    foo(3);
    %char buf;
    buf .= '\xfeff';
    `winct.forEach()<, [void(^/char name, ^int cnt){
      buf .= name .= ',';
      loop{index i = 0; while; do:
        buf .= ' ' .= .s.iToS(cnt[i]);
        i++;
      while i < 12:}
      buf .= \r\n;
    }];
    &.file.File f;
    f.open(`wincFN, "wb");
    f.writeAry!ubyte?(.s.sToU8(buf));
  }
  ^int getItem(^/char name)
  {
    ^int item = `winct.get(name);
    if(#item < 12) item = item + `zeroAry(12-#item);
    ret item;
  }
  void win(index i)
  {
    ^int item = `getItem(.chr.chars[i][0]~def);
    item[.chr.chars[i][0]~palno-1] +=
      .com.tmode[i+1&1] == (int).com.TeamMode::Simul
      && .com.tmode[i&1] != (int).com.TeamMode::Simul ? 2 : 1;
    `winct.set(.chr.chars[i][0]~def, item);
  }
  void lose(index i)
  {
    ^int item = `getItem(.chr.chars[i][0]~def);
    item[.chr.chars[i][0]~palno-1] -=
      .com.tmode[i+1&1] == (int).com.TeamMode::Simul
      && .com.tmode[i&1] != (int).com.TeamMode::Simul ? 2 : 1;
    `winct.set(.chr.chars[i][0]~def, item);
  }
  public int getLevel(index i)
  {
    ^int item = `getItem(.chr.chars[i][0]~def);
    ret item[.chr.chars[i][0]~palno-1];
  }
}
&WincntMgr wm;

void game()
{
  void put(float x, float y=, ^/char txt)
  {
    int tmp = .sff.allPalFX~time;
    .sff.allPalFX~time = 0;
    .fnt.debugFont~drawText(
      x - (float)(.com.GameWidth-320)/2.0,
      y += (float).fnt.debugFont~sizey/.com.HeightScale,
      1.0/.com.WidthScale,  1.0/.com.HeightScale, 0, 1, txt);
    .sff.allPalFX~time = tmp;
  }
  void drawDebug()
  {:<-
    if(!.com.debugdraw || #.fnt.debugFont == 0) ret;
    float pdraw(&.chr.Char p=, float x)
    {:<-
      float y = 0.0;
      `put(x, y=, .s.iToS(p.stVal.time));
      `put(x, y=, .s.iToS(p.stVal.prevno));
      `put(x, y=, .s.iToS(p.stVal.no));
      `put(x, y=, .s.iToS(p.animno));
      `put(x, y=, .s.iToS(.chr.v.setI(0)$p.trAnimElemNo()$.chr.v.toI()));
      ret y;
    }
    float y = 48.0;
    loop{index i = 0; while; do:
      if(#.chr.chars[i] > 0){
        y =
          .m.max!float?(
            y, pdraw(
              .chr.chars[i][0]<>=, ((float).com.GameWidth/4.0)*(float)i));
      }
      i++;
    while i < #.chr.chars:
    }
    loop{index i = 0; while; do:
      if(#.chr.chars[i] > 0) `put(0.0, y=, .chr.chars[i][0]~def + \n);
      i++;
    while i < #.chr.chars:}
    `put(0.0, y=, .chr.stg~def);
    `put(0.0, y=, "");
    loop{index i = 0; while; do:
      if(#.chr.chars[i] > 0){
        loop{index j = 0; while; do:
          `put(0.0, y=, .com.clipboardText[i][j]);
          j++;
        while j < #.com.clipboardText[i]:
        }
      }
      y+=(float).fnt.debugFont~sizey/.com.HeightScale;
      i++;
    while i < #.chr.chars:
    }
  }
  float x = 0.0, y = 0.0, l = 0.0, r = 0.0;
  float scl = 1.0, sclmul = 1.0;
  float newx = x, newy = y;
  int oldp1wins, oldp2wins, olddraws;
  ^int lif.new(4), pow.new(4);
  ^^/int var.new(4);
  ^^/float fvar.new(4);
  void copyVar(int pno)
  {
    `lif[pno] = .chr.chars[pno][0]~sysivar[.chr.iLIFE];
    `pow[pno] = .chr.chars[pno][0]~sysivar[.chr.iPOWER];
    `var[pno] = .s.clone!int?(.chr.chars[pno][0]~ivar);
    `fvar[pno] = .s.clone!float?(.chr.chars[pno][0]~fvar);
  }
  void reset()
  {
    .com.p1wins = `oldp1wins;
    .com.p2wins = `oldp2wins;
    .com.draws = `olddraws;
    loop{index i = 0; do:
      if(#.chr.chars[i] > 0){
        .chr.chars[i][0]~sysivar[.chr.iLIFE] = `lif[i];
        .chr.chars[i][0]~sysivar[.chr.iPOWER] = `pow[i];
        .s.copy!int?(.chr.chars[i][0]~ivar, `var[i]);
        .s.copy!float?(.chr.chars[i][0]~fvar, `fvar[i]);
      }
    continue:
      i++;
    while i < #.chr.chars:
    }
    .chr.nextRound();
    `x = `newx = 0.0;
    `y = `newy = 0.0;
    `l = `r = 0.0;
    `scl = `sclmul = 1.0;
    .com.scale = .chr.stg~ztopscale;
    .com.screenleft = (float).chr.stg~screenleft;
    .com.screenright = (float).chr.stg~screenright;
    .com.xmin = -((float).com.GameWidth/2.0)/.com.scale + .com.screenleft;
    .com.xmax = ((float).com.GameWidth/2.0)/.com.scale - .com.screenright;
  }
  loop{
    int stagetime;
    ^&.sha.Share share;
    &.com.SuperDangerousRef oldshare;
    oldshare.copyRef!&.sha.Share?(share=);
    ^char ss;
    .mes.GetSharedString(:ss=:);
    ^^/char sss = .s.split("<>", ss);
    &.com.SuperDangerousRef sdr;
    sdr.pos = 0;
    sdr.l = typesize(&.sha.Share);
    sdr.p = .s.sToN!index?(sss[1]);
    sdr.copyToRef!&.sha.Share?(share=);
    share~push();
    stagetime = share~stt;
    .cmd.synchronize();
    .wm.init();
    ^int level;
    level.new(4);
    if(#.chr.chars[0] > 0){
      .chr.chars[0][0]~stateInit0P();
      level[0] = level[2] = .wm.getLevel(0);
    }
    if(#.chr.chars[1] > 0){
      .chr.chars[1][0]~stateInit1P();
      level[1] = level[3] = .wm.getLevel(1);
    }
    if(#.chr.chars[2] > 0){
      .chr.chars[2][0]~stateInit2P();
      level[2] = .wm.getLevel(2);
      if(.com.powershare){
        int pmax =
          .m.max!int?(
            .chr.chars[0][0]~sysivar[.chr.iPOWERMAX],
            .chr.chars[2][0]~sysivar[.chr.iPOWERMAX]);
        .chr.chars[0][0]~sysivar[.chr.iPOWERMAX] = pmax;
        .chr.chars[2][0]~sysivar[.chr.iPOWERMAX] = pmax;
      }
    }
    if(#.chr.chars[3] > 0){
      .chr.chars[3][0]~stateInit3P();
      level[3] = .wm.getLevel(3);
      if(.com.powershare){
        int pmax =
          .m.max!int?(
            .chr.chars[1][0]~sysivar[.chr.iPOWERMAX],
            .chr.chars[3][0]~sysivar[.chr.iPOWERMAX]);
        .chr.chars[1][0]~sysivar[.chr.iPOWERMAX] = pmax;
        .chr.chars[3][0]~sysivar[.chr.iPOWERMAX] = pmax;
      }
    }
    int minlv =
      .m.min!int?(level[0])<, .m.min!int?(level[1])<,
      .m.min!int?(level[2])<, level[3];
    int maxlv =
      .m.max!int?(level[0])<, .m.max!int?(level[1])<,
      .m.max!int?(level[2])<, level[3];
    branch{
    cond minlv > 0 && maxlv > 0:
      level[0] -= minlv;
      level[1] -= minlv;
      level[2] -= minlv;
      level[3] -= minlv;
    cond minlv < 0 && maxlv < 0:
      level[0] -= maxlv;
      level[1] -= maxlv;
      level[2] -= maxlv;
      level[3] -= maxlv;
    }
    loop{index i = 0; do:
      if(#.chr.chars[i] == 0) continue;
      .chr.players.add(.chr.chars[i][0]);
      {
        float lm = (float).chr.chars[i][0]~sysivar[.chr.iLIFEMAX];
        lm *= (float).cfg.Life / 100.0;
        switch(.com.tmode[i&1]){
        case (int).com.TeamMode::Single:
          if(.com.tmode[i+1 & 1] != (int).com.TeamMode::Single){
            lm *= (float).cfg.Team_1VS2Life / 100.0;
          }
        case (int).com.TeamMode::Simul:<-
          if(.com.tmode[i+1 & 1] == (int).com.TeamMode::Turns){
            lm *=
              300.0 / (
                (float).chr.fight~ro.match_wins * (float).cfg.Team_1VS2Life);
          }
        case (int).com.TeamMode::Turns:
          lm *= 3.0 / (float).com.numturns[i&1];
        }
        double hoge = .lvmul**((double)-level[i]);
        .chr.chars[i][0]~sysivar[.chr.iLIFEMAX] = (int).m.ceil(hoge * lm);
        if(.com.rexisted[i&1] > 0){
          .chr.chars[i][0]~sysivar[.chr.iLIFE] =
            (int).m.ceil(hoge * (float).chr.chars[i][0]~sysivar[.chr.iLIFE]);
        }
      }
      if(
        .com.round == 1 || (
          .com.tmode[i&1] == (int).com.TeamMode::Turns
          && .com.rexisted[i&1] == 0))
      {
        .chr.chars[i][0]~sysivar[.chr.iLIFE] =
          .chr.chars[i][0]~sysivar[.chr.iLIFEMAX];
        if(.com.round == 1) .chr.chars[i][0]~sysivar[.chr.iPOWER] = 0;
      }
      copyVar(i);
    continue:
      i++;
    while i < #.chr.chars:
    }
    oldp1wins = .com.p1wins;
    oldp2wins = .com.p2wins;
    olddraws = .com.draws;
    .chr.stg~reset();//bgctrlの都合(循環参照可能な型を操作する)でここでreset
    loop{int i = 0; while; do:
      .chr.stg~action();
      i++;
    while i < stagetime:
    }
    if(.com.round == 1) .sdl.playBGM("plugins", .chr.stg~bgmusic);
    reset();
    float bl = (float)(.chr.stg~cam.boundleft - .chr.stg~cam.startx);
    float br = (float)(.chr.stg~cam.boundright - .chr.stg~cam.startx);
    float bt = (float).chr.stg~cam.boundhigh;
    float xminscl = (float).com.GameWidth / (320.0+(float)(-bl + br));
    float yminscl = (float).com.GameHeight / (240.0-bt);
    float minscl =
      .m.max!float?(.cfg.MinScale)<, .m.min!float?(.cfg.MaxScale)<,
      .m.max!float?(xminscl, yminscl);
    float tmp;
  do:
    if(.com.keyDown(.com.KeyEvent::CtrlC)) .com.clsndraw!!;
    if(.com.keyDown(.com.KeyEvent::CtrlD)) .com.debugdraw!!;
    if(#.cmd.net == 0 && #.cmd.replay == 0){
      if(.com.keyDown(.com.KeyEvent::Pause)) .com.pause!!;
      if(.com.keyDown(.com.KeyEvent::CtrlS)) branch{
      cond .com.accel >= 4.0:
        .com.accel = 0.25;
      else:
        .com.accel *= 2.0;
      }
      if(.com.keyDown(.com.KeyEvent::F4)) reset();
      if(.com.keyDown(.com.KeyEvent::ShiftF4)){
        .mes.SetSharedString(:"reload":);
        ret;
      }
    }
    if(.chr.roundOver()) branch{
      .com.round++;
      loop{index i = 0; while; do:
        .com.rexisted[i]++;
        i++;
      while i < #.com.tmode:
      }
      if(.com.time > 0) loop{index i = 0; while; do:
        if(
          .com.tmode[i] == (int).com.TeamMode::Turns
          && .chr.chars[i][0]~isWin())
        {
          .chr.chars[i][0]~sysivar[.chr.iLIFE] +=
            (int)(
              (float).chr.chars[i][0]~sysivar[.chr.iLIFEMAX]
              * (float).com.time * (1.0/60.0) * .cfg.TurnsRecoveryRate);
          .m.limMax!int?(
            .chr.chars[i][0]~sysivar[.chr.iLIFE]=,
            .chr.chars[i][0]~sysivar[.chr.iLIFEMAX]);
        }
        i++;
      while i < #.com.tmode:
      }
    cond
      .com.p1wins < .com.p1mw && .com.p2wins < .com.p2mw
      && (
        .com.tmode[0] != (int).com.TeamMode::Turns
        || .chr.chars[0][0]~isWin())
      && (
        .com.tmode[1] != (int).com.TeamMode::Turns
        || .chr.chars[1][0]~isWin())
      :
      loop{index i = 0; while; do:
        if(
          .com.tmode[i] != (int).com.TeamMode::Turns
          || !.chr.chars[i][0]~isWin())
        {
          .chr.chars[i][0]~sysivar[.chr.iLIFE] =
            .chr.chars[i][0]~sysivar[.chr.iLIFEMAX];
          if(#.chr.chars[i+2] > 0){
            .chr.chars[i+2][0]~sysivar[.chr.iLIFE] =
              .chr.chars[i+2][0]~sysivar[.chr.iLIFEMAX];
            copyVar(i+2);
          }
        }
        copyVar(i);
        i++;
      while i < #.com.tmode:
      }
      oldp1wins = .com.p1wins;
      oldp2wins = .com.p2wins;
      olddraws = .com.draws;
      reset();
    else:
      loop{index i = 0; while; do:
        branch{
          double hoge;
        cond
          .chr.chars[i][0]~isWin() || (
            !.chr.chars[i][0]~isLose()
            && .com.tmode[i] != (int).com.TeamMode::Turns)
          :
          hoge = .lvmul**(double)level[i];
          .chr.chars[i][0]~sysivar[.chr.iLIFE] =
            .m.max!int?(1)<, (int).m.ceil(
              hoge * (float)(
                .chr.chars[i][0]~isWin()
                ? .chr.chars[i][0]~sysivar[.chr.iLIFE]
                : .chr.chars[i][0]~sysivar[.chr.iLIFEMAX]));
          if(#.chr.chars[i+2] > 0){
            hoge = .lvmul**(double)level[i+2];
            .chr.chars[i+2][0]~sysivar[.chr.iLIFE] =
              .m.max!int?(1)<, (int).m.ceil(
                hoge * (float)(
                  .chr.chars[i+2][0]~isWin()
                  ? .chr.chars[i+2][0]~sysivar[.chr.iLIFE]
                  : .chr.chars[i+2][0]~sysivar[.chr.iLIFEMAX]));
          }
        else:
          .chr.chars[i][0]~sysivar[.chr.iLIFE] = 0;
        }
        i++;
      while i < #.com.tmode:
      }
      break, break;
    }
    if(.com.turbo < 1.0) sclmul **= .com.turbo;
    scl *= sclmul;
    branch{
    cond !.cfg.Zoom:
      scl = 1.0;
    else:
      scl = .m.max!float?(minscl)<, .m.min!float?(.cfg.MaxScale)<, scl;
    }
    tmp =
      #((l + r) - (newx - x)*2.0) < ((float).com.GameWidth/4.0)/scl
      ? ((float).com.GameWidth/2.0)/scl
      : .m.max!float?(0.0)<, .m.min!float?(((float).com.GameWidth/2.0)/scl)<,
      .m.max!float?(-(l-(newx-x)), r-(newx-x));
    x =
      (float).com.GameWidth > br - bl + 320.0
      ? 0.0
      : .m.max!float?(bl-160.0 + ((float).com.GameWidth/2.0)/scl)<,
      .m.min!float?(br+160.0 - ((float).com.GameWidth/2.0)/scl)<,
      .m.min!float?(x + l + tmp)<, .m.max!float?(x + r - tmp)<, newx;
    tmp = .m.max!float?(0.0, 240.0 - (float).chr.stg~zoffset);
    y =
      .m.min!float?(0.0)<, 
      .m.min!float?(tmp*(1.0/scl - 1.0))<,
      .m.max!float?(
        bt-240.0 + .m.max!float?(
          (float).com.GameHeight/scl, tmp + (float).chr.stg~zoffset/scl),
        newy + 240.0*(1.0 - .m.min!float?(1.0, scl)));
    if(
      .com.tickFrame() && (.chr.super <= 0 || .chr.superpausebg == 0)
      && (.chr.pause <= 0 || .chr.pausebg == 0)) 
    {
      .chr.stg~action();
      stagetime++;
    }
    newx = x;
    newy = y;
    sclmul = .chr.action(newx=, newy=, l=, r=, scl);
    if(!.com.addFrameTime(.com.turbo)){
      if(!.se.eventUpdate()) break, while;
      break, do;
    }
    if(.se.fskip) while;
    .chr.draw(x, y, scl);
    drawDebug();
  /?/*.cfg.OpenGL:
    .sdl.GlSwapBuffers(::);
  /*true:
    .sdl.screen.flip();
  /*?*/
  while !.se.esc && .cmd.update():
    if(.se.esc) .mes.SetSharedString(:"esc":);
  break:
    .chr.stg~bgctl.clear();//bgctrlをでfightingで開放
    if(#.cmd.net > 0) .cmd.net~stop();
    share~copy();
    share~stt = stagetime;
    oldshare.copyToRef!&.sha.Share?(share=);
  }
}

void main()
{
  if(!.sdl.shareScreen(.cfg.OpenGL)){
    .al.alert!.self?("初期化に失敗");
    ret;
  }
  ret .game();
}

main();

if(se.end) mes.SetSharedString(:"end":);


