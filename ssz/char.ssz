
lib file = <file.ssz>;
lib s = <string.ssz>;
lib sdl = <alpha/sdlplugin.ssz>;
lib consts = <consts.ssz>;
lib m = <math.ssz>;
lib se = <alpha/sdlevent.ssz>;
lib sff = "sff.ssz";
lib cmd = "command.ssz";
lib stage = "stage.ssz";
lib com = "common.ssz";
lib cfg = "config.ssz";
lib snd = "sound.ssz";
lib fgt = "fight.ssz";
lib act = "action.ssz";
lib mes = <alpha/mesdialog.ssz>;


int changeStateNest = 0;
float oldx = 0.0;
int slowt = 0, shuttertime = 0;
bool winskipped = false;

public float zoomdelay = 0.0;

|fgt.KOTy ko = fgt.KOTy::NotYet;
^|fgt.WinTy winty.new(2);
winty[0] = fgt.WinTy::N;
winty[1] = fgt.WinTy::N;

public ^&.stage.Stage stg;

^uint tmppl.new(256);

%&act.DrawnClsn drawc1, drawc2, drawc2sp, drawwh;
void resetDrawnClsnList()
{
  .drawc1.new(0);
  .drawc2.new(0);
  .drawc2sp.new(0);
  .drawwh.new(0);
}
void drawClsn()
{
  ^ubyte pxl;
  ^uint pal;
  pxl.new(1);
  pxl<> = 0x0;
  pal.new(256);
  pal<> = 0xff0000;
  loop{index i = 0; while; do:
    .drawc1[i].draw(pxl, pal, (int)0x3feff);
    i++;
  while i < #.drawc1:
  }
  pal<> = 0x0000ff;
  loop{index i = 0; while; do:
    .drawc2[i].draw(pxl, pal, (int)0x3feff);
    i++;
  while i < #.drawc2:
  }
  pal<> = 0x00ff00;
  loop{index i = 0; while; do:
    .drawc2sp[i].draw(pxl, pal, (int)0x3feff);
    i++;
  while i < #.drawc2sp:
  }
  pal<> = 0x404040;
  loop{index i = 0; while; do:
    .drawwh[i].draw(pxl, pal, (int)0x3feff);
    i++;
  while i < #.drawwh:
  }
}

&AnimList
{
  public ^&.act.Action anim;
  public int priority = 0;
  public float x = 0.0, y = 0.0, cscl = 1.0;
  public float xscl = 1.0, yscl = 1.0, angle = 0.0, axscl = 1.0, ayscl = 1.0;
  public bool aset = false;
  public int salpha = -1, dalpha = 0, bright = 256;
  public ^&.com.PalFX fx;
  public ^self next;
}

^&AnimList anims, topanims;

&ShadowList
{
  public ^&.AnimList al;
  public int color;
  public float offsety = 0.0;
  public ^self next;
}

^&ShadowList shadows;

public void addAnimList(
  ^&.AnimList al=, ^&.act.Action a, int p,
  float x, float y, float cs, float xs, float ys,
  float an, bool as, float ax, float ay,
  int sa, int da, int b, ^&.com.PalFX fx, int sc, float so)
{
  void newdainyuu(^&.AnimList anl=)
  {
    anl.new(1);
    anl~anim = `a;
    anl~priority = `p;
    anl~x = `x;
    anl~y = `y;
    anl~cscl = `cs;
    anl~xscl = `xs;
    anl~yscl = `ys;
    anl~angle = `an;
    anl~aset = `as;
    anl~axscl = `ax;
    anl~ayscl = `ay;
    anl~salpha = `sa;
    anl~dalpha = `da;
    anl~bright = `b;
    anl~fx = `fx;
    if(`sc != 0){
      .addShadowList(anl, `sc, `so);
    }
  }
  ^&.AnimList tmp = al;
  branch{
  cond<a> #al == 0:
  cond<b> p <= al~priority:
  else:
    break;
  comm:
    newdainyuu(al=);
  diff<b>:
    al~next = tmp;
  comm:
    ret;
  }
  loop{while; do:
    if(p <= tmp~next~priority){
      ^&.AnimList tmp2 = tmp~next;
      newdainyuu(tmp~next=);
      tmp~next~next = tmp2;
      break, break;
    }
    tmp = tmp~next;
  while #tmp~next > 0:
    newdainyuu(tmp~next=);
  }
}

public void drawAnimList(^&.AnimList al=, float x, float y)
{
  loop{while; do:
    if(#al~anim > 0){
      al~anim~ani.salpha = al~salpha;
      al~anim~ani.dalpha = al~dalpha;
      branch{
        int ob = .com.brightness;
        .com.brightness = al~bright;
        float cs = al~cscl;
      cond al~angle != 0.0:
        al~anim~ani.angleDraw(
          .com.xoffset-(x-al~x)*cs, .com.zoffset+.com.yoffset-(y-al~y)*cs,
          cs*al~xscl, cs*al~yscl, al~angle*(.m.PI/180.0),
          al~aset, al~axscl, al~ayscl,
          #al~fx != 0 && al~fx~time != 0 ? al~fx : .com.allPalFX);
      else:
        al~anim~ani.draw(
          .com.scrrect=, .com.xoffset/cs - (x-al~x),
          (.com.zoffset+.com.yoffset)/cs - (y-al~y), cs, cs,
          al~xscl, al~xscl, al~yscl, 0.0, 160.0,
          #al~fx != 0 && al~fx~time != 0 ? al~fx : .com.allPalFX);
      break:
        .com.brightness = ob;
      }
    }
    al = al~next;
  while #al > 0:
  }
}

public void addShadowList(^&.AnimList al, int sc, float so)
{
  void newdainyuu(^&.ShadowList shl=)
  {
    shl.new(1);
    shl~al = `al;
    shl~color = `sc;
    shl~offsety = `so;
  }
  int p = al~priority;
  ^&.ShadowList tmp = .shadows;
  branch{
  cond<a> #.shadows == 0:
  cond<b> p <= .shadows~al~priority:
  else:
    break;
  comm:
    newdainyuu(.shadows=);
  diff<b>:
    .shadows~next = tmp;
  comm:
    ret;
  }
  loop{while; do:
    if(p <= tmp~next~al~priority){
      ^&.ShadowList tmp2 = tmp~next;
      newdainyuu(tmp~next=);
      tmp~next~next = tmp2;
      break, break;
    }
    tmp = tmp~next;
  while #tmp~next > 0:
    newdainyuu(tmp~next=);
  }
}

public void drawShadowList(float x, float y)
{
  ^&.ShadowList sl = .shadows;
  ^uint pal, oldpal;
  loop{while; do:
    if(
      #sl~al~anim == 0 || #sl~al~anim~ani.spr == 0) continue;
    branch{
    cond sl~color < 0:
      pal = .stg~sdw.pal;
      {
        int inte = .stg~sdw.intensity;
        branch{
        cond sl~al~y < (float).stg~sdw.fadeend:
          break, break, break, continue;
        cond sl~al~y < (float).stg~sdw.fadebgn:
          inte =
            (int)(
              (float)inte * ((float).stg~sdw.fadeend - sl~al~y)
              / ((float).stg~sdw.fadeend - (float).stg~sdw.fadebgn));
        }
        sl~al~anim~ani.salpha = inte;
        sl~al~anim~ani.dalpha = 255 - inte;
      }
    else:
      pal = .tmppl;
      loop{index i = 0; do: pal[i] = (uint)sl~color; while ++i < 256:}
      sl~al~anim~ani.salpha = 1;
      sl~al~anim~ani.dalpha = 255;
    }
    {
      oldpal = sl~al~anim~ani.spr~colorPallet;
      sl~al~anim~ani.spr~colorPallet = pal;
      float syscl = .stg~sdw.yscale;
      branch{
        float cs = sl~al~cscl;
      cond sl~al~angle != 0.0:
        {
          float agl = sl~al~angle*(.m.PI/180.0);
          float ss = syscl < 0.0 ? -1.0 : 1.0;//pow用
          sl~al~anim~ani.angleDraw(
            .com.xoffset-(x-sl~al~x)*cs,
            .com.zoffset + .com.yoffset - (y+sl~al~y*syscl-sl~offsety)*cs,
            cs*sl~al~xscl * ss * (ss*syscl)**#.m.sin(agl),
            cs*-sl~al~yscl * ss * (ss*syscl)**#.m.cos(agl),
            agl, sl~al~aset, sl~al~axscl, sl~al~ayscl,
           .com.allPalFX~time != 0 ? .com.allPalFX : .stage.bgPalFX);
        }
      else:
        sl~al~anim~ani.draw(
          .com.scrrect=, .com.xoffset/cs - (x-sl~al~x),
          (.com.zoffset+.com.yoffset)/cs - (y+sl~al~y*syscl-sl~offsety),
          cs, cs, sl~al~xscl, sl~al~xscl, -sl~al~yscl*syscl, 0.0,
          160.0, .com.allPalFX~time != 0 ? .com.allPalFX : .stage.bgPalFX);
      }
    break:
      sl~al~anim~ani.spr~colorPallet = oldpal;
    }
  continue:
    sl = sl~next;
  while #sl > 0:
  }
}

public void drawReflection(float x, float y)
{
  ^&.ShadowList sl = .shadows;
  loop{while; do:
    if(#sl~al~anim > 0 && #sl~al~anim~ani.frames > 0){
      if(sl~al~salpha < 0){
        sl~al~salpha =
          (int)
            sl~al~anim~ani.frames[sl~al~anim~ani.drawidx].salpha;
        sl~al~dalpha =
          (int)
            sl~al~anim~ani.frames[sl~al~anim~ani.drawidx].dalpha;
      }
      sl~al~anim~ani.salpha =
        (int)((float)sl~al~salpha*(float).stg~reflection / 255.0);
      sl~al~anim~ani.dalpha =
        .m.min!int?(255, sl~al~dalpha + (255-.stg~reflection));
      if(
        sl~al~anim~ani.salpha == 1
        && sl~al~anim~ani.dalpha == 255)
      {
        sl~al~anim~ani.salpha = 0;
      }
      branch{
        float cs = sl~al~cscl;
      cond sl~al~angle != 0.0:
        sl~al~anim~ani.angleDraw(
          .com.xoffset-(x-sl~al~x)*cs,
          .com.zoffset+.com.yoffset-(y+sl~al~y-sl~offsety)*cs,
          cs*sl~al~xscl, cs*-sl~al~yscl, sl~al~angle*(.m.PI/180.0),
          sl~al~aset, sl~al~axscl, sl~al~ayscl,
          #sl~al~fx > 0 && sl~al~fx~time != 0 ? sl~al~fx
          : (.com.allPalFX~time != 0 ? .com.allPalFX : .stage.bgPalFX));
      else:
        sl~al~anim~ani.draw(
          .com.scrrect=, .com.xoffset/cs - (x-sl~al~x),
          (.com.zoffset+.com.yoffset)/cs - (y+sl~al~y-sl~offsety),
          cs, cs, sl~al~xscl, sl~al~xscl, -sl~al~yscl, 0.0, 160.0,
          #sl~al~fx != 0 && sl~al~fx~time > 0 ? sl~al~fx
          : (.com.allPalFX~time != 0 ? .com.allPalFX : .stage.bgPalFX));
      }
    }
    sl = sl~next;
  while #sl > 0:
  }
}


&AfterImage
{
  &ImgInfo
  {
    public ^&.act.Action anim;
    public float x = 0.0, y = 0.0, xscl = 1.0, yscl = 1.0;
    public float angle = 0.0, axscl = 1.0, ayscl = 1.0;
    public bool aset = false;
    new()
    {
      `anim.new(1);
    }
  }
  public int time;
  public int length;
  public int postbrightr;
  public int postbrightg;
  public int postbrightb;
  public int addr;
  public int addg;
  public int addb;
  public float mulr;
  public float mulg;
  public float mulb;
  public int timegap;
  public int framegap;
  public int alphas;
  public int alphad;
  public ^&.com.PalFX palfx;
  public ^&ImgInfo imgs;
  public int imgidx;
  public int restgap;
  public int reccount;
  new()
  {
    `palfx.new(.cfg.AfterImageMax);
    loop{index i = 0; do: `palfx[i].time = -1; while ++i < #`palfx:}
    `clear();
    `timegap = 0;
    `imgs.new(64);
  }
  public void clear()
  {
    `time = 0;
    `length = 20;
    `palfx~color = 1.0;
    `palfx~invertall = 0;
    `palfx~addr = 30;
    `palfx~addg = 30;
    `palfx~addb = 30;
    `palfx~mulr = 120.0 / 256.0;
    `palfx~mulg = 120.0 / 256.0;
    `palfx~mulb = 220.0 / 256.0;
    `postbrightr = 0;
    `postbrightg = 0;
    `postbrightb = 0;
    `addr = 10;
    `addg = 10;
    `addb = 25;
    `mulr = 0.65;
    `mulg = 0.65;
    `mulb = 0.75;
    `timegap = 1;
    `framegap = 6;
    `alphas = -1;
    `alphad = 0;
    `imgidx = 0;
    `restgap = 0;
    `reccount = 0;
  }
  public void setupPalfx()
  {
    loop{
      index i = 1;
      int pbr = `postbrightr, pbg = `postbrightg, pbb = `postbrightb;
      while;
    do:
      `palfx[i].color = `palfx[i-1].color;
      `palfx[i].invertall = `palfx[i-1].invertall;
      `palfx[i].addr = `palfx[i-1].addr + `addr + pbr;
      `palfx[i].addg = `palfx[i-1].addg + `addg + pbg;
      `palfx[i].addb = `palfx[i-1].addb + `addb + pbb;
      pbr = pbg = pbb = 0;
      `palfx[i].mulr = `palfx[i-1].mulr * `mulr;
      `palfx[i].mulg = `palfx[i-1].mulg * `mulg;
      `palfx[i].mulb = `palfx[i-1].mulb * `mulb;
      i++;
    while i < #`palfx:
    }
  }
  public void recAfterImg(
    &.act.Action a=, float x, float y, float xs, float ys,
    float an, bool as, float ax, float ay)
  {
    if(`time == 0){
      `reccount = `timegap = 0;
      ret;
    }
    if(`time > 0) `time--;
    if(`restgap <= 0){
      `imgs[`imgidx].anim~copy(a=);
      `imgs[`imgidx].x = x;
      `imgs[`imgidx].y = y;
      `imgs[`imgidx].xscl = xs;
      `imgs[`imgidx].yscl = ys;
      `imgs[`imgidx].angle = an;
      `imgs[`imgidx].aset = as;
      `imgs[`imgidx].axscl = ax;
      `imgs[`imgidx].ayscl = ay;
      `imgidx = `imgidx+1 & 63;
      if(`reccount < #`imgs) `reccount++;
      `restgap = `timegap;
    }
    `restgap--;
  }
  public void recAndAddAL(
    &.act.Action a=, int p,
    float x, float y, float xs, float ys,
    float an, bool as, float ax, float ay, bool rec, int br)
  {
    if(
      `time == 0 || !.m.inRange!int?(1, 32767, `timegap)
      || !.m.inRange!int?(1, 32767, `framegap))
    {
      `time = 0;
      `reccount = `timegap = 0;
      ret;
    }
    loop{
      index i = `framegap;
      index end = (.m.min!int?(`reccount, `length)/`framegap) * `framegap;
      .m.limMax!index?(end=, .cfg.AfterImageMax*`framegap);
      while;
    do:
      .addAnimList(
        .anims=, `imgs[`imgidx-i&63].anim, p-2,
        `imgs[`imgidx-i&63].x, `imgs[`imgidx-i&63].y, .com.scale,
        `imgs[`imgidx-i&63].xscl, `imgs[`imgidx-i&63].yscl,
        `imgs[`imgidx-i&63].angle, `imgs[`imgidx-i&63].aset,
        `imgs[`imgidx-i&63].axscl, `imgs[`imgidx-i&63].ayscl,
        `alphas, `alphad, br, `palfx[i/`framegap - 1 .. i/`framegap], 0, 0.0);
      i += `framegap;
    while i <= end:
    }
    if(rec) `recAfterImg(a=, x, y, xs, ys, an, as, ax, ay);
  }
}


void pLrSet(float dl=, float dr=, float sl, float sr)
{
  dl = sl;
  dr = sr;
}
void mLrSet(float dl=, float dr=, float sl, float sr)
{
  dl = -sr;
  dr = -sl;
}


|VarTy
{
  Int, Float, SFalse
}
public &Var
{
  public |.VarTy typ = .VarTy::Int;
  public int i = 0;
  public float f = 0.0;
  public void setI(int i)
  {
    if(i == .com.IERR){
      `setSF();
      ret;
    }
    `typ = .VarTy::Int;
    `i = i;
  }
  public void setF(float f)
  {
    if(f == .com.FERR){
      `setSF();
      ret;
    }
    `typ = .VarTy::Float;
    `f = f;
  }
  public void setB(bool b)
  {
    `typ = .VarTy::Int;
    `i = (int)b;
  }
  public void setSF()
  {
    `typ = .VarTy::SFalse;
  }
  const bool isTrue()
  {
    if(`isSF()) ret false;
    if(`typ == .VarTy::Int) ret `i != 0;
    ret `f != 0.0;
  }
  const bool isSF()
  {
    ret `typ == .VarTy::SFalse;
  }
  const int toInt()
  {
    if(`isSF()) ret .com.IERR;
    if(`typ == .VarTy::Int) ret `i;
    ret (int)`f;
  }
  const float toFloat()
  {
    if(`isSF()) ret .com.FERR;
    if(`typ == .VarTy::Int) ret (float)`i;
    ret `f;
  }
}
public &Var v;//work
public ^&Char c;//work
type _t = $void(&Char=);

void appendToClipboard(int p, ^/char text, ^&.Var vars)
{
  loop{
    index i = 0, vi = 0;
    .com.clipboardText[p].new[-1];
    if(#.com.clipboardText[p] > 40){
      ^%char tmp = .com.clipboardText[p][#.com.clipboardText[p]-40..-1];
      .com.clipboardText[p].new(0);
      .com.clipboardText[p] .= tmp;
    }
    ^%char line = .com.clipboardText[p][#.com.clipboardText[p]-1..-1];
    while;
  do:
    switch(text[i]){
    case '%':
      switch(text[++i]){
      case '%':
        line<> .= '%';
      case 'd':
        if(#vars > 0) line<> .= .s.iToS(vars[vi++].toInt());
      case 'f':
        if(#vars > 0){
          ^char tmp;
          .mes.DoubleToStr(:tmp=, vars[vi++].toFloat():);
          line<> .= tmp;
        }
      default:
        line<> .= '%' .= text[i];
      }
    case '\\':
      switch(text[++i]){
      case '\\':
        line<> .= '\\';
      case 'n':
        .com.clipboardText[p].new[-1];
        line = .com.clipboardText[p][#.com.clipboardText[p]-1..-1];
      case 't':
        loop{index j = 0, n = 8 - #line<>%8; do:
          line<> .= ' ';
          j++;
        while j < n:
        }
      default:
        line<> .= '\\' .= text[i];
      }
    default:
      line<> .= text[i];
    }
    i++;
  while i < #text:
  }
}

|StTy
{
  S=0x1, C=0x2, A=0x4, L=0x8, N=0x10, U=0x20//L->D N->F U->P
}
|AtTy
{
  NA=   0x40, NT=   0x80, NP=  0x100,
  SA=  0x200, ST=  0x400, SP=  0x800,
  HA= 0x1000, HT= 0x2000, HP= 0x4000
}
|MovTy
{
  I=0x8000, A, H=0x10000, U//I->- H->+
}
|AnimTy
{
  Light, Medium, Hard, Back, Up, Diagup, Unknown
}
|PriTy
{
  Hit, Miss, Dodge
}
|ReactTy
{
  Non, High, Low, Trip, Unknown
}
&Fall
{
  public |.AnimTy animtype;
  public float xvelocity;
  public float yvelocity;
  public int recover;
  public int recovertime;
  public int damage;
  public int kill;
  public int envshake_time;
  public float envshake_freq;
  public float envshake_ampl;
  public float envshake_phase;
  public void clear()
  {
    `animtype = .AnimTy::Unknown;
    `xvelocity = .com.FERR;
    `yvelocity = -4.5;
    `recover = 1;
    `recovertime = 4;
    `damage = 0;
    `kill = 1;
    `envshake_time = 0;
    `envshake_freq = 60.0;
    `envshake_ampl = -4.0;
    `envshake_phase = .com.FERR;
  }
}
&Hitdef
{
  public int attr;
  public int reversal_attr;
  public int hitflag;
  public int guardflag;
  public int affectteam;
  public |.AnimTy animtype;
  public |.AnimTy air_animtype;
  public int priority;
  public |.PriTy bothhittype;
  public int hitdamage;
  public int guarddamage;
  public int pausetime;
  public int shaketime;
  public int guard_pausetime;
  public int guard_shaketime;
  public int sparkno;
  public int guard_sparkno;
  public float sparkx;
  public float sparky;
  public int hitsoundg;
  public int hitsoundn;
  public int guardsoundg;
  public int guardsoundn;
  public |.ReactTy ground_type;
  public |.ReactTy air_type;
  public int ground_slidetime;
  public int guard_slidetime;
  public int ground_hittime;
  public int guard_hittime;
  public int air_hittime;
  public int guard_ctrltime;
  public int airguard_ctrltime;
  public int guard_dist;
  public float yaccel;
  public float ground_velocityx;
  public float ground_velocityy;
  public float guard_velocity;
  public float air_velocityx;
  public float air_velocityy;
  public float airguard_velocityx;
  public float airguard_velocityy;
  public float ground_cornerpush_veloff;
  public float air_cornerpush_veloff;
  public float down_cornerpush_veloff;
  public float guard_cornerpush_veloff;
  public float airguard_cornerpush_veloff;
  public int air_juggle;
  public int p1sprpriority;
  public int p2sprpriority;
  public int p1getp2facing;
  public int p1facing;
  public int p2facing;
  public int p1stateno;
  public int p2stateno;
  public int p2getp1state;
  public int forcestand;
  public int ground_fall;
  public int air_fall;
  public float down_velocityx;
  public float down_velocityy;
  public int down_hittime;
  public int down_bounce;
  public int id;
  public int chainid;
  public int nochainid1;
  public int nochainid2;
  public int hitonce;
  public int kill;
  public int guard_kill;
  public int numhits;
  public int hitgetpower;
  public int guardgetpower;
  public int hitgivepower;
  public int guardgivepower;
  public int palfx_time;
  public int palfx_mulr;
  public int palfx_mulg;
  public int palfx_mulb;
  public int palfx_addr;
  public int palfx_addg;
  public int palfx_addb;
  public int palfx_amplr;
  public int palfx_amplg;
  public int palfx_amplb;
  public int palfx_cycletime;
  public int palfx_color;
  public int palfx_invertall;
  public int envshake_time;
  public float envshake_freq;
  public float envshake_ampl;
  public float envshake_phase;
  public float mindistx;
  public float maxdistx;
  public float mindisty;
  public float maxdisty;
  public int forcenofall;
  public &.Fall fall;
  public void clear()
  {
    `attr = 0;
    `reversal_attr = 0;
    `hitflag = (int).StTy::S | (int).StTy::C | (int).StTy::A | (int).StTy::N;
    `guardflag = 0;
    `affectteam = 1;
    `animtype = .AnimTy::Light;
    `air_animtype = .AnimTy::Unknown;
    `priority = 4;
    `bothhittype = .PriTy::Hit;
    `hitdamage = 0;
    `guarddamage = 0;
    `pausetime = 0;
    `shaketime = 0;
    `guard_pausetime = -1;
    `guard_shaketime = -1;
    `sparkno = .com.IERR;
    `guard_sparkno = .com.IERR;
    `sparkx = 0.0;
    `sparky = 0.0;
    `hitsoundg = .com.IERR;
    `hitsoundn = -1;
    `guardsoundg = .com.IERR;
    `guardsoundn = -1;
    `ground_type = .ReactTy::High;
    `air_type = .ReactTy::Unknown;
    `ground_slidetime = 0;
    `guard_slidetime = -1;
    `ground_hittime = 0;
    `guard_hittime = -1;
    `air_hittime = 20;
    `guard_ctrltime = -1;
    `airguard_ctrltime = -1;
    `guard_dist = -1;
    `yaccel = .com.FERR;
    `ground_velocityx = 0.0;
    `ground_velocityy = 0.0;
    `guard_velocity = .com.FERR;
    `air_velocityx = 0.0;
    `air_velocityy = 0.0;
    `airguard_velocityx = .com.FERR;
    `airguard_velocityy = .com.FERR;
    `ground_cornerpush_veloff = .com.FERR;
    `air_cornerpush_veloff = .com.FERR;
    `down_cornerpush_veloff = .com.FERR;
    `guard_cornerpush_veloff = .com.FERR;
    `airguard_cornerpush_veloff = .com.FERR;
    `air_juggle = 0;
    `p1sprpriority = 1;
    `p2sprpriority = 0;
    `p1getp2facing = 0;
    `p1facing = 0;
    `p2facing = .com.IERR;
    `p1stateno = -1;
    `p2stateno = -1;
    `p2getp1state = 1;
    `forcestand = .com.IERR;
    `ground_fall = 0;
    `air_fall = .com.IERR;
    `down_velocityx = .com.FERR;
    `down_velocityy = .com.FERR;
    `down_hittime = 0;
    `down_bounce = 0;
    `id = 0;
    `chainid = -1;
    `nochainid1 = -1;
    `nochainid2 = -1;
    `hitonce = 0;
    `kill = 1;
    `guard_kill = 1;
    `numhits = 1;
    `hitgetpower = .com.IERR;
    `guardgetpower = .com.IERR;
    `hitgivepower = .com.IERR;
    `guardgivepower = .com.IERR;
    `palfx_time = 0;
    `palfx_mulr = 256;
    `palfx_mulg = 256;
    `palfx_mulb = 256;
    `palfx_addr = 0;
    `palfx_addg = 0;
    `palfx_addb = 0;
    `palfx_amplr = 0;
    `palfx_amplg = 0;
    `palfx_amplb = 0;
    `palfx_cycletime = 0;
    `palfx_color = 256;
    `palfx_invertall = 0;
    `envshake_time = 0;
    `envshake_freq = 60.0;
    `envshake_ampl = -4.0;
    `envshake_phase = .com.FERR;
    `mindistx = .com.FERR;
    `maxdistx = .com.FERR;
    `mindisty = .com.FERR;
    `maxdisty = .com.FERR;
    `forcenofall = 0;
    `fall.clear();
  }
  public void invalidate()
  {
    `attr |= (int)0x80000000;
    `reversal_attr |= (int)0x80000000;
  }
}
&HitBy
{
  public %int byid;
  public int hitf1;
  public int hitt1;
  public int hitf2;
  public int hitt2;
  public int attr;
  public int typ;
  public int airanimtype;
  public int groundanimtype;
  public int airtype;
  public int groundtype;
  public int damage;
  public int absdamage;
  public int hitcount;
  public int fallcount;
  public int hitshaketime;
  public int hittime;
  public int slidetime;
  public int ctrltime;
  public float xvel;
  public float yvel;
  public float yaccel;
  public int hitid;
  public int chainid;
  public int nochainid1;
  public int nochainid2;
  public int guarded;
  public int fallf;
  public int juggle;
  public int p1getp2facing;
  public float mindistx;
  public float maxdistx;
  public float mindisty;
  public float maxdisty;
  public &.Fall fall;
  public void clear()
  {
    `byid.new(0);
    `hitf1 = 0;
    `hitt1 = 0;
    `hitf2 = 0;
    `hitt2 = 0;
    `attr = 0;
    `typ = -1;
    `airanimtype = 0;
    `groundanimtype = 0;
    `airtype = 0;
    `groundtype = 0;
    `damage = 0;
    `absdamage = 0;
    `hitcount = 0;
    `fallcount = 0;
    `hitshaketime = 0;
    `hittime = 0;
    `slidetime = 0;
    `ctrltime = 0;
    `xvel = 0.0;
    `yvel = 0.0;
    `yaccel = .com.FERR;
    `hitid = -1;
    `chainid = -1;
    `nochainid1 = -1;
    `nochainid2 = -1;
    `guarded = 0;
    `fallf = 0;
    `juggle = 0;
    `p1getp2facing = 0;
    `mindistx = .com.FERR;
    `maxdistx = .com.FERR;
    `mindisty = .com.FERR;
    `maxdisty = .com.FERR;
    `fall.clear();
  }
  /float getYaccel()
  {
    ret `yaccel == .com.FERR ? 0.35 : `yaccel;
  }
  /bool byidMatch(int id)
  {
    loop{index i = 0; while; do:
      if(`byid[i] == id) ret true;
      i++;
    while i < #`byid:
    }
    ret false;
  }
  public void dropByid(int id)
  {
    loop{index i = 0; while; do:
      if(`byid[i] == id){
        %int tmp .= `byid[0..i] .= `byid[i+1..-1];
        `byid = tmp;
        ret ;
      }
      i++;
    while i < #`byid:
    }
  }
  public void addByid(int id)
  {
    `dropByid(id);
    `byid .= id;
  }
}
&HitOverride
{
  public int attr;
  public int stateno;
  public int time;
  public int forceair;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `attr = 0;
    `stateno = -1;
    `time = 0;
    `forceair = 0;
  }
}
|MoveContact
{
  Hit, Guarded, Reversed
}
|ProjContact
{
  Hit, Guarded, Cancel
}
&Persistent
{
  public int p = 0;
}
&StateVal
{
  public ^&.Persistent ps;
  public int no, prevno, playerno;
  public int time;
  public |.StTy typ;
  public |.StTy phy;
  public |.MovTy mov;
  public int juggle;
  public &.Hitdef hit;
  public &.HitBy hb;
  public ^&.HitOverride ho;
  public |.MoveContact mctyp;
  public int mctime;
  new()
  {
    `ho.new(8);
    `clear();
  }
  public void clear()
  {
    `ps.new(0);
    `no = 0;
    `prevno = 0;
    `playerno = 0;
    `time = 0;
    `typ = .StTy::S;
    `phy = .StTy::N;
    `mov = .MovTy::I;
    `juggle = 0;
    `hit.clear();
    `hb.clear();
    loop{index i=0;do:`ho[i].clear();while ++i<8:}
    `mctyp = .MoveContact::Hit;
    `mctime = 0;
  }
  public int setHb(&.Hitdef hit=, bool guard, bool combo, int f)
  {
    bool cmb = combo && `hb.guarded == 0;
    int fall = `hb.fallf, hc = `hb.hitcount, fc = `hb.fallcount;
    %int bi = `hb.byid;
    int jgl = `hb.juggle;
    `hb.clear();
    `hb.byid = bi;
    `hb.juggle = jgl;
    `hb.attr = hit.attr;
    `hb.hitid = hit.id;
    `hb.chainid = hit.chainid;
    `hb.nochainid1 = hit.nochainid1;
    `hb.nochainid2 = hit.nochainid2;
    `hb.fall = hit.fall;
    `hb.yaccel = hit.yaccel;
    `hb.p1getp2facing = hit.p1getp2facing;
    `hb.mindistx = hit.mindistx;
    `hb.maxdistx = hit.maxdistx;
    `hb.mindisty = hit.mindisty;
    `hb.maxdisty = hit.maxdisty;
    if(`hb.fall.xvelocity != .com.FERR) `hb.fall.xvelocity *= (float)f;
    if(hit.forcenofall != 0) fall = 0;
    branch{
    cond `typ == .StTy::A:
      `hb.airtype = `hb.typ = (int)hit.air_type;
    else:
      `hb.groundtype = `hb.typ = (int)hit.ground_type;
    }
    `hb.airanimtype = (int)hit.air_animtype;
    `hb.groundanimtype = (int)hit.animtype;
    if(guard && ((int)`typ&hit.guardflag) != 0){
      `hb.hitshaketime = .m.max!int?(1, hit.guard_shaketime+1);
      `hb.hittime = hit.guard_hittime;
      `hb.slidetime = hit.guard_slidetime;
      `hb.guarded = 1;
      branch{
      cond `typ == .StTy::A:
        `hb.ctrltime = hit.airguard_ctrltime;
        `hb.xvel = hit.airguard_velocityx;
        `hb.yvel = hit.airguard_velocityy;
      else:
        `hb.ctrltime = hit.guard_ctrltime;
        `hb.xvel = hit.guard_velocity;
        `hb.yvel = hit.ground_velocityy;
      }
      `hb.xvel *= (float)f;
      `hb.absdamage = hit.guarddamage;
      `hb.hitcount = hc;
      ret 2 * (`hb.typ == 0 || hit.reversal_attr > 0 ? -1 : 1);
    }
    `hb.hitshaketime = .m.max!int?(1, hit.shaketime+1);
    `hb.slidetime = hit.ground_slidetime;
    branch{
    cond `typ == .StTy::A:
      `hb.hittime = hit.air_hittime;
      `hb.ctrltime = hit.air_hittime;
      `hb.xvel = hit.air_velocityx;
      `hb.yvel = hit.air_velocityy;
      `hb.fallf = hit.air_fall;
    cond `typ == .StTy::L:
      `hb.hittime = hit.down_hittime;
      `hb.ctrltime = hit.down_hittime;
      `hb.xvel = hit.down_velocityx;
      branch{
      cond hit.down_velocityy != 0.0 || hit.down_bounce == 0:
        `hb.yvel = hit.down_velocityy;
      else:
        if(hit.fall.xvelocity != .com.FERR) `hb.xvel = hit.fall.xvelocity;
        `hb.yvel = hit.fall.yvelocity;
      }
      `hb.fallf = 1;
    else:
      `hb.hittime = hit.ground_hittime;
      `hb.ctrltime = hit.ground_hittime;
      `hb.xvel = hit.ground_velocityx;
      `hb.yvel = hit.ground_velocityy;
      `hb.fallf = hit.ground_fall;
    }
    `hb.xvel *= (float)f;
    `hb.absdamage = hit.hitdamage;
    `hb.hitcount = cmb ? hc+1 : 1;
    `hb.fallcount = fc;
    `hb.fallf |= fall;
    ret 1 * (`hb.typ == 0 || hit.reversal_attr > 0 ? -1 : 1);
  }
}
const index iLIFE              = 10;
const index iLIFEMAX           = 11;
const index iPOWER             = 12;
const index iPOWERMAX          = 13;
const index iATTACK            = 14;
const index iDEFENCE           = 15;
const index iLIEDOWN_TIME      = 16;
const index iAIRJUGGLE         = 17;
const index iSPARKNO           = 18;
const index iGUARD_SPARKNO     = 19;
const index iKO_ECHO           = 20;
const index iVOLUME            = 21;
const index iINTPERSISTINDEX   = 22;
const index iFLOATPERSISTINDEX = 23;
const index iGROUND_BACK       = 24;
const index iGROUND_FRONT      = 25;
const index iAIR_BACK          = 26;
const index iAIR_FRONT         = 27;
const index iHEIGHT            = 28;
const index iATTACK_DIST       = 29;
const index iPROJ_ATTACK_DIST  = 30;
const index iPROJ_DOSCALE      = 31;
const index iHEAD_POSX         = 32;
const index iHEAD_POSY         = 33;
const index iMID_POSX          = 34;
const index iMID_POSY          = 35;
const index iSHADOWOFFSET      = 36;
const index iDRAW_OFFSETX      = 37;
const index iDRAW_OFFSETY      = 38;
const index iAIRJUMP_CNT       = 39;
const index iAIRJUMP_NUM       = 40;
const index iAIRJUMP_HEIGHT    = 41;
const index iCTRL              = 42;
const index iHITCOUNT          = 43;
const index iUNIQHITCOUNT      = 44;
const index iMOVETIMEPAUSE     = 45;
const index iMOVETIMESUPER     = 46;
const index iPAUSEMOVETIME     = 47;
const index iSUPERMOVETIME     = 48;
const index iBINDTIME          = 49;
const index iBINDTOID          = 50;
const index iBINDFACING        = 51;
const index iHITPAUSETIME      = 52;
const index iALPHAS            = 53;
const index iALPHAD            = 54;
const index iRECOVERTIME       = 55;
const index iWAITWIN           = 56;
const index iSPECIALFLAG       = 57;
const index iSYSFLAG           = 58;
const index iSYSTEMP           = 59;

const index fX                = 10;
const index fY                = 11;
const index fVX               = 12;
const index fVY               = 13;
const index fFALL_DEFENCE_MUL = 14;
const index fXSCALE           = 15;
const index fYSCALE           = 16;
const index fWALK_FWD         = 17;
const index fWALK_BACK        = 18;
const index fRUN_FWDX         = 19;
const index fRUN_FWDY         = 20;
const index fRUN_BACKX        = 21;
const index fRUN_BACKY        = 22;
const index fJUMP_NEUX        = 23;
const index fJUMP_NEUY        = 24;
const index fJUMP_BACK        = 25;
const index fJUMP_FWD         = 26;
const index fRUNJUMP_BACKX    = 27;
const index fRUNJUMP_BACKY    = 28;
const index fRUNJUMP_FWDX     = 29;
const index fRUNJUMP_FWDY     = 30;
const index fAIRJUMP_NEUX     = 31;
const index fAIRJUMP_NEUY     = 32;
const index fAIRJUMP_BACK     = 33;
const index fAIRJUMP_FWD      = 34;
const index fYACCEL           = 35;
const index fSTAND_FRICTION   = 36;
const index fCROUCH_FRICTION  = 37;
const index fBINDPOSX         = 38;
const index fBINDPOSY         = 39;
const index fANGLE            = 40;
const index fANGLESCALEX      = 41;
const index fANGLESCALEY      = 42;
const index fCLSNXSCALE       = 43;
const index fCLSNYSCALE       = 44;
const index fAIR_GETHIT_GROUNDRECOVERX                 = 45;
const index fAIR_GETHIT_GROUNDRECOVERY                 = 46;
const index fAIR_GETHIT_AIRRECOVER_MULX                = 47;
const index fAIR_GETHIT_AIRRECOVER_MULY                = 48;
const index fAIR_GETHIT_AIRRECOVER_ADDX                = 49;
const index fAIR_GETHIT_AIRRECOVER_ADDY                = 50;
const index fAIR_GETHIT_AIRRECOVER_BACK                = 51;
const index fAIR_GETHIT_AIRRECOVER_FWD                 = 52;
const index fAIR_GETHIT_AIRRECOVER_UP                  = 53;
const index fAIR_GETHIT_AIRRECOVER_DOWN                = 54;
const index fSTAND_FRICTION_THRESHOLD                  = 55;
const index fCROUCH_FRICTION_THRESHOLD                 = 56;
const index fAIR_GETHIT_GROUNDLEVEL                    = 57;
const index fAIR_GETHIT_GROUNDRECOVER_GROUND_THRESHOLD = 58;
const index fAIR_GETHIT_GROUNDRECOVER_GROUNDLEVEL      = 59;
const index fAIR_GETHIT_AIRRECOVER_THRESHOLD           = 60;
const index fAIR_GETHIT_AIRRECOVER_YACCEL              = 61;
const index fAIR_GETHIT_TRIP_GROUNDLEVEL               = 62;
const index fDOWN_BOUNCE_OFFSETX                       = 63;
const index fDOWN_BOUNCE_OFFSETY                       = 64;
const index fDOWN_BOUNCE_YACCEL                        = 65;
const index fDOWN_BOUNCE_GROUNDLEVEL                   = 66;
const index fDOWN_FRICTION_THRESHOLD                   = 67;


const int lsINVISIBLE     = 0b00000000000000000000000000000001;
const int lsNOSTANDGUARD  = 0b00000000000000000000000000000010;
const int lsNOCROUCHGUARD = 0b00000000000000000000000000000100;
const int lsNOAIRGUARD    = 0b00000000000000000000000000001000;
const int lsNOAUTOTURN    = 0b00000000000000000000000000010000;
const int lsNOJUGGLECHECK = 0b00000000000000000000000000100000;
const int lsNOSHADOW      = 0b00000000000000000000000001000000;
const int lsNOWALK        = 0b00000000000000000000000010000000;
const int lsUNGUARDABLE   = 0b00000000000000000000000100000000;
const int lsPOSFREEZEX    = 0b00000000000000000000001000000000;
const int lsPOSFREEZEY    = 0b00000000000000000000010000000000;
const int lsGRAVITY       = 0b00000000000000000000100000000000;
const int lsPLAYERPUSH    = 0b00000000000000000001000000000000;
const int lsSCREENBOUNDX  = 0b00000000000000000010000000000000;
const int lsSCREENBOUNDY  = 0b00000000000000000100000000000000;
const int lsGETHIT        = 0b00000000000000001000000000000000;
const int lsANGLEDRAW     = 0b00000000000000010000000000000000;
const int lsTRANS         = 0b00000000000000100000000000000000;
const int lsFRONTWCHANGE  = 0b00000000000001000000000000000000;
const int lsBACKWCHANGE   = 0b00000000000010000000000000000000;
const int lsFEDGECHANGE   = 0b00000000000100000000000000000000;
const int lsBEDGECHANGE   = 0b00000000001000000000000000000000;
const int lsGUARD         = 0b00000000010000000000000000000000;
const int lsBindCancel    = 0b00000000100000000000000000000000;

public uint specialFlag;
const uint gsINTRO          = 0b00000000000000000000000000000001;
const uint gsROUNDNOTOVER   = 0b00000000000000000000000000000010;
const uint gsNOBARDISPLAY   = 0b00000000000000000000000000000100;
const uint gsNOBG           = 0b00000000000000000000000000001000;
const uint gsNOFG           = 0b00000000000000000000000000010000;
const uint gsNOKOSLOW       = 0b00000000000000000000000000100000;
const uint gsGLOBALNOSHADOW = 0b00000000000000000000000001000000;
const uint gsNOMUSIC        = 0b00000000000000000000000010000000;
const uint gsTIMERFREEZE    = 0b00000000000000000000000100000000;
const uint gsNOKO           = 0b00000000000000000000001000000000;
const uint gsNOKOSND        = 0b00000000000000000000010000000000;
public bool gs(uint mask)
{
  ret (.specialFlag & mask) == mask;
}

const int sfAIRJUMP = 0b00000000000000000000000000000001;
const int sfWIN     = 0b00000000000000000000000000000010;

&PlayerList<_t>
{
  &Node<_t>
  {
    public ^_t c;
    public ^self next;
  }
  ^&Node!_t? top, end;
  public void clear()
  {
    `top.new(0);
    `end.new(0);
  }
}

public ^%^&Char chars;
^%&Projectile projs;
^%&Explod explods;
&snd.Sound syssnd;
chars.new(4);
projs.new(4);
explods.new(4);


^%index expdrawlist;
expdrawlist.new(4);

void delIL(%index l=, index i)
{
  ^index l1 = l[0..i], l2 = l[i+1..-1];
  l.new(0);
  l .= l1 .= l2;
}

void insIL(%index l=, index i, index x)
{
  ^index l1 = l[0..i], l2 = l[i..-1];
  l.new(0);
  l .= l1 .= x .= l2;
}

&RdCacheInfo
{
  public int n, pn, hi;
}
%&RdCacheInfo playerid;
^int numenemy.new(4);
void resetNumenemy()
{
  loop{index i = 0; do: .numenemy[i] = -1; while ++i < #.numenemy:}
}
resetNumenemy();

public ^&.fgt.Fight fight;
public int roundState()
{
  ret
    .com.intro > .fight~ro.ctrl_time+1 ? 0 : (
      .fight~ro.cur == 0 ? 1 : (
        !.roundEnd() ? 2 : (
          .com.intro < -(
            .fight~ro.over_hittime
            + .fight~ro.over_waittime + .fight~ro.over_wintime)
          ? 4 : 3)));
}
public bool roundEnd()
{
  ret .com.intro < -.fight~ro.over_hittime;
}


public &PlayerList!&Char? players;
public int id = cfg.HelperMax;
/int pause = 0, pausetime = 0, pausebg = 0;
/int super = 0, supertime = 0, superpausebg = 0;
int pauseplayer = -1, superplayer = -1;
^&.act.Action superanim;
float superposx = 0.0, superposy = 0.0;
int superfacing = 1;
int superdarken = 1;
float superp2defmul = 1.0;
int superunhittable = 1;
/int envcol_time = 0;
/int envcol_under = 0;
int envcol_r = 255;
int envcol_g = 255;
int envcol_b = 255;

&ModifyExplod
{
  public int id;
  public int bindtime;
  public float scalex;
  public float scaley;
  public int removeongethit;
  public int removetime;
  public float velocityx;
  public float velocityy;
  public float accelx;
  public float accely;
  public int sprpriority;
  public int postype;
  public float offsetx;
  public float offsety;
  public int relativef;
  public float x;
  public float y;
  public int facing;
  public int vfacing;
  public int shadowr;
  public int shadowg;
  public int shadowb;
  public int ontop;
  public int alphas;
  public int alphad;
  public int supermovetime;
  public int pausemovetime;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `id = -1;
    `bindtime = .com.IERR;
    `scalex = .com.FERR;
    `scaley = .com.FERR;
    `removeongethit = .com.IERR;
    `removetime = .com.IERR;
    `velocityx = .com.FERR;
    `velocityy = .com.FERR;
    `accelx = .com.FERR;
    `accely = .com.FERR;
    `sprpriority = .com.IERR;
    `postype = .com.IERR;
    `offsetx = .com.FERR;
    `offsety = .com.FERR;
    `relativef = .com.IERR;
    `x = .com.FERR;
    `y = .com.FERR;
    `facing = .com.IERR;
    `vfacing = .com.IERR;
    `shadowr = .com.IERR;
    `shadowg = .com.IERR;
    `shadowb = .com.IERR;
    `ontop = .com.IERR;
    `alphas = .com.IERR;
    `alphad = .com.IERR;
    `supermovetime = .com.IERR;
    `pausemovetime = .com.IERR;
  }
  public void setX(float x)
  {
    `x = x;
  }
  public void setY(float y)
  {
    `y = y;
  }
}
public &Explod
{
  public int id;
  public int bindtime;
  public float scalex;
  public float scaley;
  public int removeongethit;
  public int removetime;
  public float velocityx;
  public float velocityy;
  public float accelx;
  public float accely;
  public int sprpriority;
  public int postype;
  public float offsetx;
  public float offsety;
  public int relativef;
  public float x;
  public float y;
  public int facing;
  public int vfacing;
  public int shadowr;
  public int shadowg;
  public int shadowb;
  public int supermovetime;
  public int pausemovetime;
  public ^&.act.Action ani;
  public int ontop;
  public int alphas;
  public int alphad;
  public int ownpal;
  public int player;
  public int bindid;
  public int ignorehitpause;
  public int stconno;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `id = .com.IERR;
    `bindtime = 0;
    `scalex = 1.0;
    `scaley = 1.0;
    `removeongethit = 0;
    `removetime = -2;
    `velocityx = 0.0;
    `velocityy = 0.0;
    `accelx = 0.0;
    `accely = 0.0;
    `sprpriority = 0;
    `postype = 0;
    `offsetx = 0.0;
    `offsety = 0.0;
    `relativef = 1;
    `x = 0.0;
    `y = 0.0;
    `facing = 1;
    `vfacing = 1;
    `shadowr = 0;
    `shadowg = 0;
    `shadowb = 0;
    `supermovetime = 0;
    `pausemovetime = 0;
    `ani.new(0);
    `ontop = 0;
    `alphas = .com.IERR;
    `alphad = .com.IERR;
    `ownpal = 0;
    `player = -1;
    `bindid = -1;
    `ignorehitpause = 1;
    `stconno = 0;
  }
  public void setFacing(int f)
  {
    if(f == 0) ret;
    if((`facing < 0) != (f < 0)){
      `facing *= -1;
      `velocityx *= -1.0;
    }
  }
  public void setX(float x)
  {
    `x = x;
  }
  public void setY(float y)
  {
    `y = y;
  }
}
public &Projectile
{
  public &.Hitdef hit;
  public int id;
  public int anim;
  public int hitanim;
  public int remanim;
  public int cancelanim;
  public float scalex;
  public float scaley;
  public int remove;
  public int removetime;
  public float velocityx;
  public float velocityy;
  public float remvelocityx;
  public float remvelocityy;
  public float accelx;
  public float accely;
  public float velmulx;
  public float velmuly;
  public int hits;
  public int misstime;
  public int priority;
  public int prioritypoint;
  public int sprpriority;
  public int edgebound;
  public int stagebound;
  public int heightboundt;
  public int heightboundb;
  public float x;
  public float y;
  public int facing;
  public int shadowr;
  public int shadowg;
  public int shadowb;
  public int supermovetime;
  public int pausemovetime;
  public ^&.act.Action ani;
  public int timemiss, hitpause, playerno;
  public |.ProjContact pctyp;
  public int pctime;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `hit.clear();
    `id = .com.IERR;
    `anim = 0;
    `hitanim = -1;
    `remanim = -1;
    `cancelanim = -1;
    `scalex = 1.0;
    `scaley = 1.0;
    `remove = 1;
    `removetime = -1;
    `velocityx = 0.0;
    `velocityy = 0.0;
    `remvelocityx = 0.0;
    `remvelocityy = 0.0;
    `accelx = 0.0;
    `accely = 0.0;
    `velmulx = 1.0;
    `velmuly = 1.0;
    `hits = 1;
    `misstime = 0;
    `priority = 1;
    `prioritypoint = 1;
    `sprpriority = 3;
    `edgebound = 40;
    `stagebound = 40;
    `heightboundt = -240;
    `heightboundb = 1;
    `x = 0.0;
    `y = 0.0;
    `facing = 1;
    `shadowr = 0;
    `shadowg = 0;
    `shadowb = 0;
    `supermovetime = 0;
    `pausemovetime = 0;
    `ani.new(0);
    `timemiss = 0;
    `hitpause = 0;
    `playerno = 0;
    `pctyp = .ProjContact::Hit;
    `pctime = 0;
  }
  public void setX(float x)
  {
    `x = x;
  }
  public void setY(float y)
  {
    `y = y;
  }
  public void remvel()
  {
    `velocityx = `remvelocityx;
    `velocityy = `remvelocityy;
    `accelx = `accely = 0.0;
    `velmulx = `velmuly = 1.0;
    `anim = -1;
    `hits = 0;
    `prioritypoint = 0;
  }
  public void update()
  {
    branch{
    cond .super > 0:
      if(`supermovetime == 0) ret;
    cond .pause > 0:
      if(`pausemovetime == 0) ret;
    }
    if(`hitpause != 0) ret;
    float sp = .m.min!float?(1.0, .com.turbo);
    `x += `velocityx*(float)`facing * sp;
    `y += `velocityy * sp;
    if(.com.tickNextFrame()){
      `velocityx += `accelx;
      `velocityy += `accely;
      `velocityx *= `velmulx;
      `velocityy *= `velmuly;
      if(`velocityx < 0.0){
        `facing *= -1;
        `velocityx *= -1.0;
        `accelx *= -1.0;
      }
    }
  }
  public bool hitCheck(&.Projectile pr=)
  {
    float xscl1 = pr.scalex, yscl1 = pr.scaley;
    float xscl2 = `scalex, yscl2 = `scaley;
    float xofs1 = pr.x, yofs1 = pr.y;
    float xofs2 = `x, yofs2 = `y;
    func$void(float=, float=, float, float) lrset1 =
      (pr.facing > 0 ? .pLrSet : .mLrSet);
    func$void(float=, float=, float, float) lrset2 =
      (`facing > 0 ? .pLrSet : .mLrSet);
    bool hentei(&.act.Rect c1, &.act.Rect c2)
    {
      float l1, r1, l2, r2;
      `lrset1(:l1=, r1=, (float)c1.l, (float)(c1.r+1):);
      `lrset2(:l2=, r2=, (float)c2.l, (float)(c2.r+1):);
      branch{
      cond l1*`xscl1+`xofs1 < l2*`xscl2+`xofs2:
        if(r1*`xscl1+`xofs1 < l2*`xscl2+`xofs2) break;
      else:
        if(l1*`xscl1+`xofs1 > r2*`xscl2+`xofs2) break;
      comm:
        branch{
        cond
          (float)c1.b*`yscl1+`yofs1 < (float)c2.b*`yscl2+`yofs2
          :
          if(
            (float)(c2.t-1)*`yscl2+`yofs2
            <= (float)c1.b*`yscl1+`yofs1) ret true;
        else:
          if(
            (float)c2.b*`yscl2+`yofs2
            >= (float)(c1.t-1)*`yscl1+`yofs1) ret true;
        }
      }
      ret false;
    }
    if(#pr.ani == 0 || #pr.ani~ani.frames == 0) ret false;
    if(#`ani == 0 || #`ani~ani.frames == 0) ret false;
    ^&.act.Frame frm;
    ^&.act.Rect clsn1 = pr.ani~ani.currentFrame()=>frm#frm~clsn1;
    ^&.act.Rect clsn2 = `ani~ani.currentFrame()=>frm#frm~clsn2;
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(hentei(clsn1[i], clsn2[j])) ret true;
        j++;
      while j < #clsn2:
      }
      i++;
    while i < #clsn1:
    }
    ret false;
  }
  public void projClsn()
  {
    if(`hit.attr < 0) ret;
    loop{index i = 0; while; do:
      if(i != `playerno) loop{
        index j = 0;
        while;
      do:
        if(
          .projs[i][j].id < 0 || (
            .projs[i][j].hit.affectteam != 0 && (
              (`playerno&1) != (i&1)) != (.projs[i][j].hit.affectteam > 0))
          ) continue;
        if(
          .projs[i][j].hit.attr >= 0
          && `hitCheck(.projs[i][j]=) && .projs[i][j].hitCheck(`=))
        {
          `prioritypoint -= .projs[i][j].priority;
        }
      continue:
        j++;
      while j < #.projs[i]:
      }
      i++;
    while i < #.projs:
    }
    if(`prioritypoint <= 0 && `hits > 0 && `priority > 0){
      `hits -= 1 + -`prioritypoint / `priority;
      if(`hits > 0){
        `prioritypoint = `prioritypoint % `priority + `priority;
      }
    }
  }
  bool paused()
  {
    branch{
    cond .super > 0:
      if(`supermovetime == 0) ret true;
    cond .pause > 0:
      if(`pausemovetime == 0) ret true;
    }
    ret false;
  }
  public void tick()
  {
    if(`timemiss < 0){
      `timemiss = !`timemiss;
      branch{
      cond `misstime <= 0 && `hitpause == 0:
        `hits = 0;
      else:
        `hits--;
      }
      `hit.air_juggle = 0;
    }
    if(`hits <= 0) `hit.attr = -1;
    if(`paused()) ret;
    branch{
    cond `anim >= 0:
      branch{
      cond `prioritypoint <= 0 && `remove != 0:
        `ani = .chars[`playerno][0]~getAction(`cancelanim);
      cond `hits <= 0 && `remove != 0:
        `ani = .chars[`playerno][0]~getAction(`hitanim);
      cond
        (
          `x < .com.xmin-(float)`edgebound || .com.xmax+(float)`edgebound < `x)
        || (
          `x < .com.scrxmin-(float)`stagebound
          || .com.scrxmax+(float)`stagebound < `x)
        || (`velocityy > 0.0 && `y > (float)`heightboundb)
        || (`velocityy < 0.0 && `y < (float)`heightboundt)
        || `removetime == 0
        :
        `ani = .chars[`playerno][0]~getAction(`remanim);
      else:
        break;
      comm:
        `remvel();
      }
    else:
      branch{
      cond #`ani == 0:
      cond !`ani~ani.loopend:
        {
          ^&.act.Frame frm = `ani~ani.currentFrame();
          if(#frm > 0 && frm~time >= 0) break, break;
        }
      else:
        `ani.new(0);
      comm:
        if(`hitpause == 0 && `removetime <= 0) `id = -1;
      }
    }
    branch{
    cond `pctime > 0:
      `pctime++;
    cond `pctime < 0:
      `pctime *= -1;
    }
    if(`hitpause <= 0){
      if(`removetime > 0) `removetime--;
      if(`timemiss > 0) `timemiss--;
    }
  }
  public void anime()
  {
    if(.com.clsndraw && #`ani > 0){
      ^&.act.Frame frm = `ani~ani.currentFrame();
      if(#frm == 0) break;
      ^&.act.Rect clsn = frm~clsn1;
      if(#clsn > 0){
        .drawc1.new[-1].set(clsn, `x, `y, (float)`facing*`scalex, `scaley);
      }
      clsn = frm~clsn2;
      if(#clsn > 0){
        .drawc2.new[-1].set(clsn, `x, `y, (float)`facing*`scalex, `scaley);
      }
    }
    if(.com.tickNextFrame()){
      if(#`ani > 0) branch{
      cond !`paused() && (`hitpause == 0 || `anim < 0):
        `ani~ani.action();
      else:
        `ani~ani.updateSprite();
      }
      if(`paused()) break;
      branch{
      cond .super > 0:
        if(`supermovetime > 0) `supermovetime--;
      cond .pause > 0:
        if(`pausemovetime > 0) `pausemovetime--;
      }
      if(`hitpause > 0) `hitpause--;
    }
    .addAnimList(
      .anims=, `ani, `sprpriority, `x, `y, .com.scale,
      (float)`facing*`scalex, `scaley, 0.0, false, 1.0, 1.0, -1, 0,
      256 >> (int)(
        .super > 0 && .superdarken != 0 && `playerno != .superplayer),
      .consts.null!&.com.PalFX?(),
      `shadowr<<16 | (`shadowg&255)<<8 | (`shadowb&255), 0.0);
  }
}
public &Char
{
  public ^/char def, name, displayname, author;
  public ^/char command;
  public ^/char sprite;
  public ^/char anim;
  public ^/char sound;
  public ^^/char pal;
  public ^index palkeymap;
  public ^&.sff.Sff sf;
  public ^&.snd.Snd sn;
  public ^&.com.PalFX palfx;
  public %&.act.Action actionList;
  public ^&.act.Action ani;
  public ^int ivar, sysivar;
  public ^float fvar, sysfvar;
  public &.cmd.CommandList cmd;
  public &.StateVal stVal;
  public &.AfterImage aimg;
  public int key;
  public int id, playerno, helperindex, helperid, parentindex;
  public %int children;
  public %int targets;
  public byte facing;
  public bool keyctrl;
  public bool player;
  public bool inguarddist;
  public int sprpriority;
  public int palno, drawpalno;
  public int animno;
  public int animpno;
  public int getcombo;
  public float frontw, backw, fedge, bedge;
  public float attackmul, defencemul, attackdist;
  public float offsetx, offsety;
  public float veloff;
  public float oldx;
  public bool destmp, cs1tmp, tmphit, angleset;
  public int atktmp, hittmp, acttmp, minus;
  public %&.RdCacheInfo enemyn;
  public ^&.act.Frame curFrame;
  public %&.snd.Sound sounds;
  public short mver0 = 0, mver1 = 0;
  void dummy(){}
  public method$void() state = dummy, state_1 = dummy,
    state_2 = dummy, state_3 = dummy, state_i1 = dummy;
  new()
  {
    `ivar.new(61);
    `sysivar.new(60);
    `fvar.new(41);
    `sysfvar.new(70);
    `clearVal();
  }
  void copyParent(`self c=)
  {
    %char buf;
    `name = (buf .= c.name .= "'s helper");
    `displayname = c.displayname;
    `author = c.author;
    `sf = c.sf;
    `sn = c.sn;
    `actionList = c.actionList;
    `key = c.key;
    `cmd.copy(c.cmd=);
    if(`key < 0){
      `cmd.buffer.new(1);
      `cmd.cTable.new(1);
    }
    `palno = c.palno;
    `drawpalno = c.drawpalno;
    `state_1 = c.state_1;
    `state_2 = c.state_2;
    `state_3 = c.state_3;
    `state_i1 = c.state_i1;
    .s.copy!int?(`sysivar[10..-1], c.sysivar[10..-1]);
    .s.copy!float?(`sysfvar[10..-1], c.sysfvar[10..-1]);
    `sysivar[.iLIFE] = `sysivar[.iLIFEMAX];
    `sysivar[.iPOWER] = 0;
    `mver0 = c.mver0;
    `mver1 = c.mver1;
    `clearSpSysVar();
  }
  public void clearSpSysVar()
  {
    `sysivar[.iAIRJUMP_CNT] = 0;
    `sysivar[.iCTRL] = 0;
    `sysivar[.iHITCOUNT] = 0;
    `sysivar[.iUNIQHITCOUNT] = 0;
    `sysivar[.iMOVETIMEPAUSE] = 0;
    `sysivar[.iMOVETIMESUPER] = 0;
    `sysivar[.iPAUSEMOVETIME] = 0;
    `sysivar[.iSUPERMOVETIME] = 0;
    `sysivar[.iBINDTIME] = 0;
    `sysivar[.iHITPAUSETIME] = 0;
    `sysfvar[.fANGLE] = 0.0;
    `sysfvar[.fANGLESCALEX] = 1.0;
    `sysfvar[.fANGLESCALEY] = 1.0;
    `sysivar[.iALPHAS] = 255;
    `sysivar[.iALPHAD] = 0;
    `sysivar[.iRECOVERTIME] = 0;
    `sprpriority = 0;
    `getcombo = 0;
    `veloff = 0.0;
    `oldx = `sysfvar[.fX];
    `palfx.new(0);
    `aimg.timegap = -1;
    `frontw = `defFW();
    `backw = `defBW();
    `fedge = `bedge = 0.0;
    `enemyn.new(0);
    `targets.new(0);
  }
  public void clearVal()
  {
    `ani.new(0);
    `curFrame.new(0);
    `stVal.clear();
    `rangeSetSysIVar(0, #`sysivar-1, 0);
    `rangeSetSysFVar(0, #`sysfvar-1, 0.0);
    `rangeSetIVar(0, #`ivar-1, 0);
    `rangeSetFVar(0, #`fvar-1, 0.0);
    `key = -1; `id = .com.IERR; `playerno = -1; `helperindex = -1;
    `helperid = 0; `parentindex = .com.IERR;
    `facing = 1;
    `keyctrl = false;
    `player = false;
    `inguarddist = false;
    `palno = 0;
    `drawpalno = 0;
    `animno = 0;
    `animpno = -1;
    `tmphit = false;
    `atktmp = -1;
    `hittmp = 0;
    `acttmp = 0;
    `destmp = false;
    `minus = 2;
    `cs1tmp = false;
    `angleset = false;
    `state = `dummy;
  }
  void clearHitDef()
  {
    `stVal.hit.clear();
  }
  void clearMoveHit()
  {
    `stVal.mctime = 0;
    `sysivar[.iHITPAUSETIME] = 0;
  }
  void clearHitCount()
  {
    `sysivar[.iHITCOUNT] = 0;
    `sysivar[.iUNIQHITCOUNT] = 0;
  }
  public void rangeSetSysIVar(index start, index end, int n)
  {
    if(start < 0) ret;
    loop{index i = start; while; do:
      `sysivar[i] = n;
      i++;
    while i <= end && i < #`sysivar:
    }
  }
  public void rangeSetSysFVar(index start, index end, float n)
  {
    if(start < 0) ret;
    loop{index i = start; while; do:
      `sysfvar[i] = n;
      i++;
    while i <= end && i < #`sysfvar:
    }
  }
  public void rangeSetIVar(index start, index end, int n)
  {
    if(start < 0) ret;
    loop{index i = start; while; do:
      `ivar[i] = n;
      i++;
    while i <= end && i < #`ivar:
    }
  }
  public void rangeSetFVar(index start, index end, float n)
  {
    if(start < 0) ret;
    loop{index i = start; while; do:
      `fvar[i] = n;
      i++;
    while i <= end && i < #`fvar:
    }
  }
  public ^&.act.Action getAction(int no)
  {
    *`ani.self a;
    loop{index i = 0; while; do:
      if(`actionList[i].no == no){
        a.new(1);
        a~copy(`actionList[i]=);
        break, break;
      }
      i++;
    while i< #`actionList:
    }
    if(#a > 0) a~ani.updateSprite();
    ret a;
  }
  public ^&.snd.Sound newChannel(int ch, bool lowpriority)
  {
    index c = .m.min!int?(255, ch);
    if(c >= 0) branch{
    cond lowpriority:
      if(#`sounds > c && #`sounds[c].sound > 0){
        ret .consts.null!&.snd.Sound?();
      }
    comm:
      `sounds.new[c];
      ret `sounds[c..c+1];
    }
    `sounds.new[255];
    loop{index i = 255; do:
      if(#`sounds[i].sound == 0) ret `sounds[i..i+1];
      i--;
    while i >= 0:
    }
    ret .consts.null!&.snd.Sound?();
  }
  public ^&.Explod newExplod(index idx=)
  {:<-
    ^&.Explod foo(index i)
    {
      .explods[`playerno][i].clear();
      .explods[`playerno][i].id = -1;
      .explods[`playerno][i].player = `id;
      ret .explods[`playerno][i..i+1];
    }
    loop{idx = 0; while; do:
      if(.explods[`playerno][idx].id == .com.IERR) ret foo(idx);
      idx++;
    while idx < #.explods[`playerno]:
      if(idx < .cfg.ExplodMax){
        .explods[`playerno].new[idx];
        ret foo(idx);
      }
    }
    idx = -1;
    ret .consts.null!&.Explod?();
  }
  public void insertExplod(index i, int scn)
  {
    .explods[`playerno][i].stconno = scn;
    loop{
      index ii = 0;
      int p;
      while;
    do:
      p = .explods[`playerno][.expdrawlist[`playerno][ii]].player;
      if(
        p >= `id && (
          p > `id || .explods[`playerno][i].ontop == 0
          || .explods[`playerno][.expdrawlist[`playerno][ii]].stconno > scn))
      {
        .insIL(.expdrawlist[`playerno]=, ii, i);
        break, break;
      }
      ii++;
    while ii < #.expdrawlist[`playerno]:
      .expdrawlist[`playerno] .= i;
    }
  }
  public ^&.Projectile newProj()
  {
    loop{index i = 0; while; do:
      if(.projs[`playerno][i].id < 0){
        .projs[`playerno][i].clear();
        .projs[`playerno][i].id = 0;
        ret .projs[`playerno][i..i+1];
      }
      i++;
    while i < #.projs[`playerno]:
      if(i < .cfg.PlayerProjectileMax){
        .projs[`playerno].new[i].id = 0;
        ret .projs[`playerno][i..i+1];
      }
    }
    ret .consts.null!&.Projectile?();
  }
  public void addTarget(int id)
  {
    loop{index i = 0; while; do:
      if(`targets[i] < 0 || `targets[i] == id){
        `targets[i] = id;
        break, break;
      }
      i++;
    while i < #`targets:
      `targets .= id;
    }
  }
  public bool isTarget(int id)
  {
    loop{index i = 0; while; do:
      if(`targets[i] == id) ret true;
      i++;
    while i < #`targets:
    }
    ret false;
  }
  public void removeTarget(int id)
  {
    loop{index i = 0; while; do:
      if(`targets[i] == id){
        `targets[i] = -1;
        break, break;
      }
      i++;
    while i < #`targets:
    }
  }
  public void byBindClear()
  {
    if(`stVal.hb.byidMatch(`sysivar[.iBINDTOID])){
      `sysivar[.iBINDTIME] = 0;
      `sysivar[.iSPECIALFLAG] |= .lsBindCancel;
    }
  }
  public void outTarget()
  {
    if(`hittmp >= 0){
      loop{
        index i = 0;
        ^`self c;
        while;
      do:
        c = .players.get(`stVal.hb.byid[i]);
        if(#c > 0) c~removeTarget(`id);
        i++;
      while i < #`stVal.hb.byid:
      }
      `byBindClear();
    }
    `stVal.hb.byid.new(0);
  }
  void addChild(int hidx)
  {
    loop{index i = 0; while; do:
      if(`children[i] < 0){
        `children[i] = hidx;
        ret;
      }
      i++;
    while i < #`children:
    }
    `children .= hidx;
  }
  public ^&.com.PalFX getPalfx()
  {
    if(#`palfx > 0) ret `palfx;
    if(`parentindex < 0){
      `palfx.new(1);
      ret `palfx;
    }
    ret .chars[`playerno][`parentindex]~getPalfx();
  }
  public bool ls(int mask)
  {
    ret (`sysivar[.iSPECIALFLAG] & mask) == mask;
  }
  public bool load(^/char def)
  {:<-
    public void info(&.com.Section sc=)
    {
      ^/char data;
      if(#(data = sc.get("name")) > 0) `name = data;
      if(#(data = sc.get("displayname")) > 0) `displayname = data;
      if(#(data = sc.get("author")) > 0) `author = data;
      if(#(data = sc.get("mugenversion")) > 0){
        ^short tmp = .s.svToAry!short?(".", data);
        `mver0 = tmp[0];
        if(#tmp >= 2) `mver1 = tmp[1];
      }
    }
    public void files(&.com.Section sc=)
    {
      type _t = .com.readFileName;
      ^/char data;
      if(#(data = sc.get("cmd")) > 0) `command = _t(data);
      if(#(data = sc.get("sprite")) > 0) `sprite = _t(data);
      if(#(data = sc.get("anim")) > 0) `anim = _t(data);
      if(#(data = sc.get("sound")) > 0) `sound = _t(data);
      if(#(data = sc.get("pal1")) > 0) `pal[0] = _t(data);
      if(#(data = sc.get("pal2")) > 0) `pal[1] = _t(data);
      if(#(data = sc.get("pal3")) > 0) `pal[2] = _t(data);
      if(#(data = sc.get("pal4")) > 0) `pal[3] = _t(data);
      if(#(data = sc.get("pal5")) > 0) `pal[4] = _t(data);
      if(#(data = sc.get("pal6")) > 0) `pal[5] = _t(data);
      if(#(data = sc.get("pal7")) > 0) `pal[6] = _t(data);
      if(#(data = sc.get("pal8")) > 0) `pal[7] = _t(data);
      if(#(data = sc.get("pal9")) > 0) `pal[8] = _t(data);
      if(#(data = sc.get("pal10")) > 0) `pal[9] = _t(data);
      if(#(data = sc.get("pal11")) > 0) `pal[10] = _t(data);
      if(#(data = sc.get("pal12")) > 0) `pal[11] = _t(data);
    }
    public void keymap(&.com.Section sc=)
    {:<-
      void foo(index k, ^/char p)
      {
        `palkeymap[k] = .com.atoi(p)-1;
        .m.limRange!index?(`palkeymap[k]=, 0, .sff.NumCharPalletes-1);
      }
      ^/char data;
      if(#(data = sc.get("a")) > 0) foo(0, data);
      if(#(data = sc.get("b")) > 0) foo(1, data);
      if(#(data = sc.get("c")) > 0) foo(2, data);
      if(#(data = sc.get("x")) > 0) foo(3, data);
      if(#(data = sc.get("y")) > 0) foo(4, data);
      if(#(data = sc.get("z")) > 0) foo(5, data);
      if(#(data = sc.get("a2")) > 0) foo(6, data);
      if(#(data = sc.get("b2")) > 0) foo(7, data);
      if(#(data = sc.get("c2")) > 0) foo(8, data);
      if(#(data = sc.get("x2")) > 0) foo(9, data);
      if(#(data = sc.get("y2")) > 0) foo(10, data);
      if(#(data = sc.get("z2")) > 0) foo(11, data);
    }
    public void palette(^/char sec, &.com.Section sc=)
    {
      branch{
      cond .s.equ(.s.toLower(sec[0..6]), "keymap"):
        `load:<-keymap(sc=);
      }
    }
    void section(^^/char lines, index i=)
    {
      ^/char sec = lines[i];
      ^/char secname = .com.sectionName(sec=);
      if(#secname == 0) ret;
      i++;
      &.com.Section sc.parse(lines, i=);
      branch{
      cond .s.equ(secname, "info"):
        `load:<-info(sc=);
      cond .s.equ(secname, "files"):
        `load:<-files(sc=);
      cond .s.equ(secname, "palette"):
        `load:<-palette(sec, sc=);
      }
    }
    public void begin(^^/char lines, index i=, ^/char section)
    {
      index fnd = .s.cFind(" "\t, section);
      ^/char name = .s.toLower()<, section[0..fnd];
      if(fnd >= 0) loop{while; do:
        fnd++;
      while fnd < #section && .s.cMatch!char?(" "\t, section[fnd]):
      }
      ^/char sec = section[fnd..-1];
      branch{
      cond .s.equ(name, "action"):
        {
          int no;
          no = .com.atoi(sec);
          ^&.act.Action act = `getAction(no);
          if(#act > 0) break;
          `actionList.new[-1].no = no;
          act = `actionList[#`actionList-1..-1];
          act~read(lines, i=);
        }
      }
    }
    void action(^^/char lines, index i=)
    {
      ^/char sec = lines[i];
      ^/char secname = .com.sectionName(sec=);
      if(#secname == 0) ret;
      i++;
      branch{
      cond .s.equ(secname, "begin"):
        `load:<-begin(lines, i=, sec);
      }
    }
    public void remap(&.com.Section sc=)
    {
      ^/char data;
      void map(|.cmd.Key k=, |.cmd.Key nk=)
      {
        branch{
        cond .s.equ(`data, "x"):
          k  = .cmd.Key:: x;
          nk = .cmd.Key::nx;
        cond .s.equ(`data, "y"):
          k  = .cmd.Key:: y;
          nk = .cmd.Key::ny;
        cond .s.equ(`data, "z"):
          k  = .cmd.Key:: z;
          nk = .cmd.Key::nz;
        cond .s.equ(`data, "a"):
          k  = .cmd.Key:: a;
          nk = .cmd.Key::na;
        cond .s.equ(`data, "b"):
          k  = .cmd.Key:: b;
          nk = .cmd.Key::nb;
        cond .s.equ(`data, "c"):
          k  = .cmd.Key:: c;
          nk = .cmd.Key::nc;
        cond .s.equ(`data, "s"):
          k  = .cmd.Key:: s;
          nk = .cmd.Key::ns;
        }
      }
      if(#(data = sc.get("x")) > 0) map(.cmd.x=, .cmd.nx=);
      if(#(data = sc.get("y")) > 0) map(.cmd.y=, .cmd.ny=);
      if(#(data = sc.get("z")) > 0) map(.cmd.z=, .cmd.nz=);
      if(#(data = sc.get("a")) > 0) map(.cmd.a=, .cmd.na=);
      if(#(data = sc.get("b")) > 0) map(.cmd.b=, .cmd.nb=);
      if(#(data = sc.get("c")) > 0) map(.cmd.c=, .cmd.nc=);
      if(#(data = sc.get("s")) > 0) map(.cmd.s=, .cmd.ns=);
    }
    public void defaults(&.com.Section sc=)
    {
      ^/char data;
      if(#(data = sc.get("command.time")) > 0){
        `cmd.defaultTime = .com.atoi(data);
      }
      if(#(data = sc.get("command.buffer.time")) > 0){
        `cmd.defaultBufferTime = .m.max!int?(1)<, .com.atoi(data);
      }
    }
    public void command(&.com.Section sc=)
    {
      `cmd.ctmp.new(1);
      `cmd.ctmp~time = `cmd.defaultTime;
      `cmd.ctmp~buffertime = `cmd.defaultBufferTime;
      ^/char data;
      if(#(data = sc.get("name")) > 0) `cmd.ctmp~name = data;
      if(#(data = sc.get("time")) > 0) `cmd.ctmp~time = .com.atoi(data);
      if(#(data = sc.get("buffer.time")) > 0){
        `cmd.ctmp~buffertime = .m.max!int?(1)<, .com.atoi(data);
      }
      if(#(data = sc.get("command")) > 0) `cmd.ctmp~readCmd(data);
      if(#`cmd.ctmp~cmd == 1 && `cmd.ctmp~cmd~slash){
        `cmd.ctmp~buffertime = 1;
      }
      `cmd.add(`cmd.ctmp<>=);
    }
    void commandlist(^^/char lines, index i=)
    {
      ^/char sec = lines[i];
      ^/char secname = .com.sectionName(sec=);
      if(#secname == 0) ret;
      i++;
      &.com.Section sc.parse(lines, i=);
      branch{
      cond .s.equ(secname, "remap"):
        `load:<-remap(sc=);
      cond .s.equ(secname, "defaults"):
        `load:<-defaults(sc=);
      cond .s.equ(secname, "command"):
        `load:<-command(sc=);
      }
    }
    `def = def;
    ^char mainbuf = .file.loadAsciiText(def);
    ^^/char lines = .com.splitLines(mainbuf);
    .s.each!^/char?([void(^/char l=){l=.s.trim(l);}], lines);
    `clearDef();
    loop{index i = 0; while; do:
      section(lines, i=);
      i++;
    while i < #lines:
    }
    if(#`displayname == 0) `displayname = `name;
    `sf.new(1);
    if(
      !.com.loadFile(def, `sprite=)<,
       [bool(^/char f){ret `sf~loadFile(f, true);}]) ret false;
    if(
      !.com.loadFile(def, `anim=)<, [bool(^/char f){
        ret #(mainbuf = .file.loadAsciiText(f)) > 0;
      }]) ret false;
    lines = .com.splitLines(mainbuf);
    .s.each!^/char?([void(^/char l=){l=.s.trim(l);}], lines);
    `actionList.new(0);
    loop{index i = 0; while; do:
      action(lines, i=);
      i++;
    while i < #lines:
    }
    loop{index i = 0; while; do:
      `actionList[i].ani.setup(`sf);
      i++;
    while i < #`actionList:
    }
    `sn.new(1);
    if(
      #`sound > 0 && !.com.loadFile(def, `sound=)<,
      [bool(^/char f){ret `sn~loadFile(f);}]) ret false;
    if(
      !.com.loadFile(def, `command=)<, [bool(^/char f){
        ret #(mainbuf = .file.loadAsciiText(f)) > 0;
      }]) ret false;
    lines = .com.splitLines(mainbuf);
    .s.each!^/char?([void(^/char l=){l=.s.trim(l);}], lines);
    .cmd.resetReadKeymap();
    `cmd.clear();
    `cmd.buffer.new(1);
    loop{index i = 0; while; do:
      commandlist(lines, i=);
      i++;
    while i < #lines:
    }
    ret true;
  }
  public bool loadPallet(^/char def, int no)
  {
    `sf~palList.resetRemap();
    index tmp = 0;
    if(`sf~head.ver0 == 0d1) loop{
      index i = 0;
      ubyte r, g, b;
      ^uint pl;
      while;
    do:
      pl = `sf~palList.get(i);
      branch{
        &.file.File f;
      cond
        .com.loadFile(def, `pal[i]=)<, [bool(^/char fn){
          f.open(fn, "rb"); ret f.read!ubyte?(r=);
        }]
        :
        loop{
          index j = 255;
          continue;
        do:
          if(!f.read!ubyte?(r=)) ret false;
        continue:
          if(!f.read!ubyte?(g=)) ret false;
          if(!f.read!ubyte?(b=)) ret false;
          pl[j] = (uint)r<<0d16 | (uint)g<<0d8 | (uint)b;
          j--;
        while j >= 0:
        }
        if(tmp == 0) loop{index j = 0; while; do:
          .s.copy!uint?(`sf~palList.get(j), pl);
          j++;
        while j < i:
        }
        tmp = i+1;
      cond tmp > 0:
        .s.copy!uint?(pl, `sf~palList.get(i >= 6 ? i % 6 : i - 1));
      }
      i++;
    while i < .sff.NumCharPalletes:
    }
    `palno = `palkeymap[no-1]+1;
    `drawpalno = `palno;
    if(tmp == 0) ret false;
    loop{
      index i = `palno-1;
    do:
      loop{index j = 0; while; do:
        if(
          j != `playerno && #.chars[j] > 0 && .s.equ(.chars[j][0]~def, `def)
          && .chars[j][0]~drawpalno == i+1) break;
        j++;
      while j < #.chars:
        `drawpalno = i+1;
        break, break;
      }
      i++;
      if(i >= .sff.NumCharPalletes) i = 0;
    while i != `palno-1:
    }
    `trRemapPal(1, 1, 1, `drawpalno);
    ret true;
  }
  public void clearDef()
  {
    `name = "";
    `displayname = "";
    `author = "";
    `command = "";
    `sprite = "";
    `anim = "";
    `sound = "";
    `pal.new(.sff.NumCharPalletes);
    `palkeymap.new(.sff.NumCharPalletes);
    loop{index i = 0; while; do:
      `palkeymap[i] = i;
      i++;
    while i < #`palkeymap:
    }
  }
  public int gethitAnimtype()
  {
    ret
      `stVal.hb.fallf != 0 ? (int)`stVal.hb.fall.animtype : (
        `stVal.typ == .StTy::A
        ? `stVal.hb.airanimtype : `stVal.hb.groundanimtype);
  }
  public void setEnemyWinty()
  {
    if(`helperindex != 0) ret;
    branch{
    cond
      (`stVal.hb.attr&((int).AtTy::HA|(int).AtTy::HT|(int).AtTy::HP))
      != 0
      :
      .winty[(`playerno+1)&1] = .fgt.WinTy::H;
    cond
      (`stVal.hb.attr&((int).AtTy::SA|(int).AtTy::ST|(int).AtTy::SP))
      != 0
      :
      .winty[(`playerno+1)&1] = .fgt.WinTy::S;
    cond
      (`stVal.hb.attr&((int).AtTy::NT|(int).AtTy::ST|(int).AtTy::HT))
      != 0
      :
      .winty[(`playerno+1)&1] = .fgt.WinTy::Throw;
    else:
      .winty[(`playerno+1)&1] = .fgt.WinTy::N;
    }
  }
  public bool attrCheck(&.Hitdef hit=)
  {
    if(
      .super > 0 && .superunhittable != 0
      && `playerno == .superplayer) ret false;
    if(hit.chainid >= 0 && `stVal.hb.hitid != hit.chainid) ret false;
    if(`hittmp > 0){
      if(
        `stVal.hb.nochainid1 >= 0 && hit.id == `stVal.hb.nochainid1) ret false;
      if(
        `stVal.hb.nochainid2 >= 0 && hit.id == `stVal.hb.nochainid2) ret false;
    }
    if(hit.reversal_attr > 0){
      ret
        `atktmp >= 0 && `stVal.hit.attr > 0
        && (`stVal.hit.attr & hit.reversal_attr & 63) != 0
        && (`stVal.hit.attr & hit.reversal_attr & !63) != 0;
    }
    if(hit.attr <= 0) ret false;
    if((hit.hitflag & (int)`stVal.typ) == 0) ret false;
    if((hit.hitflag & (int).StTy::N) == 0 && `hittmp > 2) ret false;
    if((hit.hitflag & (int).MovTy::I) != 0 && `hittmp > 0) ret false;
    if((hit.hitflag & (int).MovTy::H) != 0 && `hittmp <= 0) ret false;
    if(hit.chainid < 0){
      if(
        `stVal.hb.hitt1 != 0 && (
          (`stVal.hb.hitf1 & hit.attr & 63) == 0
          || (`stVal.hb.hitf1 & hit.attr & !63) == 0)) ret false;
      if(
        `stVal.hb.hitt2 != 0 && (
          (`stVal.hb.hitf2 & hit.attr & 63) == 0
          || (`stVal.hb.hitf2 & hit.attr & !63) == 0)) ret false;
    }
    ret true;
  }
  public bool hittable(&.Hitdef hit=, ~$bool(&.Hitdef=) countercheck)
  {
    if(
      `atktmp >= 0 && (`stVal.hit.attr != 0 || `stVal.hit.reversal_attr > 0)
      && hit.reversal_attr <= 0)
    {
      if(
        (
          `stVal.hit.reversal_attr > 0 || (
            hit.priority <= `stVal.hit.priority && (
              hit.priority < `stVal.hit.priority
              || `stVal.hit.bothhittype == .PriTy::Dodge
              || hit.bothhittype != .PriTy::Hit)))
        && countercheck(:`stVal.hit=:)) ret false;
    }
    ret `attrCheck(hit=);
  }
  public bool hitCheck(`self atk=)
  {
    float xscl1 = atk.sysfvar[.fCLSNXSCALE],
      yscl1 = atk.sysfvar[.fCLSNYSCALE];
    float xscl2 = `sysfvar[.fCLSNXSCALE],
      yscl2 = `sysfvar[.fCLSNYSCALE];
    float xofs1 = atk.sysfvar[.fX] + atk.offsetx,
      yofs1 = atk.sysfvar[.fY] + atk.offsety;
    float xofs2 = `sysfvar[.fX] + `offsetx,
      yofs2 = `sysfvar[.fY] + `offsety;
    func$void(float=, float=, float, float) lrset1 =
      (atk.facing > 0 ? .pLrSet : .mLrSet);
    func$void(float=, float=, float, float) lrset2 =
      (`facing > 0 ? .pLrSet : .mLrSet);
    bool hentei(&.act.Rect c1, &.act.Rect c2)
    {
      float l1, r1, l2, r2;
      `lrset1(:l1=, r1=, (float)c1.l, (float)(c1.r+1):);
      `lrset2(:l2=, r2=, (float)c2.l, (float)(c2.r+1):);
      branch{
      cond l1*`xscl1+`xofs1 < l2*`xscl2+`xofs2:
        if(r1*`xscl1+`xofs1 < l2*`xscl2+`xofs2) break;
      else:
        if(l1*`xscl1+`xofs1 > r2*`xscl2+`xofs2) break;
      comm:
        branch{
        cond (float)c1.b*`yscl1+`yofs1 < (float)c2.b*`yscl2+`yofs2:
          if(
            (float)(c2.t-1)*`yscl2+`yofs2
            <= (float)c1.b*`yscl1+`yofs1) ret true;
        else:
          if(
            (float)c2.b*`yscl2+`yofs2
            >= (float)(c1.t-1)*`yscl1+`yofs1) ret true;
        }
      }
      ret false;
    }
    if(#atk.ani == 0 || #atk.curFrame == 0) ret false;
    if(#`ani == 0 || #`curFrame == 0) ret false;
    ^&.act.Rect clsn1 = atk.curFrame~clsn1;
    ^&.act.Rect clsn2 = `curFrame~clsn2;
    if(atk.stVal.hit.reversal_attr > 0) clsn2 = `curFrame~clsn1;
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(hentei(clsn1[i], clsn2[j])) ret true;
        j++;
      while j < #clsn2:
      }
      i++;
    while i < #clsn1:
    }
    ret false;
  }
  public bool projHitCheck(&.Projectile pr=)
  {
    float xscl1 = pr.scalex, yscl1 = pr.scaley;
    float xscl2 = `sysfvar[.fCLSNXSCALE],
      yscl2 = `sysfvar[.fCLSNYSCALE];
    float xofs1 = pr.x, yofs1 = pr.y;
    float xofs2 = `sysfvar[.fX] + `offsetx,
      yofs2 = `sysfvar[.fY] + `offsety;
    func$void(float=, float=, float, float) lrset1 =
      (pr.facing > 0 ? .pLrSet : .mLrSet);
    func$void(float=, float=, float, float) lrset2 =
      (`facing > 0 ? .pLrSet : .mLrSet);
    bool hentei(&.act.Rect c1, &.act.Rect c2)
    {
      float l1, r1, l2, r2;
      `lrset1(:l1=, r1=, (float)c1.l, (float)(c1.r+1):);
      `lrset2(:l2=, r2=, (float)c2.l, (float)(c2.r+1):);
      branch{
      cond l1*`xscl1+`xofs1 < l2*`xscl2+`xofs2:
        if(r1*`xscl1+`xofs1 < l2*`xscl2+`xofs2) break;
      else:
        if(l1*`xscl1+`xofs1 > r2*`xscl2+`xofs2) break;
      comm:
        branch{
        cond (float)c1.b*`yscl1+`yofs1 < (float)c2.b*`yscl2+`yofs2:
          if(
            (float)(c2.t-1)*`yscl2+`yofs2
            <= (float)c1.b*`yscl1+`yofs1) ret true;
        else:
          if(
            (float)c2.b*`yscl2+`yofs2
            >= (float)(c1.t-1)*`yscl1+`yofs1) ret true;
        }
      }
      ret false;
    }
    if(#pr.ani == 0 || #pr.ani~ani.frames == 0) ret false;
    if(#`ani == 0 || #`curFrame == 0) ret false;
    ^&.act.Frame frm;
    ^&.act.Rect clsn1 = pr.ani~ani.currentFrame()=>frm#frm~clsn1;
    ^&.act.Rect clsn2 = `curFrame~clsn2;
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(hentei(clsn1[i], clsn2[j])) ret true;
        j++;
      while j < #clsn2:
      }
      i++;
    while i < #clsn1:
    }
    ret false;
  }
  public bool hitProjCheck(&.Projectile pr=)
  {
    float xscl1 = pr.scalex, yscl1 = pr.scaley;
    float xscl2 = `sysfvar[.fCLSNXSCALE],
      yscl2 = `sysfvar[.fCLSNYSCALE];
    float xofs1 = pr.x, yofs1 = pr.y;
    float xofs2 = `sysfvar[.fX] + `offsetx,
      yofs2 = `sysfvar[.fY] + `offsety;
    func$void(float=, float=, float, float) lrset1 =
      (pr.facing > 0 ? .pLrSet : .mLrSet);
    func$void(float=, float=, float, float) lrset2 =
      (`facing > 0 ? .pLrSet : .mLrSet);
    bool hentei(&.act.Rect c1, &.act.Rect c2)
    {
      float l1, r1, l2, r2;
      `lrset1(:l1=, r1=, (float)c1.l, (float)(c1.r+1):);
      `lrset2(:l2=, r2=, (float)c2.l, (float)(c2.r+1):);
      branch{
      cond l1*`xscl1+`xofs1 < l2*`xscl2+`xofs2:
        if(r1*`xscl1+`xofs1 < l2*`xscl2+`xofs2) break;
      else:
        if(l1*`xscl1+`xofs1 > r2*`xscl2+`xofs2) break;
      comm:
        branch{
        cond (float)c1.b*`yscl1+`yofs1 < (float)c2.b*`yscl2+`yofs2:
          if(
            (float)(c2.t-1)*`yscl2+`yofs2
            <= (float)c1.b*`yscl1+`yofs1) ret true;
        else:
          if(
            (float)c2.b*`yscl2+`yofs2
            >= (float)(c1.t-1)*`yscl1+`yofs1) ret true;
        }
      }
      ret false;
    }
    if(#pr.ani == 0 || #pr.ani~ani.frames == 0) ret false;
    if(#`ani == 0 || #`curFrame == 0) ret false;
    ^&.act.Frame frm;
    ^&.act.Rect clsn1 = pr.ani~ani.currentFrame()=>frm#frm~clsn2;
    if(`stVal.hit.reversal_attr > 0) clsn1 = frm~clsn1;
    ^&.act.Rect clsn2 = `curFrame~clsn1;
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(hentei(clsn1[i], clsn2[j])) ret true;
        j++;
      while j < #clsn2:
      }
      i++;
    while i < #clsn1:
    }
    ret false;
  }
  public void tick()
  {
    if(#`ani > 0 && `acttmp > 0) `ani~ani.action();
    if(!`isPaused()){
      branch{
      cond `stVal.hb.hitshaketime > 0:
        `stVal.hb.hitshaketime--;
      else:
        if(`stVal.hb.hittime > 0){
          `stVal.hb.hittime--;
          if(`isFall()){
            `defencemul *= `sysfvar[.fFALL_DEFENCE_MUL];
            `stVal.hb.fallcount++;
          }
        }
        if(`stVal.hb.fall.recovertime > 0) `stVal.hb.fall.recovertime--;
      }
      branch{
      cond `sysivar[.iHITPAUSETIME] > 0:
        `sysivar[.iHITPAUSETIME]--;
      else:
        if(`stVal.mctime > 0) `stVal.mctime++;
      }
      if(!`isHitPaused()){
        if(`stVal.hb.fall.recovertime > 0) `stVal.hb.fall.recovertime--;
        if(`stVal.hb.hitt1 > 0) `stVal.hb.hitt1--;
        if(`stVal.hb.hitt2 > 0) `stVal.hb.hitt2--;
        loop{index i = 0; while; do:
          if(`stVal.ho[i].time > 0) `stVal.ho[i].time--;
          i++;
        while i < #`stVal.ho:
        }
        if(`sysivar[.iBINDTIME] > 0){
          if(--`sysivar[.iBINDTIME] == 0) branch{
            ^`self c = .players.get(`sysivar[.iBINDTOID]);
            if(#c == 0) break;
          cond c~isTarget(`id):
            `setXV((float)(`facing*c~facing)*c~sysfvar[.fVX]);
            `setYV(c~sysfvar[.fVY]);
          cond `isTarget(c~id):
            c~setXV((float)(`facing*c~facing)*`sysfvar[.fVX]);
            c~setYV(`sysfvar[.fVY]);
          }
        }
        `sysivar[.iSPECIALFLAG] &= !.lsGUARD;
      }
    }
    `sysivar[.iSPECIALFLAG] &= !.lsBindCancel;
    if(`sysivar[.iBINDTIME] == 0) `sysivar[.iBINDTOID] = -1;
    if(`tmphit){
      `stVal.hit.invalidate();
      `tmphit = false;
    }
    if(`stVal.mctime < 0){
      `stVal.mctime = 1;
      if(`stVal.mctyp == .MoveContact::Hit){
        `stVal.juggle = 0;
        `sysivar[.iHITCOUNT] += `stVal.hit.numhits;
      }
    }
    ^`self c;
    if(
      `ls(.lsGETHIT) && #`stVal.hb.byid > 0
      && #(c = .players.get(`stVal.hb.byid[-1])) > 0)
    {
      if(`stVal.hb.p1getp2facing != 0){
        c~setFacing(`facing*`stVal.hb.p1getp2facing);
      }
      if(`stVal.hb.mindistx != .com.FERR) branch{
      cond c~facing < 0:
        `sysfvar[.fX] =
          .m.min!float?(`sysfvar[.fX])<, (c~sysfvar[.fX] - `stVal.hb.mindistx);
      else:
        `sysfvar[.fX] =
          .m.max!float?(`sysfvar[.fX])<, (c~sysfvar[.fX] + `stVal.hb.mindistx);
      }
      if(`stVal.hb.maxdistx != .com.FERR) branch{
      cond c~facing < 0:
        `sysfvar[.fX] =
          .m.max!float?(`sysfvar[.fX])<, (c~sysfvar[.fX] - `stVal.hb.maxdistx);
      else:
        `sysfvar[.fX] =
          .m.min!float?(`sysfvar[.fX])<, (c~sysfvar[.fX] + `stVal.hb.maxdistx);
      }
      if(
        `stVal.playerno != `playerno
        || `stVal.hb.guarded == 0 || `stVal.typ == .StTy::A)
      {
        if(`stVal.hb.mindisty != .com.FERR){
          `sysfvar[.fY] =
            .m.max!float?(`sysfvar[.fY])<,
            (c~sysfvar[.fY] + `stVal.hb.mindisty);
        }
        if(`stVal.hb.maxdisty != .com.FERR){
          `sysfvar[.fY] =
            .m.min!float?(`sysfvar[.fY])<,
            (c~sysfvar[.fY] + `stVal.hb.maxdisty);
        }
      }
    }
    if(`cs1tmp) `sysivar[.iSPECIALFLAG] &= !.lsGETHIT;
    `enemyn.new(0);
    if(`ls(.lsGETHIT)) branch{
    cond `stVal.typ == .StTy::L:
      .v.setI(5080)$`trSelfState(-1, 0);
    cond `stVal.hb.guarded != 0:
      switch(`stVal.typ){
      case .StTy::S:
        .v.setI(150)$`trSelfState(-1, 0);
      case .StTy::C:
        .v.setI(152)$`trSelfState(-1, 0);
      case .StTy::A:
        .v.setI(154)$`trSelfState(-1, 0);
      }
    cond `stVal.hb.typ == 3:
      .v.setI(5070)$`trSelfState(-1, 0);
    else:
      if(`stVal.hb.yvel != 0.0 || `stVal.hb.fallf != 0){
        `stVal.typ = .StTy::A;
      }
      switch(`stVal.typ){
      case .StTy::S:
        .v.setI(5000)$`trSelfState(-1, 0);
      case .StTy::C:
        .v.setI(5010)$`trSelfState(-1, 0);
      case .StTy::A:
        .v.setI(5020)$`trSelfState(-1, 0);
      }
    }
    branch{
    cond `stVal.typ == .StTy::A:
      if(`cmd.buffer~U < 0) `sysivar[.iSYSFLAG] |= .sfAIRJUMP;
    else:
      `sysivar[.iAIRJUMP_CNT] = 0;
      `sysivar[.iSYSFLAG] &= !.sfAIRJUMP;
    }
    if(`stVal.no == 140 && `trAnimTime()$.v.toInt() == 0){
      .v.setI(
        (int)(`stVal.typ == .StTy::C)*11 + (int)(`stVal.typ == .StTy::A)*51);
      `trSelfState(-1, -1);
    }
    if(`isActive()) branch{
    cond `ctrl():
      branch{
      cond `stVal.typ == .StTy::S && `cmd.buffer~D > 0:
        if(`stVal.no != 10) .v.setI(10)$`trSelfState(-1, -1);
      cond `stVal.typ == .StTy::C && `cmd.buffer~D < 0:
        if(`stVal.no != 12) .v.setI(12)$`trSelfState(-1, -1);
      cond !.roundEnd() && `stVal.typ != .StTy::A && `cmd.buffer~U > 0:
        if(`stVal.no != 40) .v.setI(40)$`trSelfState(-1, -1);
      cond
        `stVal.typ == .StTy::A && (`sysivar[.iSYSFLAG]&.sfAIRJUMP) != 0
        && `sysfvar[.fY] <= (float)`sysivar[.iAIRJUMP_HEIGHT]
        && `sysivar[.iAIRJUMP_CNT] < `sysivar[.iAIRJUMP_NUM]
        && `cmd.buffer~U > 0
        :
        if(`stVal.no != 45){
          `sysivar[.iAIRJUMP_CNT]++;
          `sysivar[.iSYSFLAG] &= !.sfAIRJUMP;
          .v.setI(45)$`trSelfState(-1, -1);
        }
      cond
        !`ls(.lsNOWALK) && `stVal.typ == .StTy::S
        && (
          `cmd.buffer~F > 0 || (
            (!`inguarddist || `ls(.lsNOSTANDGUARD)) && `cmd.buffer~B > 0))
        :
        if(`stVal.no != 20) .v.setI(20)$`trSelfState(-1, -1);
      cond `stVal.no == 20 && (`cmd.buffer~F < 0 && `cmd.buffer~B < 0):
        .v.setI(0)$`trSelfState(-1, -1);
      }
      if(
        `ctrl() && `inguarddist && (`stVal.no < 120 || `stVal.no >= 160) && (
          (`stVal.typ == .StTy::S && !`ls(.lsNOSTANDGUARD))
          || (`stVal.typ == .StTy::C && !`ls(.lsNOCROUCHGUARD))
          || (`stVal.typ == .StTy::A && !`ls(.lsNOAIRGUARD)))
        && `cmd.buffer~B > 0)
      {
        .v.setI(120)$`trSelfState(-1, -1);
      }
    cond `sysivar[.iCTRL] != 0 || .roundState() == 4:
      switch(`stVal.no){
      case 11:
        .v.setI(12)$`trSelfState(-1, 1);
      case 20:
        .v.setI(0)$`trSelfState(-1, 1);
      }
    comm:
      if(
        .m.inRange!int?(120, 159, `stVal.no) || (
          `keyctrl && `ctrl() && `cmd.buffer~B > 0 && (
            (`stVal.typ == .StTy::S && !`ls(.lsNOSTANDGUARD))
            || (`stVal.typ == .StTy::C && !`ls(.lsNOCROUCHGUARD))
            || (`stVal.typ == .StTy::A && !`ls(.lsNOAIRGUARD)))))
      {
        `sysivar[.iSPECIALFLAG] |= .lsGUARD;
      }
    }
    if(`player) `state_i1(::);
    `minus = 2;
  }
  public void drawAnim()
  {
    if(`helperindex < 0 || `id < 0) ret;
    float x = `sysfvar[.fX]+`offsetx;
    float y = `sysfvar[.fY]+`offsety;
    float xs = (float)`facing * `sysfvar[.fXSCALE];
    float ys = `sysfvar[.fYSCALE];
    if(.com.clsndraw && #`curFrame > 0){
      ^&.act.Frame frm = `curFrame;
      ^&.act.Rect clsn = frm~clsn1;
      if(#clsn > 0 && `atktmp >= 0) .drawc1.new[-1].set(clsn, x, y, xs, ys);
      clsn = frm~clsn2;
      if(#clsn > 0) branch{
      cond `stVal.hb.hitt1 != 0 || `stVal.hb.hitt2 != 0:
        .drawc2sp.new[-1].set(clsn, x, y, xs, ys);
      else:
        .drawc2.new[-1].set(clsn, x, y, xs, ys);
      }
      if(`ls(.lsPLAYERPUSH)){
        clsn.new(1);
        clsn~l = (short)-`backw;
        clsn~t = (short)-.com.BodyHeight + 1;
        clsn~r = (short)`frontw - 1;
        clsn~b = 0;
        .drawwh.new[-1].set(clsn, x-`offsetx, y-`offsety, (float)`facing, 1.0);
      }
    }
    if(#`ani > 0) branch{
      int sp = `sprpriority;
      int br = 256 >> (int)(
        .super > 0 && .superdarken != 0 && `playerno != .superplayer);
      float an =
        `ls(.lsANGLEDRAW)
        ? (`sysfvar[.fANGLE] == 0.0 ? 360.0 : `sysfvar[.fANGLE]) : 0.0;
    cond !`ls(.lsINVISIBLE):
      if(`ls(.lsANGLEDRAW) && !`ls(.lsTRANS)){
        `sysivar[.iSPECIALFLAG] |= .lsTRANS;
        `sysivar[.iALPHAS] = 255;
        `sysivar[.iALPHAD] = 0;
      }
      .addAnimList(
        .anims=, `ani, sp,
        x - (float)(
          (int)(`stVal.hb.hitshaketime > 0 && (`stVal.time&1) != 0)
          * `facing),
        y, .com.scale, xs, ys, an, `angleset,
        `sysfvar[.fANGLESCALEX], `sysfvar[.fANGLESCALEY],
        `ls(.lsTRANS) ? `sysivar[.iALPHAS] : -1,
        `sysivar[.iALPHAD], br, `getPalfx(),
        `ls(.lsNOSHADOW) ? 0 : -1, (float)`sysivar[.iSHADOWOFFSET]);
      `aimg.recAndAddAL(
        `ani<>=, sp, x, y, xs, ys,
        an, `angleset, `sysfvar[.fANGLESCALEX], `sysfvar[.fANGLESCALEY],
        .com.tickNextFrame() && `acttmp > 0, br);
    cond .com.tickNextFrame() && `acttmp > 0:
      `aimg.recAfterImg(
        `ani<>=, x, y, xs, ys,
        an, `angleset, `sysfvar[.fANGLESCALEX], `sysfvar[.fANGLESCALEY]);
    }
    if(.com.tickNextFrame()){
      if(
        .supertime < 0
        && (`playerno&1) != (.superplayer&1) && `stVal.mov == .MovTy::H)
      {
        `defencemul *= .superp2defmul;
      }
      if(
        !.roundEnd() && .gs(.gsNOKO)
        && `helperindex == 0 && `sysivar[.iLIFE] <= 0)
      {
        `sysivar[.iLIFE] = 1;
      }
    }
  }
  public bool isPaused()
  {
    ret `acttmp <= -2;
  }
  public bool isHitPaused()
  {
    ret `sysivar[.iHITPAUSETIME] > 0;
  }
  public bool isActive()
  {
    ret !`isPaused() && !`isHitPaused();
  }
  public bool isBound()
  {
    loop{
      index i = 0;
      ^`self by;
      while;
    do:
      if(
        `sysivar[.iBINDTOID] == `stVal.hb.byid[i]
        && `sysivar[.iBINDTIME] != 0)
      {
        ret true;
      }
      by = .players.get(`stVal.hb.byid[i]);
      if(
        #by > 0 && by~sysivar[.iBINDTOID] == `id
        && by~sysivar[.iBINDTIME] != 0)
      {
        ret true;
      }
      i++;
    while i < #`stVal.hb.byid:
    }
    ret false;
  }
  public bool isFreezeX()
  {
    ret `ls(.lsPOSFREEZEX) || `isBound();
  }
  public bool pushable()
  {
    ret
      `ls(.lsPLAYERPUSH) && !`isFreezeX()
      && #`curFrame > 0 && (#`curFrame~clsn1 > 0 || #`curFrame~clsn2 > 0);
  }
  public bool isFall()
  {
    ret `stVal.hb.fallf != 0 && `stVal.hb.hittime <= 0;
  }
  public float getHeight()
  {
    ret (float)`sysivar[.iHEIGHT];
  }
  void lSetNormal()
  {
    if((!`ls(.lsGETHIT) && `stVal.mov != .MovTy::H) || `stVal.hb.guarded != 0){
      `getcombo = 0;
    }
    `sysivar[.iSPECIALFLAG] &=
      .lsGUARD | (`isHitPaused() ? .lsANGLEDRAW | .lsTRANS : 0);
    `sysivar[.iSPECIALFLAG] |=
      `player && (`sysivar[.iLIFE] > 0 || `sysivar[.iRECOVERTIME] > 0)
      ? .lsSCREENBOUNDX | .lsSCREENBOUNDY | .lsPLAYERPUSH : 0;
    `attackmul = (float)`sysivar[.iATTACK] * (1.0/100.0);
    `attackdist = (float)`sysivar[.iATTACK_DIST];
    `offsetx = (float)`sysivar[.iDRAW_OFFSETX];
    `offsety = (float)`sysivar[.iDRAW_OFFSETY];
    if(.super <= 0){
      `sysivar[.iMOVETIMESUPER] = 0;
      if(.pause <= 0) `sysivar[.iMOVETIMEPAUSE] = 0;
    }
  }
  public float defFW()
  {
    ret
      (float)(
        `stVal.typ == .StTy::A
        ? `sysivar[.iAIR_FRONT] : `sysivar[.iGROUND_FRONT]);
  }
  public float defBW()
  {
    ret
      (float)(
        `stVal.typ == .StTy::A
        ? `sysivar[.iAIR_BACK] : `sysivar[.iGROUND_BACK]);
  }
  public void targetAction()
  {
    loop{
      index i = 0;
      ^`self c;
      while;
    do:
      c = .players.get(`targets[i]);
      if(#c > 0){
        c~action();
        if(
          `destmp && c~stVal.playerno != c~playerno
          && c~sysivar[.iBINDTIME] != 0 && c~sysivar[.iBINDTOID] == `id)
        {
          .v.setI(5050)$c~trSelfState(-1, -1);
        }
      }
      i++;
    while i < #`targets:
    }
  }
  public bool landCondition()
  {
    ret
      `stVal.phy == .StTy::A && `isActive() && `sysfvar[.fVY] > 0.0
      && `sysfvar[.fY] >= 0.0 && `stVal.no != 105 && `stVal.no != 52;
  }
  public void action()
  {:<-
    bool isSuperPaused()
    {
      ret
        .super > 0 && `sysivar[.iSUPERMOVETIME] == 0
        && `sysivar[.iMOVETIMESUPER] <= 0;
    }
    bool isNormalPaused()
    {
      ret
        .super <= 0 && .pause > 0 && `sysivar[.iPAUSEMOVETIME] == 0
        && `sysivar[.iMOVETIMEPAUSE] <= 0;
    }
    if(`minus != 2) ret;
    {
      if(#`palfx > 0 && !`isPaused()) `palfx~step();
      bool p = isSuperPaused() || isNormalPaused();
      `acttmp = -(int)p * 2;
      bool lc = !`ls(.lsGETHIT) && `landCondition();
      `bind();
      {
        if(p && !`cs1tmp) ret;
        branch{
        cond .super > 0:
          if(`sysivar[.iSUPERMOVETIME] > 0) `sysivar[.iSUPERMOVETIME]--;
          if(`sysivar[.iMOVETIMESUPER] > 0) `sysivar[.iMOVETIMESUPER]--;
        cond .pause > 0:
          if(`sysivar[.iPAUSEMOVETIME] > 0) `sysivar[.iPAUSEMOVETIME]--;
          if(`sysivar[.iMOVETIMEPAUSE] > 0) `sysivar[.iMOVETIMEPAUSE]--;
        }
        `lSetNormal();
        `minus = -3;
        if(`stVal.playerno == `playerno && `player) `state_3(::);
        `minus = -2;
        if(`player) `state_2(::);
        `minus = -1;
        if(`keyctrl && `stVal.playerno == `playerno) `state_1(::);
      break:
        if(!`isHitPaused()) `changeState2();
        if(`stVal.hb.damage != 0 && `stVal.mov == .MovTy::H) branch{
        cond `stVal.hb.guarded != 0:
          if(
            `addLife(-`stVal.hb.damage, true, true)
            && `helperindex == 0) branch
          {
            ^`self by;
            if(#`stVal.hb.byid == 0) else;
            by = .players.get(`stVal.hb.byid[-1]);
            if(#by == 0) else;
          cond by~playerno == `playerno:
            .winty[(`playerno+1)&1] = .fgt.WinTy::Suicide;
          cond (by~playerno&1) == (`playerno&1):
            .winty[(`playerno+1)&1] = .fgt.WinTy::Teammate;
          else:
            .winty[(`playerno+1)&1] = .fgt.WinTy::C;
          }
        else:
          if(`addLife(-`stVal.hb.damage, true, true)) branch{
            ^`self by;
            if(#`stVal.hb.byid == 0) else;
            by = .players.get(`stVal.hb.byid[-1]);
            if(#by == 0) else;
          cond (by~playerno&1) == (`playerno&1):
            if(`helperindex == 0) branch{
            cond by~playerno == `playerno:
              .winty[(`playerno+1)&1] = .fgt.WinTy::Suicide;
            else:
              .winty[(`playerno+1)&1] = .fgt.WinTy::Teammate;
            }
          else:
            `setEnemyWinty();
          }
        }
      }
      if(!`cs1tmp){
        if(lc) .v.setI(52)$`trSelfState(-1, -1);
        if(`stVal.no == 0 && `sysivar[.iLIFE] <= 0){
          .v.setI(5050)$`trSelfState(-1, -1);
        }
        `minus = 0;
        `state(::);
        if(`isActive()) `stVal.time++;
      }
    break:
      `minus = 1;
      `acttmp += (int)`isActive() - (int)`isHitPaused();
      branch{
      cond #`ani > 0:
        `curFrame = `ani~ani.currentFrame();
        `ani~ani.updateSprite();
      else:
        `curFrame.new(0);
      }
      if(!`isHitPaused()){
        if(!`ls(.lsFRONTWCHANGE)) `frontw = `defFW();
        if(!`ls(.lsBACKWCHANGE)) `backw = `defBW();
        if(!`ls(.lsFEDGECHANGE)) `fedge = 0.0;
        if(!`ls(.lsBEDGECHANGE)) `bedge = 0.0;
      }
      `targetAction();
    }
  }
  public void move(
    float highest=, float lowest=, float leftest=, float rightest=)
  {
    if(.com.tickFrame()){
      `action();//TargetDropされたとき
      if(`destmp){
        `destroySelf();
        ret;
      }
      if(!`ls(.lsPOSFREEZEY) && `ls(.lsGRAVITY)){
        `sysfvar[.fVY] += `sysfvar[.fYACCEL];
      }
    }
    if(`acttmp > 0){
      float sp = .m.min!float?(1.0, .com.turbo);
      if(!`ls(.lsPOSFREEZEX)){
        `sysfvar[.fX] += (`sysfvar[.fVX]*(float)`facing + `veloff) * sp;
        if(.com.tickNextFrame()){
          `veloff *= `sysfvar[.fSTAND_FRICTION] * `sysfvar[.fSTAND_FRICTION];
          if(#`veloff < 1.0) `veloff = 0.0;
        }
      }
      if(!`ls(.lsPOSFREEZEY)) `sysfvar[.fY] += `sysfvar[.fVY] * sp;
      if(.com.tickNextFrame()) switch(`stVal.phy){
      case .StTy::S:
        if(!`ls(.lsPOSFREEZEX)) `sysfvar[.fVX] *= `sysfvar[.fSTAND_FRICTION];
        if(#`sysfvar[.fVX] < 1.0) `sysfvar[.fVX] = 0.0;
      case .StTy::C:
        if(!`ls(.lsPOSFREEZEX)) `sysfvar[.fVX] *= `sysfvar[.fCROUCH_FRICTION];
      default:<-
        if(!`ls(.lsPOSFREEZEY)){
          `sysfvar[.fVY] +=
            `sysfvar[.fYACCEL] * (float)(`stVal.phy == .StTy::A);
        }
      }
    }
    if(`ls(.lsSCREENBOUNDX)){
      float l, r;
      branch{
      cond `facing > 0:
        l = `bedge; r = `fedge;
      else:
        l = `fedge; r = `bedge;
      }
      .m.limRange!float?(`sysfvar[.fX]=, .com.xmin+l, .com.xmax-r);
      leftest = .m.min!float?(`sysfvar[.fX]-l, leftest);
      rightest = .m.max!float?(`sysfvar[.fX]+r, rightest);
    }
    if(`ls(.lsSCREENBOUNDY)){
      highest = .m.min!float?(`sysfvar[.fY], highest);
      lowest = .m.min!float?(0.0)<, .m.max!float?(`sysfvar[.fY], lowest);
    }
  }
  public void bind()
  {
    if(`sysivar[.iBINDTIME] == 0) ret;
    ^`self c = .players.get(`sysivar[.iBINDTOID]);
    if(#c == 0 || `destmp || (`isTarget(c~id) && c~ls(.lsBindCancel))){
      `sysivar[.iBINDTIME] = 0;
      ret;
    }
    if(`sysfvar[.fBINDPOSX] != .com.FERR){
      float f =
        (float)(
          #`sysivar[.iBINDFACING] == 2
          ? `sysivar[.iBINDFACING]/2 : c~facing);
      `setX(c~sysfvar[.fX] + f*`sysfvar[.fBINDPOSX]);
    }
    if(`sysfvar[.fBINDPOSY] != .com.FERR){
      `sysfvar[.fY] = c~sysfvar[.fY] + `sysfvar[.fBINDPOSY];
    }
    if(#`sysivar[.iBINDFACING] == 1) branch{
    cond `sysivar[.iBINDFACING] > 0: `facing = c~facing;
    cond `sysivar[.iBINDFACING] < 0: `facing = -c~facing;
    }
  }
  public void xScreenBound()
  {
    if(`ls(.lsSCREENBOUNDX)){
      float l, r;
      branch{
      cond `facing > 0:
        l = `bedge; r = `fedge;
      else:
        l = `fedge; r = `bedge;
      }
      float oldx = `sysfvar[.fX];
      .m.limRange!float?(`sysfvar[.fX]=, .com.xmin+l, .com.xmax-r);
      if(oldx != `sysfvar[.fX] && `sysivar[.iBINDTIME] != 0){
        ^`self c = .players.get(`sysivar[.iBINDTOID]);
        if(#c == 0) break;
        if(!`isTarget(c~id)){
          `sysfvar[.fX] = oldx;
          break, break;
        }
        c~sysfvar[.fX] += `sysfvar[.fX] - oldx;
        c~xScreenBound();
      }
    }
  }
  public float update(float tension)
  {
    if(.com.tickFrame()){
      `atktmp =
        (`stVal.mov != .MovTy::I || `stVal.hit.reversal_attr > 0)
        && `isActive() ? `stVal.no : -1;
      branch{
      cond `stVal.mov == .MovTy::H:
        `hittmp =
          (int)(
            `stVal.hb.fallf != 0 && `hittmp > 0 && !`isBound()
            && (`stVal.typ == .StTy::A || `stVal.typ == .StTy::L))
          * ((int)`isFall() + 1) + 1;
        if(
          `isActive() && `sysfvar[.fY] == 0.0 && #`sysfvar[.fVX] >= 1.0
          && `stVal.time % 3 == 0)
        {
          `makeDust(0.0, 0.0);
        }
      else:
        if(`hittmp > 0) `hittmp = 0;
        `defencemul = (float)`sysivar[.iDEFENCE] * (1.0/100.0);
        `stVal.hb.hittime = 0;
        `stVal.hb.hitshaketime = 0;
        `stVal.hb.fallf = 0;
        `stVal.hb.fallcount = 0;
        `stVal.hb.juggle = 0;
      }
      if(
        `stVal.playerno == `playerno && (
          `hittmp <= 0 || (
            .roundState() == 2
            && `sysivar[.iLIFE] <= 0 && `sysivar[.iRECOVERTIME] <= 0)))
      {
        `outTarget();
      }
    }
    `bind();
    `xScreenBound();
    float cvx = 0.0;
    if(`ls(.lsSCREENBOUNDX)){
      if(tension > 0.0 && !`isFreezeX()) branch{
      cond
        `sysfvar[.fX] < .com.xmin - .com.screenleft + tension
        || `sysfvar[.fX] > .com.xmax + .com.screenright - tension
        :
        cvx += `sysfvar[.fX] - `oldx;
      }
    }
    `oldx = `sysfvar[.fX];
    ret cvx;
  }
  public void posReset(float p1x, float p2x)
  {
    `facing = (`playerno&1) == 0 ? 1 : -1;
    `setX(
      ((`playerno&1) == 0 ? p1x : p2x)
      + (float)(`playerno*-`facing / 2) * .com.P1P3Dist);
    `setY(0.0);
    `setXV(0.0);
    `setYV(0.0);
  }
  void nikou<if_t, ff_t>(&.Var rtn=, &.Var var1, &.Var var2)
  {
    &.Var v1 = var1, v2 = var2;
    if(v1.isSF()) v1.setB(false);
    if(v2.isSF()) v2.setB(false);
    branch{
    cond v1.typ == v2.typ:
      branch{
      cond v1.typ == .VarTy::Int:
        if_t(rtn=, v1.i, v2.i);
      else:
        ff_t(rtn=, v1.f, v2.f);
      }
    else:
      branch{
      cond v1.typ == .VarTy::Int:
        ff_t(rtn=, (float)v1.i, v2.f);
      else:
        ff_t(rtn=, v1.f, (float)v2.i);
      }
    }
  }
  public void setLife(int l)
  {
    if(.roundEnd()) ret;
    `sysivar[.iLIFE] = .m.max!int?(0)<, .m.min!int?(`sysivar[.iLIFEMAX])<, l;
  }
  public int getDamage(int damage, bool kill, bool absolute, float atkmul)
  {
    int d = damage;
    if(!absolute){
      d = (int).m.ceil((float)d*atkmul / `defencemul);
    }
    if(`player){
      .m.limRange!int?(
        d=, `sysivar[.iLIFE]-`sysivar[.iLIFEMAX],
        .m.max!int?(0, `sysivar[.iLIFE]-(int)!kill));
    }
    ret d;
  }
  public bool addLife(int l, bool kill, bool absolute)
  {
    if(.com.intro > 0 || .roundEnd()) ret false;
    bool foo = `sysivar[.iLIFE] != 0;
    `sysivar[.iLIFE] +=
      (int).m.floor((float)l / (absolute ? 1.0 : `defencemul));
    .m.limRange!int?(
      `sysivar[.iLIFE]=, kill || !foo ? 0 : 1, `sysivar[.iLIFEMAX]);
    if(`helperindex == 0 && `sysivar[.iLIFE] == 0){
      `stVal.hb.fallf = 1;
      `stVal.hb.fall.recover = 0;
      if(!foo) break;
      branch{
      cond `stVal.mov == .MovTy::H || `stVal.playerno != `playerno:
        `setEnemyWinty();
      else:
        if(`helperindex == 0) .winty[(`playerno+1)&1] = .fgt.WinTy::Suicide;
      }
      ret true;
    }
    ret false;
  }
  public void setPower(int p)
  {
    if(.roundEnd()) ret;
    `sysivar[.iPOWER] = .m.max!int?(0)<, .m.min!int?(`sysivar[.iPOWERMAX])<, p;
  }
  public int getSharePower()
  {
    ret .chars[`playerno & (.com.powershare?1:-1)][0]~sysivar[.iPOWER];
  }
  public void addPower(int p)
  {
    .chars[`playerno&(.com.powershare?1:-1)][0]~setPower(`getSharePower() + p);
  }
  public void setFacing(int f)
  {
    if(f == 0) ret;
    if((`facing < 0) != (f < 0)){
      `facing *= -1;
      `sysfvar[.fVX] *= -1.0;
    }
  }
  void setFWidth(float f)
  {
    if(f != .com.FERR){
      `frontw = `defFW() + f;
      `sysivar[.iSPECIALFLAG] |= .lsFRONTWCHANGE;
    }
  }
  void setBWidth(float b)
  {
    if(b != .com.FERR){
      `backw = `defBW() + b;
      `sysivar[.iSPECIALFLAG] |= .lsBACKWCHANGE;
    }
  }
  void setFEdge(float f)
  {
    if(f != .com.FERR){
      `fedge = f;
      `sysivar[.iSPECIALFLAG] |= .lsFEDGECHANGE;
    }
  }
  void setBEdge(float b)
  {
    if(b != .com.FERR){
      `bedge = b;
      `sysivar[.iSPECIALFLAG] |= .lsBEDGECHANGE;
    }
  }
  void setHitdefDefault(&.Hitdef h=, bool proj)
  {
    if(!proj && h.guard_dist < 0) h.guard_dist = `sysivar[.iATTACK_DIST];
    if(h.guard_pausetime < 0) h.guard_pausetime = h.pausetime;
    if(h.guard_shaketime < 0) h.guard_shaketime = h.shaketime;
    if(
      h.hitonce < 0
      || (h.attr&((int).AtTy::NT|(int).AtTy::ST|(int).AtTy::HT)) != 0)
    {
      h.hitonce = 1;
    }
    if(h.guard_hittime < 0) h.guard_hittime = h.ground_hittime;
    if(h.guard_slidetime < 0) h.guard_slidetime = h.guard_hittime;
    if(h.guard_ctrltime < 0) h.guard_ctrltime = h.guard_slidetime;
    if(h.ground_velocityx == .com.FERR) h.ground_velocityx = 0.0;
    if(h.ground_velocityy == .com.FERR) h.ground_velocityy = 0.0;
    if(h.air_velocityx == .com.FERR) h.air_velocityx = 0.0;
    if(h.air_velocityy == .com.FERR) h.air_velocityy = 0.0;
    if(h.guard_velocity == .com.FERR) h.guard_velocity = h.ground_velocityx;
    if(h.airguard_ctrltime < 0) h.airguard_ctrltime = h.guard_ctrltime;
    if(h.airguard_velocityx == .com.FERR){
      h.airguard_velocityx = h.air_velocityx*1.5;
    }
    if(h.airguard_velocityy == .com.FERR){
      h.airguard_velocityy = h.air_velocityy*0.5;
    }
    if(h.down_velocityx == .com.FERR) h.down_velocityx = h.air_velocityx;
    if(h.down_velocityy == .com.FERR) h.down_velocityy = h.air_velocityy;
    if(h.air_fall == .com.IERR) h.air_fall = h.ground_fall;
    if(h.fall.animtype == .AnimTy::Unknown) branch{
    cond h.air_animtype != .AnimTy::Unknown:
      h.fall.animtype = h.air_animtype;
    cond (int)h.animtype < 3:
      h.fall.animtype = .AnimTy::Back;
    else:
      h.fall.animtype = h.animtype;
    }
    if(h.air_animtype == .AnimTy::Unknown) h.air_animtype = h.animtype;
    if(h.air_type == .ReactTy::Unknown) h.air_type = h.ground_type;
    if(h.forcestand == .com.IERR){
      h.forcestand = (int)(h.ground_velocityy != 0.0);
    }
    if(h.ground_cornerpush_veloff == .com.FERR){
      h.ground_cornerpush_veloff =
        (h.attr & (int).StTy::A) != 0 ? 0.0 : h.guard_velocity*1.3;
    }
    if(h.air_cornerpush_veloff == .com.FERR){
      h.air_cornerpush_veloff = h.ground_cornerpush_veloff;
    }
    if(h.down_cornerpush_veloff == .com.FERR){
      h.down_cornerpush_veloff = h.ground_cornerpush_veloff;
    }
    if(h.guard_cornerpush_veloff == .com.FERR){
      h.guard_cornerpush_veloff = h.ground_cornerpush_veloff;
    }
    if(h.airguard_cornerpush_veloff == .com.FERR){
      h.airguard_cornerpush_veloff = h.ground_cornerpush_veloff;
    }
    if(h.hitgetpower == .com.IERR){
      h.hitgetpower = (int)(.cfg.Attack_LifeToPowerMul*(float)(h.hitdamage));
    }
    if(h.guardgetpower == .com.IERR){
      h.guardgetpower =
        (int)(.cfg.Attack_LifeToPowerMul*(float)(h.hitdamage)*0.5);
    }
    if(h.hitgivepower == .com.IERR){
      h.hitgivepower = (int)(.cfg.GetHit_LifeToPowerMul*(float)(h.hitdamage));
    }
    if(h.guardgivepower == .com.IERR){
      h.guardgivepower =
        (int)(.cfg.GetHit_LifeToPowerMul*(float)(h.hitdamage)*0.5);
    }
    if(h.hitdamage == .com.IERR) h.hitdamage = 0;
    if(h.guarddamage == .com.IERR) h.guarddamage = 0;
    if(h.p1facing == .com.IERR) h.p1facing = 0;
    if(h.p2facing == .com.IERR) h.p2facing = 0;
    if(h.p1getp2facing == .com.IERR) h.p1getp2facing = 0;
    if(h.fall.yvelocity == .com.FERR) h.fall.yvelocity = -4.5;
    if(h.fall.recovertime == .com.IERR) h.fall.recovertime = 4;
    if(h.fall.damage == .com.IERR) h.fall.damage = 0;
  }
  void playSound(
    bool f, bool lw, bool lp, int g, int s, int ch,
    int vo, float p, float fr, ^float x)
  {
    if(g < 0) ret;
    ^&.snd.Sound sou = `newChannel(ch, lw);
    if(#sou == 0) ret;
    branch{
    cond f:
      if(#.fight~fsn == 0) break;
      sou~sound = .fight~fsn~getSound(g, s);
    else:
      if(#`sn == 0) break;
      sou~sound = `sn~getSound(g, s);
    }
    sou~chrx = x;
    sou~setVol(vo);
    sou~loop_ = lp;
    sou~lowpriority = lw;
    sou~setPan(p * (float)`facing);
    sou~freqmul = fr;
    sou~fidx = 0.0;
  }
  void ifAlaSetVyZero()
  {
    if(
      `stVal.typ == .StTy::A
      || `stVal.typ == .StTy::L || `stVal.phy == .StTy::A)
    {
      `setYV(0.0);
    }
  }
  public bool ctrlOver()
  {
    ret
     .com.time == 0
     || .com.intro < -(.fight~ro.over_hittime + .fight~ro.over_waittime);
  }
  public bool ctrl()
  {
    ret
      `sysivar[.iCTRL] != 0 && `sysivar[.iLIFE] > 0
      && .com.intro <= 0 && !`ctrlOver();
  }
  public void setCtrl(bool c)
  {
    `sysivar[.iCTRL] = (int)c;
  }
  public void destroySelf()
  {
    if(`helperindex <= 0) ret;
    loop{
      index i = 0;
      ^`self c;
      while;
    do:
      c = .players.get(`targets[i]);
      if(#c > 0){
        c~byBindClear();
        c~stVal.hb.dropByid(`id);
      }
      i++;
    while i < #`targets:
    }
    if(`parentindex >= 0) loop{index i = 0; while; do:
      if(.chars[`playerno][`parentindex]~children[i] == `helperindex){
        .chars[`playerno][`parentindex]~children[i] = -1;
        break, break;
      }
      i++;
    while i < #.chars[`playerno][`parentindex]~children:
    break:
      `parentindex *= -1;
    }
    loop{index i = 0; while; do:
      if(`children[i] >= 0){
        .chars[`playerno][`children[i]]~parentindex *= -1;
        `children[i] = -1;
      }
      i++;
    while i < #`children:
    }
    ^&.com.PalFX fx = `getPalfx();
    if(fx~player == `id) fx~time = 0;
    .players.destroy(`id);
    `helperindex = -1;
  }
  public void setX(float x)
  {
    `sysfvar[.fX] = `oldx = x;
    `enemyn.new(0);
    if(`player) loop{index i = (`playerno+1) & 1; while; do:
      loop{index j = 0; while; do:
        .chars[i][j]~enemyn.new(0);
        j++;
      while j < #.chars[i]:
      }
      i += 2;
    while i < #.chars:
    }
  }
  public void setY(float y)
  {
    `sysfvar[.fY] = y;
  }
  public void setXV(float xv)
  {
    `sysfvar[.fVX] = xv;
    if(xv != 0.0){
      `sysivar[.iBINDTIME] = 0;
      `sysivar[.iSPECIALFLAG] |= .lsBindCancel;
    }
  }
  public void setYV(float yv)
  {
    `sysfvar[.fVY] = yv;
    `sysivar[.iSPECIALFLAG] &= !.lsGRAVITY;
    if(yv != 0.0){
      `sysivar[.iBINDTIME] = 0;
      `sysivar[.iSPECIALFLAG] |= .lsBindCancel;
    }
  }
  public void setAngle(float a)
  {
    `sysfvar[.fANGLE] = a;
    `angleset = true;
  }
  public void setPos<_t>(_t o=, int pt, float x, float y, int facing)
  {
    branch{
    cond facing < 0:
      o.facing = -1;
    else:
      o.facing = 1;
    }
    switch(pt){
    case 0://p1
      if(x != .com.FERR) o.setX(`sysfvar[.fX] + (float)`facing*x);
      if(y != .com.FERR) o.setY(`sysfvar[.fY] + y);
      o.facing *= `facing;
    case 1://p2
      {
        ^`self c = .players.enemyNear(`=, 0);
        if(#c == 0) break;
        if(x != .com.FERR) o.setX(c~sysfvar[.fX] + (float)c~facing*x);
        if(y != .com.FERR) o.setY(c~sysfvar[.fY] + y);
        o.facing *= c~facing;
      }
    case 2, 3://front, back
      if(x != .com.FERR) branch{
      cond (`facing > 0 && pt == 2) || (`facing < 0 && pt == 3):
        o.setX(.com.screenx + (320.0 - x*(pt == 2 ? -1.0 : 1.0))/.com.scale);
      else:
        o.setX(.com.screenx + x*(pt == 2 ? -1.0 : 1.0)/.com.scale);
      }
      if(y != .com.FERR) o.setY(.com.screeny + y/.com.scale);
      o.facing *= `facing;
    case 4://left
      if(x != .com.FERR) o.setX(.com.screenx + x/.com.scale);
      if(y != .com.FERR) o.setY(.com.screeny + y/.com.scale);
    case 5://right
      if(x != .com.FERR) o.setX(.com.screenx + (320.0 + x)/.com.scale);
      if(y != .com.FERR) o.setY(.com.screeny + y/.com.scale);
    }
  }
  public void setAlpha(int trans, int salpha=, int dalpha=)
  {
    switch(trans){
    case 0://default
      salpha = .com.IERR;
      dalpha = .com.IERR;
    case 1://none
      salpha = 255;
      dalpha = 0;
    case 2://add
      salpha = 255;
      dalpha = 255;
    case 3://addalpha
      if(salpha != .com.IERR){
        salpha = .m.max!int?(0)<, .m.min!int?(255)<, salpha;
      }
      if(dalpha != .com.IERR){
        dalpha = .m.max!int?(0)<, .m.min!int?(255)<, dalpha;
      }
      if(salpha == 1 && dalpha == 255) salpha = 0;
    case 4://add1
      salpha = 255;
      dalpha = 128;
    case 5://sub
      salpha = 1;
      dalpha = 255;
    }
  }
  public void setBindToId(`self to=)
  {
    `sysivar[.iSPECIALFLAG] |= .lsBindCancel;
    `sysivar[.iBINDTOID] = to.id;
    if(to.sysivar[.iBINDTOID] == `id){
      to.sysivar[.iSPECIALFLAG] &= !.lsBindCancel;
      to.sysivar[.iBINDTIME] = 0;
    }
    `sysivar[.iBINDFACING] = to.facing*2;
  }
  public void makeDust(float x, float y)
  {
    index i;
    ^&.Explod e = `newExplod(i=);
    if(#e==0)ret;
    e~ani = .fight~getAction(120);
    e~ontop = 1;
    e~sprpriority = -5;
    e~ownpal = 1;
    e~offsetx = x;
    e~offsety = y;
    e~setPos(`=);
    `insertExplod(i, 0);
  }
  public void trPlayerID()
  {
    .c = .players.get(.v.toInt());
  }
  public void trEnemy()
  {
    .c = .players.enemy(`playerno, .v.toInt());
  }
  public void trEnemyNear()
  {
    .c = .players.enemyNear(`=, .v.toInt());
  }
  public void trRoot()
  {
    .c = .chars[`playerno][0];
  }
  public void trParent()
  {
    branch{
    cond `parentindex == .com.IERR:
      .c = .chars[`playerno][0];
    else:
      .c = .chars[`playerno][#`parentindex];
    }
  }
  public void trPartner()
  {
    .c =
      #.chars[`playerno+2 & 3] > 0
      ? .chars[`playerno+2 & 3][0] : .consts.null!`self?();
  }
  public void trHelper()
  {
    int id = .v.toInt();
    if(id != .com.IERR) loop{index i = 1; while; do:
      if(
        .chars[`playerno][i]~helperindex > 0 && !.chars[`playerno][i]~destmp
        && (id <= 0 || id == .chars[`playerno][i]~helperid))
      {
        .c = .chars[`playerno][i];
        ret;
      }
      i++;
    while i < #.chars[`playerno]:
    }
    .c = .consts.null!`self?();
  }
  public void trTarget()
  {
    int id = .v.toInt();
    loop{index i = 0; while; do:
      .c = .players.get(`targets[i]);
      if(#.c > 0 && (id < 0 || .c~stVal.hb.hitid == id)) ret;
      i++;
    while i < #`targets:
    }
    .c = .consts.null!`self?();
  }
  public void trRange(
    &.Var v, bool not, bool minequ, &.Var min, &.Var max, bool maxequ)
  {
    bool b1 = (minequ ? `trGrE(v, min) : `trGr(v, min))$.v.isTrue();
    bool b2 = (maxequ ? `trLsE(v, max) : `trLs(v, max))$.v.isTrue();
    .v.setB((b1&b2) ^ not);
  }
  public void trEqu(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 == i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 == f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trNEqu(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 != i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 != f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trGr(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 > i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 > f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trGrE(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 >= i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 >= f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trLs(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 < i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 < f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trLsE(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 <= i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 <= f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trAnd(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(r.i = i1 & i2);}
    void f(&.Var r=, float f1, float f2){r.setI((int)f1 & (int)f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trXor(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(i1 ^ i2);}
    void f(&.Var r=, float f1, float f2){r.setI((int)f1 ^ (int)f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trOr(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(i1 | i2);}
    void f(&.Var r=, float f1, float f2){r.setI((int)f1 | (int)f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trNot()
  {
    if(.v.isSF()) ret;
    .v.setI(!.v.toInt());
  }
  public void trBoolAnd(&.Var v1, &.Var v2)
  {
    .v.setB(v1.isTrue() && v2.isTrue());
  }
  public void trBoolOr(&.Var v1, &.Var v2)
  {
    .v.setB(v1.isTrue() || v2.isTrue());
  }
  public void trIfelse(&.Var b, &.Var v1, &.Var v2)
  {
    .v = b.isTrue() ? v1 : v2;
  }
  public void trBoolNot()
  {
    .v.setB(!.v.isTrue());
  }
  public void trMinus()
  {
    .v.i *= -1;
    .v.f *= -1.0;
  }
  public void trAbs()
  {
    .v.i = #.v.i;
    .v.f = #.v.f;
  }
  public void trFloor()
  {
    if(.v.typ != .VarTy::Float) ret;
    .v.setI((int).m.floor(.v.f));
  }
  public void trCeil()
  {
    if(.v.typ != .VarTy::Float) ret;
    .v.setI((int).m.ceil(.v.f));
  }
  public void trSin()
  {
    if(.v.isSF()) ret;
    .v.setF(.m.sin(.v.toFloat()));
  }
  public void trCos()
  {
    if(.v.isSF()) ret;
    .v.setF(.m.cos(.v.toFloat()));
  }
  public void trTan()
  {
    if(.v.isSF()) ret;
    .v.setF(.m.tan(.v.toFloat()));
  }
  public void trAsin()
  {
    double x = .v.toFloat();
    if(!.m.inRange!double?(-1.0, 1.0, x)){
      .v.setSF();
      ret;
    }
    .v.setF(.m.asin(x));
  }
  public void trAcos()
  {
    double x = .v.toFloat();
    if(!.m.inRange!double?(-1.0, 1.0, x)){
      .v.setSF();
      ret;
    }
    .v.setF(.m.acos(x));
  }
  public void trAtan()
  {
    if(.v.isSF()) ret;
    .v.setF(.m.atan(.v.toFloat()));
  }
  public void trLog(&.Var v1, &.Var v2)
  {
    double x = v1.toFloat(), y = v2.toFloat();
    if(x < 0.0 || y < 0.0){
      .v.setSF();
      ret;
    }
    .v.setF(.m.log(x, y));
  }
  public void trLn()
  {
    double x = .v.toFloat();
    if(x < 0.0){
      .v.setSF();
      ret;
    }
    .v.setF(.m.ln(x));
  }
  public void trExp()
  {
    if(.v.isSF()) ret;
    .v.setF(.m.exp(.v.toFloat()));
  }
  public void trMul(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(i1 * i2);}
    void f(&.Var r=, float f1, float f2){r.setF(f1 * f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trDiv(&.Var v1, &.Var v2)
  {:<-
    public void i(&.Var r=, int   i1, int   i2)
    {
      branch{
      cond i2 == 0:
        r.setSF();
      else:
        r.setI(i1 / i2);
      }
    }
    void f(&.Var r=, float f1, float f2){r.setF(f1 / f2);}
    `nikou!i, f?(.v=, v1, v2);
    if(!.m.isfinite(.v.toFloat())) .v.setSF();
  }
  public void trMod(&.Var v1, &.Var v2)
  {:<-
    public void i(&.Var r=, int   i1, int   i2)
    {
      branch{
      cond i2 == 0:
        r.setSF();
      else:
        r.setI(i1 % i2);
      }
    }
    void f(&.Var r=, float f1, float f2){
      `trMod:<-i(r=, (int)f1, (int)f2);
    }
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trAdd(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(i1 + i2);}
    void f(&.Var r=, float f1, float f2){r.setF(f1 + f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trSub(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(i1 - i2);}
    void f(&.Var r=, float f1, float f2){r.setF(f1 - f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trPow(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int i1, int i2)
    {
      r.setI((int)((double)i1**(double)i2));
    }
    void f(&.Var r=, float f1, float f2){r.setF(f1**f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public int trId()
  {
    ret `id < 0 ? !`id : `id;
  }
  public void trSetX()
  {
    float x = .v.toFloat();
    if(x == .com.FERR) ret;
    `setX(x);
    `sysivar[.iBINDTIME] = 0;
    `sysivar[.iSPECIALFLAG] |= .lsBindCancel;
  }
  public void trSetY()
  {
    float y = .v.toFloat();
    if(y == .com.FERR) ret;
    `setY(y);
    `sysivar[.iBINDTIME] = 0;
    `sysivar[.iSPECIALFLAG] |= .lsBindCancel;
  }
  public void trAddX()
  {
    float x = .v.toFloat();
    if(x == .com.FERR) ret;
    float tmp = `oldx;
    `setX(`sysfvar[.fX] + (float)`facing*x);
    `oldx = tmp;
  }
  public void trAddY()
  {
    float y = .v.toFloat();
    if(y == .com.FERR) ret;
    `setY(`sysfvar[.fY] + y);
  }
  public void trVelSetX()
  {
    float f = .v.toFloat();
    if(f == .com.FERR) ret;
    `setXV(f);
  }
  public void trVelSetY()
  {
    float f = .v.toFloat();
    if(f == .com.FERR) ret;
    `setYV(f);
  }
  public void trVelAddX()
  {
    float f = .v.toFloat();
    if(f == .com.FERR) ret;
    `sysfvar[.fVX] += f;
  }
  public void trVelAddY()
  {
    float f = .v.toFloat();
    if(f == .com.FERR) ret;
    `sysfvar[.fVY] += f;
  }
  public void trVelMulX()
  {
    float f = .v.toFloat();
    if(f == .com.FERR) ret;
    `sysfvar[.fVX] *= f;
  }
  public void trVelMulY()
  {
    float f = .v.toFloat();
    if(f == .com.FERR) ret;
    `sysfvar[.fVY] *= f;
  }
  public void trAngleSet()
  {
    float f = .v.toFloat();
    if(f == .com.FERR) ret;
    `setAngle(f);
  }
  public void trAnim()
  {
    .v.setI(`animno);
  }
  public void trAnimTime()
  {
    branch{
    cond `animpno < 0 || #`ani == 0 || #`ani~ani.frames == 0:
      .v.setI(0);
    else:
      .v.setI(`ani~ani.animTime());
    }
  }
  public void trAnimElemTime()
  {
    int e = .v.toInt();
    if(e < 1 || #`ani == 0 || e > #`ani~ani.frames){
      .v.setSF();
      ret;
    }
    .v.setI(`ani~ani.animElemTime(e));
  }
  public void trAnimElemNo()
  {
    int tim = .v.toInt();
    if(tim == .com.IERR || #`ani == 0 || #`ani~ani.frames == 0){
      .v.setSF();
      ret;
    }
    .v.setI(`ani~ani.animElemNo(tim));
  }
  public void trChangeAnim(int no)
  {
    if(no == .com.IERR) ret;
    *`ani.self tmp = `getAction(no);
    if(#tmp == 0) ret;
    `ani = tmp;
    `animno = no;
    `animpno = `playerno;
    `sysfvar[.fCLSNXSCALE] = `sysfvar[.fXSCALE];
    `sysfvar[.fCLSNYSCALE] = `sysfvar[.fYSCALE];
    `ani~ani.updateSprite();
  }
  public void trChangeAnim2(int pno, int no)
  {
    if(no == .com.IERR) ret;
    *`ani.self tmp = .chars[pno][0]~getAction(no);
    if(#tmp == 0) ret;
    `ani = tmp;
    `animno = no;
    `animpno = pno;
    `sysfvar[.fCLSNXSCALE] = .chars[pno][0]~sysfvar[.fXSCALE];
    `sysfvar[.fCLSNYSCALE] = .chars[pno][0]~sysfvar[.fYSCALE];
    `ani~ani.sff = `sf;
    `ani~ani.updateSprite();
  }
  public void trAnimExist(int pno)
  {
    if(.v.isSF()) ret;
    .v.setB(#.chars[pno][0]~getAction(.v.toInt()) > 0);
  }
  public void trSelfAnimExist()
  {
    if(.v.isSF()) ret;
    .v.setB(#`getAction(.v.toInt()) > 0);
  }
  public void trPlayerIDExist()
  {
    if(.v.isSF()) ret;
    .v.setB(#.players.get(.v.toInt()) > 0);
  }
  public void trSysIVar()
  {
    int i = .v.toInt();
    if(i < 0){
      .v.setSF();
      ret;
    }
    .v.setI(`sysivar[i]);
  }
  public void trSetSysIVar(&.Var idx, &.Var v)
  {
    int i = idx.toInt();
    if(i < 0){
      .v.setSF();
      ret;
    }
    .v.setI(`sysivar[i] = v.toInt());
  }
  public void trSysFVar()
  {
    int i = .v.toInt();
    if(i < 0){
      .v.setSF();
      ret;
    }
    .v.setF(`sysfvar[i]);
  }
  public void trSetSysFVar(&.Var idx, &.Var v)
  {
    int i = idx.toInt();
    if(i < 0){
      .v.setSF();
      ret;
    }
    .v.setF(`sysfvar[i] = v.toFloat());
  }
  public void trIVar()
  {
    int i = .v.toInt();
    if(i < 0){
      .v.setSF();
      ret;
    }
    .v.setI(`ivar[i]);
  }
  public void trSetIVar(&.Var idx, &.Var v)
  {
    int i = idx.toInt();
    if(i < 0){
      .v.setSF();
      ret;
    }
    .v.setI(`ivar[i] = v.toInt());
  }
  public void trFVar()
  {
    int i = .v.toInt();
    if(i < 0){
      .v.setSF();
      ret;
    }
    .v.setF(`fvar[i]);
  }
  public void trSetFVar(&.Var idx, &.Var v)
  {
    int i = idx.toInt();
    if(i < 0){
      .v.setSF();
      ret;
    }
    .v.setF(`fvar[i] = v.toFloat());
  }
  public bool changeState1(int p, int n)
  {
    if(.changeStateNest >= 2500){
      %char buf .=
        "2500 loops: " .= `name .= ", " .= .s.iToS(`stVal.prevno) .= " -> "
        .= .s.iToS(`stVal.no) .= " -> " .= .s.iToS(n);
      .com.error!.self?(buf);
      ret false;
    }
    if(n < 0) ret false;
    %char buf .= "`s" .= .s.iToS(n) .= '_' .= .s.iToS(p) .= "PSet";
    if(!consteval(`state=, buf)) ret false;
    if(!`cs1tmp) `stVal.prevno = `stVal.no;
    if(`stVal.playerno != `playerno && p != `stVal.playerno) loop{
      index i = #.expdrawlist[`stVal.playerno]-1;
      while;
    do:
      if(
        .explods[`stVal.playerno][.expdrawlist[`stVal.playerno][i]].bindtime
        != 0
        && .explods[`stVal.playerno][.expdrawlist[`stVal.playerno][i]].bindid
        == `id)
      {
        .explods[`stVal.playerno][.expdrawlist[`stVal.playerno][i]].id =
          .com.IERR;
        .delIL(.expdrawlist[`stVal.playerno]=, i);
      }
      i--;
    while i >= 0:
    }
    `stVal.no = n;
    `stVal.playerno = p;
    `stVal.time = 0;
    if(p == `playerno) switch(n){
    case 0:
      if(`minus == -1) `setCtrl(true);
    case 180:
      `sysivar[.iSYSFLAG] &= !.sfWIN;
      `sysivar[.iWAITWIN] = 180;
    }
    `state(::);
    `cs1tmp = true;
    ret true;
  }
  public bool changeState1kai(int p, int no)
  {
    int n = .m.max!int?(0, no);
    if(!`changeState1(p, n)){
      if(.changeStateNest < 2500){
        `trDestroySelf();
        `state = `dummy;
        `stVal.prevno = `stVal.no;
        `stVal.no = n;
        `stVal.playerno = p;
      }
      ret false;
    }
    ret true;
  }
  public void changeState2()
  {
    if(`cs1tmp){
      `state(::);
      `cs1tmp = false;
    }
  }
  public void trChangeState2(int p, int anim, int ctrl)
  {
    int n = .v.toInt();
    if(n == .com.IERR) ret;
    if(anim >= 0) `trChangeAnim(anim);
    if(ctrl >= 0) `setCtrl(ctrl != 0);
    if(`changeState1kai(p, n)){
      if(`minus <= 0) `changeState2();
      if(`minus == 0){
        if(`id >= 0){
          .changeStateNest++;
          `state(::);
          .changeStateNest--;
        }
      }
    }
  }
  public void trChangeState(int anim, int ctrl)
  {
    `trChangeState2(`stVal.playerno, anim, ctrl);
  }
  public void trSelfState(int anim, int ctrl)
  {
    `trChangeState2(`playerno, anim, ctrl);
  }
  public void trSetPersistent(int p=)
  {
    if(.v.isSF()) ret;
    p = .m.min!int?(99, .v.toInt());
    if(p <= 0) p = .consts.int_t::MAX;
    p = .m.max!int?(0, p);
  }
  public void trCommand(^/char name)
  {
    .v.typ = .VarTy::Int;
    .v.i = 1;
    ^&.cmd.Command cl = `cmd.get(name);
    loop{index i = 0; while; do:
      if(cl[i].curbuftime > 0) break;
      i++;
    while i < #cl:
      .v.i = 0;
    }
  }
  public void trP2Life()
  {
    ^`self e = .players.enemyNear(`=, 0);
    .v.setI(e~sysivar[.iLIFE]);
  }
  public void trP2DistX()
  {
    ^`self e = .players.enemyNear(`=, 0);
    .v.setF(.m.floor((float)`facing*(e~sysfvar[.fX] - `sysfvar[.fX])));
  }
  public void trP2DistY()
  {
    ^`self e = .players.enemyNear(`=, 0);
    .v.setF(e~sysfvar[.fY] - `sysfvar[.fY]);
  }
  public void trP2BodyDistX()
  {
    ^`self e = .players.enemyNear(`=, 0);
    .v.setF()<, .m.floor(
      (float)`facing*(
        e~sysfvar[.fX] - `sysfvar[.fX] + (float)e~facing*e~frontw)
      - `frontw);
  }
  public void trP2BodyDistY()
  {
    ^`self e = .players.enemyNear(`=, 0);
    .v.setF((e~sysfvar[.fY] - e~getHeight()) - (`sysfvar[.fY] - `getHeight()));
  }
  public void trRootDistX()
  {
    .v.setF()<, .m.floor(
      (float)`facing*(.chars[`playerno][0]~sysfvar[.fX] - `sysfvar[.fX]));
  }
  public void trRootDistY()
  {
    .v.setF(
      (.chars[`playerno][0]~sysfvar[.fY] - .chars[`playerno][0]~getHeight())
      - (`sysfvar[.fY] - `getHeight()));
  }
  public void trParentDistX()
  {
    `trParent();
    if(#.c == 0){
      .v.setSF();
      ret;
    }
    .v.setF()<, .m.floor((float)`facing*(.c~sysfvar[.fX] - `sysfvar[.fX]));
  }
  public void trParentDistY()
  {
    `trParent();
    if(#.c == 0){
      .v.setSF();
      ret;
    }
    .v.setF(
      (.c~sysfvar[.fY] - .c~getHeight()) - (`sysfvar[.fY] - `getHeight()));
  }
  public void trStateType(|.StTy st)
  {
    .v.typ = .VarTy::Int;
    .v.i = (int)(st == `stVal.typ);
  }
  public void trP2StateType(|.StTy st)
  {
    ^`self e = .players.enemyNear(`=, 0);
    .v.setB(st == e~stVal.typ);
  }
  public void trP2StateNo()
  {
    ^`self e = .players.enemyNear(`=, 0);
    .v.setI(e~stVal.no);
  }
  public void trMoveType(|.MovTy mt)
  {
    .v.setB(mt == `stVal.mov);
  }
  public void trP2MoveType(|.MovTy mt)
  {
    ^`self e = .players.enemyNear(`=, 0);
    .v.setB(mt == e~stVal.mov);
  }
  public void trPName(int no, ^/char name)
  {
    if(no <= 0 || #.chars < no){
      .v.typ = .VarTy::Int;
      .v.i = 0;
      ret;
    }
    int foo;
    branch{
    cond (no & 1) == 1 && no - 1 <= `playerno:
      branch{
      cond no == 1:
        foo = `playerno;
      else:
        foo = ((no - 1) - 2) + (`playerno & 1);
      }
    else:
      foo = (no - 1) ^ (`playerno & 1);
    }
    .v.setI(
      (int)(
        #.chars[foo] > 0 && .s.equ(
          .s.toLower(name), .s.toLower(.chars[foo][0]~name))));
  }
  public void trFrontEdgeDist()
  {
    .v.setF(
      (`facing > 0 ? .com.xmax - `sysfvar[.fX] : `sysfvar[.fX] - .com.xmin));
  }
  public void trFrontEdgeBodyDist()
  {
    .v.setF(
      (`facing > 0 ? .com.xmax - `sysfvar[.fX] : `sysfvar[.fX] - .com.xmin)
      - `fedge);
  }
  public void trBackEdgeDist()
  {
    .v.setF(
      (`facing < 0 ? .com.xmax - `sysfvar[.fX] : `sysfvar[.fX] - .com.xmin));
  }
  public void trBackEdgeBodyDist()
  {
    .v.setF(
      (`facing < 0 ? .com.xmax - `sysfvar[.fX] : `sysfvar[.fX] - .com.xmin)
      - `bedge);
  }
  public void trIsHelper()
  {
    int id = .v.toInt();
    if(id == .com.IERR){
      .v.setSF();
      ret;
    }
    .v.setB(`helperindex != 0 && (id <= 0 || `helperid == id));
  }
  public void trIsPlayer()
  {
    .v.setB(`player);
  }
  public void trActive()
  {
    .v.setB(`isActive());
  }
  public void trTeamMode(|.com.TeamMode tm)
  {
    .v.setB(.com.tmode[`playerno&1] == (int)tm);
  }
  public void trNewHelper(^`self c=)
  {
    c = .create(`playerno);
    if(#c == 0) ret;
    c~id ^= -1;
    c~helperid = 0;
    c~copyParent(`=);
    `addChild(c~helperindex);
    c~parentindex = `helperindex;
  }
  void helproSetPos<_t>(_t obj=, int pt, float x, float y, int facing)
  {
    switch(pt){
    case 2, 3://front, back
      if(facing < 0) obj.facing *= -1;
      branch{
      cond (`facing > 0 && pt == 2) || (`facing < 0 && pt == 3):
        obj.setX(.com.screenx + 320.0/.com.scale - x*(pt == 2 ? -1.0 : 1.0));
      else:
        obj.setX(.com.screenx + x*(pt == 2 ? -1.0 : 1.0));
      }
      obj.setY(y);
      obj.facing *= `facing;
    case 4://left
      if(facing < 0) obj.facing *= -1;
      obj.setX(.com.screenx + x);
      obj.setY(y);
    case 5://right
      if(facing < 0) obj.facing *= -1;
      obj.setX(.com.screenx + 320.0/.com.scale + x);
      obj.setY(y);
    default:
      `setPos!_t?(obj=, pt, x, y, facing);
    }
  }
  public void trHelperInit(
    `self h=, int st, int pt, float x, float y, int facing, int ownpal)
  {
    `helproSetPos!h.self?(h=, pt, x, y, facing);
    if(x == .com.FERR) h.setX(0.0);
    if(y == .com.FERR) h.sysfvar[.fY] = 0.0;
    h.sysfvar[.fVX] = 0.0;
    h.sysfvar[.fVY] = 0.0;
    if(ownpal != 0) h.palfx.new(1);
    .v.setI(st);
    h.trChangeState2(`stVal.playerno, -1, -1);
  }
  public void trProjInit(&.Projectile p=, int pt, float x, float y)
  {
    `helproSetPos!p.self?(p=, pt, x, y, 1);
    if(x == .com.FERR) p.x = 0.0;
    if(y == .com.FERR) p.y = 0.0;
    p.ani = `getAction(p.anim);
    if(`sysivar[.iPROJ_DOSCALE] != 0){
      p.scalex *= `sysfvar[.fXSCALE];
      p.scaley *= `sysfvar[.fYSCALE];
    }
    p.playerno = `playerno;
    if(p.velocityx < 0.0){
      p.facing *= -1;
      p.velocityx *= -1.0;
      p.accelx *= -1.0;
    }
  }
  public void trDestroySelf()
  {
    if(`helperindex <= 0) ret;
    `destmp = true;
  }
  public void trTargetBind(int time, int id, float x, float y)
  {
    if(time == .com.IERR || id == .com.IERR) ret;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0 && (id < 0 || c~stVal.hb.hitid == id)){
        c~setBindToId(`=);
        c~sysivar[.iBINDTIME] = time;
        c~sysivar[.iBINDFACING] = 0;
        c~sysfvar[.fBINDPOSX] = x;
        c~sysfvar[.fBINDPOSY] = y;
      }
      i++;
    while i < #`targets:
    }
  }
  public void trBindToTarget(int hmf)
  {
    if(`sysivar[.iBINDTIME] == 0) ret;
    ^`self c = .players.get(`sysivar[.iBINDTOID]);
    if(#c == 0) ret;
    switch(hmf){
    case 1:
      `sysfvar[.fBINDPOSX] += (float)c~sysivar[.iMID_POSX];
      `sysfvar[.fBINDPOSY] += (float)c~sysivar[.iMID_POSY];
    case 2:
      `sysfvar[.fBINDPOSX] += (float)c~sysivar[.iHEAD_POSX];
      `sysfvar[.fBINDPOSY] += (float)c~sysivar[.iHEAD_POSY];
    }
    `bind();
  }
  public void setBindFacing(int f)
  {
    if(f == .com.IERR || f== 0) ret;
    `sysivar[.iBINDFACING] = f < 0 ? -1 : 1;
  }
  public void trTargetDrop(int id, int keepone)
  {
    if(id == .com.IERR) ret;
    %int tmp;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0) branch{
      cond id < 0 || c~stVal.hb.hitid == id:
        tmp .= `targets[i];
      else:
        c~byBindClear();
        c~stVal.hb.dropByid(`id);
      }
      i++;
    while i < #`targets:
    }
    branch{
    cond keepone != 0 && #tmp > 0:
      `targets.new(0);
      loop{
        index i = 0, r = .m.rand(0, #tmp-1);
        while;
      do:
        branch{
        cond i == r:
          `targets .= tmp[i];
        else:
          c = .players.get(tmp[i]);
          c~byBindClear();
          c~stVal.hb.dropByid(`id);
        }
        i++;
      while i < #tmp:
      }
    else:
      `targets = tmp;
    }
  }
  public void trTargetFacing(int fasing, int id)
  {
    if(fasing == 0) ret;
    int f = `facing;
    if(fasing < 0) f *= -1;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0 && (id < 0 || c~stVal.hb.hitid == id)) c~setFacing(f);
      i++;
    while i < #`targets:
    }
  }
  public void trTargetState(int pno, int state, int id)
  {
    if(state < 0 || id == .com.IERR) ret;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0 && (id < 0 || c~stVal.hb.hitid == id)){
        c~setCtrl(false);
        c~changeState1kai(pno, state);
      }
      i++;
    while i < #`targets:
    }
  }
  public void trTargetVelSetX(int id, float vx)
  {
    if(vx == .com.FERR || id == .com.IERR) ret;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0 && (id < 0 || c~stVal.hb.hitid == id)){
        c~setXV(vx);
      }
      i++;
    while i < #`targets:
    }
  }
  public void trTargetVelSetY(int id, float vy)
  {
    if(vy == .com.FERR || id == .com.IERR) ret;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0 && (id < 0 || c~stVal.hb.hitid == id)){
        c~setYV(vy);
      }
      i++;
    while i < #`targets:
    }
  }
  public void trTargetVelAddX(int id, float vx)
  {
    if(vx == .com.FERR || id == .com.IERR) ret;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0 && (id < 0 || c~stVal.hb.hitid == id)){
        c~sysfvar[.fVX] += vx;
      }
      i++;
    while i < #`targets:
    }
  }
  public void trTargetVelAddY(int id, float vy)
  {
    if(vy == .com.FERR || id == .com.IERR) ret;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0 && (id < 0 || c~stVal.hb.hitid == id)){
        c~sysfvar[.fVY] += vy;
      }
      i++;
    while i < #`targets:
    }
  }
  public void trTargetLifeAdd(int va, int id, bool kill, bool absolute)
  {
    if(va == .com.IERR || id == .com.IERR) ret;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0 && (id < 0 || c~stVal.hb.hitid == id)){
        if(
          c~addLife(
            -c~getDamage(-va, kill, absolute, `attackmul), true, true)) branch
        {
        cond (`playerno&1) == (c~playerno&1):
          if(c~helperindex == 0) branch{
          cond `playerno == c~playerno:
            .winty[(c~playerno+1)&1] = .fgt.WinTy::Suicide;
          else:
            .winty[(c~playerno+1)&1] = .fgt.WinTy::Teammate;
          }
        else:
          c~setEnemyWinty();
        }
      }
      i++;
    while i < #`targets:
    }
  }
  public void trTargetPowerAdd(int pw, int id)
  {
    if(pw == .com.IERR || id == .com.IERR) ret;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0 && (id < 0 || c~stVal.hb.hitid == id)) c~addPower(pw);
      i++;
    while i < #`targets:
    }
  }
  public void trHitAdd(int h)
  {
    if(h == .com.IERR) ret;
    `sysivar[.iHITCOUNT] += h;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0) c~getcombo += h;
      i++;
    while i < #`targets:
    }
  }
  public void trNumEnemy()
  {
    .v.setI(.players.numEnemy(`playerno));
  }
  public void trNumPartner()
  {
    .v.setI(#.chars[`playerno+2 & 3]);
  }
  public void trHitXvel(int f)
  {
    .v.setF(`stVal.hb.xvel * (float)f);
  }
  public void trFallXvel(int f)
  {
    if(`stVal.hb.fall.xvelocity == .com.FERR){
      .v.setSF();
      ret;
    }
    .v.setF(`stVal.hb.fall.xvelocity * (float)f);
  }
  public void trHitFallSet(int f, float vx, float vy)
  {
    if(`stVal.mov != .MovTy::H) ret;
    if(f >= 0) `stVal.hb.fallf = (int)(f != 0);
    if(vx != .com.FERR) `stVal.hb.fall.xvelocity = vx;
    if(vy != .com.FERR) `stVal.hb.fall.yvelocity = vy;
  }
  public void trHitFallVel()
  {
    if(`stVal.mov != .MovTy::H) ret;
    if(`stVal.hb.fall.xvelocity != .com.FERR){
      `setXV(`stVal.hb.fall.xvelocity * (float)`facing);
    }
    `setYV(`stVal.hb.fall.yvelocity);
  }
  public void trHitFall()
  {
    .v.typ = .VarTy::Int;
    .v.i = (int)(`stVal.hb.fallf != 0);
  }
  public void trHitFallDamage()
  {
    if(`stVal.mov != .MovTy::H) ret;
    if(`addLife(-`stVal.hb.fall.damage, `stVal.hb.fall.kill != 0, false)){
      `setEnemyWinty();
    }
  }
  public void trHitVelSetX()
  {
    if(`stVal.mov != .MovTy::H) ret;
    `setXV(`stVal.hb.xvel * (float)`facing);
  }
  public void trHitVelSetY()
  {
    if(`stVal.mov != .MovTy::H) ret;
    `setYV(`stVal.hb.yvel);
  }
  public void trHitVelX()
  {
    .v.setF(`stVal.mov != .MovTy::H ? -`stVal.hb.xvel * (float)`facing : 0.0);
  }
  public void trHitVelY()
  {
    .v.setF(`stVal.mov != .MovTy::H ? -`stVal.hb.yvel : 0.0);
  }
  public void trProjTime(|.ProjContact pct)
  {
    int id = .v.toInt();
    if(id == .com.IERR){
      .v.setSF();
      ret;
    }
    .v.typ = .VarTy::Int;
    branch{
    cond id < 0:
      .v.i = 0;
    else:
      .v.i = -1;
      loop{index i = 0; while; do:
        if(.projs[`playerno][i].id >= 0
          && (id == 0 || .projs[`playerno][i].id == id)
          && .projs[`playerno][i].pctyp == pct
          && .projs[`playerno][i].pctime != 0
          && (.v.i <= 0 || .v.i > #.projs[`playerno][i].pctime))
        {
          .v.i = #.projs[`playerno][i].pctime;
        }
        i++;
      while i < #.projs[`playerno]:
      }
    }
  }
  public void trProjContactTime()
  {
    int id = .v.toInt();
    if(id == .com.IERR){
      .v.setSF();
      ret;
    }
    .v.typ = .VarTy::Int;
    branch{
    cond id < 0:
      .v.i = 0;
    else:
      .v.i = -1;
      loop{index i = 0; while; do:
        if(.projs[`playerno][i].id >= 0
          && (id == 0 || .projs[`playerno][i].id == id)
          && .projs[`playerno][i].pctime != 0
          && (.v.i <= 0 || .v.i > #.projs[`playerno][i].pctime))
        {
          .v.i = #.projs[`playerno][i].pctime;
        }
        i++;
      while i < #.projs[`playerno]:
      }
    }
  }
  public void trHitDefAttr(int flg)
  {
    const int mask = (int).AtTy::NA - 1;
    int attr = `stVal.hit.attr & (int)0x7fffffff;
    .v.setI(
      (int)(
        `stVal.mov == .MovTy::A
        && (mask & attr & flg) != 0  && (!mask & attr & flg) != 0));
  }
  public void trNumHelper()
  {
    if(.v.isSF()) ret;
    int id = .v.toInt();
    .v.typ = .VarTy::Int;
    .v.i = 0;
    loop{index i = 1; while; do:
      if(
        .chars[`playerno][i]~helperindex > 0 && !.chars[`playerno][i]~destmp
        && (id <= 0 || id == .chars[`playerno][i]~helperid)) .v.i++;
      i++;
    while i < #.chars[`playerno]:
    }
  }
  public bool matchExplodId(index i, int id)
  {
    ret
      .explods[`playerno][i].id >= 0 && (
        .explods[`playerno][i].player == `id
        && (id <= 0 || .explods[`playerno][i].id == id));
  }
  public void trExplodBindTime(int id, int bt)
  {
    if(bt == .com.IERR || id == .com.IERR) ret;
    loop{index i = 0; while; do:
      if(`matchExplodId(i, id)){
        .explods[`playerno][i].bindtime = bt + (bt > 0 ? 1 : 0);
      }
      i++;
    while i < #.explods[`playerno]:
    }
  }
  public void trRemoveExplod(int id)
  {
    if(id == .com.IERR) ret;
    loop{index i = #.expdrawlist[`playerno]-1; while; do:
      if(`matchExplodId(.expdrawlist[`playerno][i], id)){
        .explods[`playerno][.expdrawlist[`playerno][i]].id = .com.IERR;
        .delIL(.expdrawlist[`playerno]=, i);
      }
      i--;
    while i >= 0:
    }
  }
  public void trNumExplod()
  {
    int id = .v.toInt();
    if(id == .com.IERR){
      .v.setSF();
      ret;
    }
    .v.typ = .VarTy::Int;
    .v.i = 0;
    loop{index i = 0; while; do:
      if(`matchExplodId(i, id)) .v.i++;
      i++;
    while i < #.explods[`playerno]:
    }
  }
  public void trNumTarget()
  {
    int id = .v.toInt();
    if(id == .com.IERR){
      .v.setSF();
      ret;
    }
    .v.typ = .VarTy::Int;
    .v.i = 0;
    loop{index i = 0; while; do:
      if(`targets[i] >= 0) branch{
      cond id < 0:
        .v.i++;
      else:
        {
          ^`self t = .players.get(`targets[i]);
          if(#t == 0) break;
          if(t~stVal.hb.hitid == id) .v.i++;
        } 
      }
      i++;
    while i < #`targets:
    }
  }
  public void trNumProjID()
  {
    int id = .v.toInt();
    if(id == .com.IERR){
      .v.setSF();
      ret;
    }
    if(`helperindex != 0){
      .v.setI(0);
      ret;
    }
    int d = .m.max!int?(0, id);
    .v.typ = .VarTy::Int;
    .v.i = 0;
    loop{index i = 0; while; do:
      if(.projs[`playerno][i].id == d && .projs[`playerno][i].hits > 0) .v.i++;
      i++;
    while i < #.projs[`playerno]:
    }
  }
  public void trNumProj()
  {
    .v.typ = .VarTy::Int;
    .v.i = 0;
    loop{index i = 0; while; do:
      if(.projs[`playerno][i].id >= 0 && .projs[`playerno][i].hits > 0) .v.i++;
      i++;
    while i < #.projs[`playerno]:
    }
  }
  public void trHitPauseTime()
  {
    .v.setI(.m.max!int?(0, `sysivar[.iHITPAUSETIME]));
  }
  public void trInGuardDist()
  {
    .v.setB(`inguarddist);
  }
  public void trHitOver()
  {
    .v.setB(`stVal.hb.hittime <= 0);
  }
  public void trHitShakeOver()
  {
    .v.setI((int)(`stVal.hb.hitshaketime <= 0));
  }
  public void trCanRecover()
  {
    .v.setI(
      (int)(
        `isFall() && `stVal.hb.fall.recover != 0
        && `stVal.hb.fall.recovertime <= 0));
  }
  public void trMoveContact()
  {
    .v.typ = .VarTy::Int;
    .v.i = #`stVal.mctime;
  }
  public void trMoveReversed()
  {
    .v.typ = .VarTy::Int;
    .v.i = 0;
    if(`stVal.mctyp == .MoveContact::Reversed){
      .v.i = #`stVal.mctime;
    }
  }
  public void trMoveHit()
  {
    .v.typ = .VarTy::Int;
    .v.i = 0;
    if(`stVal.mctyp == .MoveContact::Hit){
      .v.i = #`stVal.mctime;
    }
  }
  public void trMoveGuarded()
  {
    .v.typ = .VarTy::Int;
    .v.i = 0;
    if(`stVal.mctyp == .MoveContact::Guarded){
      .v.i = #`stVal.mctime;
    }
  }
  public void trMoveHitReset()
  {
    `stVal.mctime = 0;
  }
  public void trPalNo()
  {
    .v.setI(`palno);
  }
  public void trMatchOver()
  {
    .v.setB(.com.p1wins >= .com.p1mw || .com.p2wins >= .com.p2mw);
  }
  public void trMatchNo()
  {////////////////////////////////////////////////////////////////////////////
    .v.setI(1);
  }
  public void trRoundNo()
  {
    .v.setI(.com.round);
  }
  public void trRoundState()
  {
    .v.setI(.roundState());
  }
  public void trRoundsExisted()
  {
    .v.setI(.com.rexisted[`playerno&1]);
  }
  public bool isWin()
  {
    ret .com.win >= 0 && (`playerno&1) == .com.win;
  }
  public bool isLose()
  {
    ret .com.win >= 0 && (`playerno+1&1) == .com.win;
  }
  public void trWin()
  {
    .v.setB(`isWin());
  }
  public void trWinKO()
  {
    .v.setB(`isWin() && .ko == .fgt.KOTy::KO);
  }
  public void trWinTime()
  {
    .v.setB(`isWin() && .ko == .fgt.KOTy::TO);
  }
  public void trWinPerfect()
  {
    .v.setI(
      (int)(
        `isWin()
        && .chars[`playerno][0]~sysivar[.iLIFE]
        == .chars[`playerno][0]~sysivar[.iLIFEMAX]));
  }
  public void trLose()
  {
    .v.setB(`isLose());
  }
  public void trLoseKO()
  {
    .v.setB(`isLose() && .ko == .fgt.KOTy::KO);
  }
  public void trLoseTime()
  {
    .v.setB(`isLose() && .ko == .fgt.KOTy::TO);
  }
  public void trDrawGame()
  {
    .v.setB(.roundState() >= 3 && .com.win < 0);
  }
  public void trRemapPal(int sg, int sn, int dg, int dn)
  {
    if(sg < 0 || sn < 0 || dg < 0 || dn < 0) ret;
    ^index si = `sf~palList.palTable.get((uint)sg << 0d16 | (ushort)sn);
    ^index di = `sf~palList.palTable.get((uint)dg << 0d16 | (ushort)dn);
    if(#si == 0) ret;
    if(#di == 0) di = si;
    `sf~palList.remap(si<>, di<>);
    if(sg == 1 && sn == 1 && `sf~head.ver0 == 0d1){
      ^&.sff.Sprite spr = `sf~getSprite(0, 0);
      if(#spr > 0) `sf~palList.remap(spr~palidx, di<>);
      spr = `sf~getSprite(9000, 0);
      if(#spr > 0) `sf~palList.remap(spr~palidx, di<>);
    }
  }
}

public void Explod::update()
{
  ^&.Char c;
  if(.com.tickNextFrame()){
    if(`removeongethit != 0){
      if(#c == 0) c = .players.get(`player);
      if(#c == 0 || c~stVal.mov == .MovTy::H){
        `id = .com.IERR;
        ret;
      }
    }
    if(
      `removetime == 0
      || (`removetime <= -2 && (#`ani == 0 || `ani~ani.loopend)))
    {
      `id = .com.IERR;
      ret;
    }
  }
  {
    float scl = 1.0, cscl = .com.scale, xofs = 0.0, yofs = 0.0;
    bool p = false;
    branch{
    cond .super > 0:
      p = `supermovetime == 0;
    cond .pause > 0:
      p = `pausemovetime == 0;
    }
    bool act = !p && `ignorehitpause != 0;
    if(!p && !act){
      if(#c == 0) c = .players.get(`player);
      act = #c == 0 || c~acttmp%2 != -1;
    }
    if(act && `bindtime == 0){
      float sp = .m.min!float?(1.0, .com.turbo);
      `x += `velocityx*(float)(`facing*`relativef) * sp;
      `y += `velocityy * sp;
      if(.com.tickNextFrame()){
        `velocityx += `accelx;
        `velocityy += `accely;
      }
    }
    if(.com.tickNextFrame()){
      if(#`ani > 0) branch{
      cond act:
        `ani~ani.action();
      else:
        `ani~ani.updateSprite();
      }
      if(p) break;
      branch{
      cond .super > 0:
        if(`supermovetime > 0) `supermovetime--;
      cond .pause > 0:
        if(`pausemovetime > 0) `pausemovetime--;
      }
      if(!act) break;
      if(`removetime > 0) `removetime--;
      if(`bindtime > 0) `bindtime--;
    }
  break:
    if(`bindtime != 0) branch{
    cond `postype >= 4:
      cscl = 1.0;
      `x = .com.camerax + `offsetx + (`postype == 4 ? -160.0 : 160.0);
      xofs = -.com.xoffset;
      `y = .com.cameray + `offsety - .com.zoffset;
      yofs = -.com.yoffset;
    else:
      {
        ^&.Char bc = .players.get(`bindid);
        if(#bc == 0){
          `bindtime = 0;
          break, break;
        }
        if(`offsetx != .com.FERR) `setX(bc~sysfvar[.fX] + `offsetx);
        if(`offsety != .com.FERR) `setY(bc~sysfvar[.fY] + `offsety);
      }
    }
    branch{
      type _t = $void(.anims.self=);
      ~_t aal = [_t(a=){
        if(`ownpal == 0 && #c == 0){
          if(#(c = .players.get(`player)) == 0) ret;
        }
        .addAnimList(
          a=, `ani, `sprpriority, `x+xofs, `y+yofs, cscl,
          (float)`facing*`scalex*scl, (float)`vfacing*`scaley*scl,
          0.0, false, 1.0, 1.0, `alphas < 0 ? -1 : `alphas,
          `alphad, 256 >> (int)(
            .super > 0 && .superdarken != 0
            && (#c > 0 || #(c = .players.get(`player)) > 0)
            && c~playerno != .superplayer),
          `ownpal == 0 ? c~getPalfx() : .consts.null!&.com.PalFX?(),
          `shadowr<<16 | (`shadowg&255)<<8 | (`shadowb&255), 0.0);
      }];
    cond `ontop != 0:
      aal(:.topanims=:);
    else:
      aal(:.anims=:);
    }
  }
}
public void Explod::setPos(&.Char c=)
{
  switch(`postype){
  case 0:
    `bindid = c.id;
    `facing = c.facing*`relativef;
    `offsetx *= (float)c.facing;
    if(`offsetx != .com.FERR) `setX(c.sysfvar[.fX] + `offsetx);
    if(`offsety != .com.FERR) `setY(c.sysfvar[.fY] + `offsety);
    break;
  case 1:
    {
      ^&.Char bc = .players.enemyNear(c=, 0);
      if(#bc == 0) break;
      `bindid = bc~id;
      `facing *= bc~facing*`relativef;
      `offsetx *= (float)bc~facing;
      if(`offsetx != .com.FERR) `setX(bc~sysfvar[.fX] + `offsetx);
      if(`offsety != .com.FERR) `setY(bc~sysfvar[.fY] + `offsety);
    }
    break;
  case 2, 3:
    branch{
    cond (c.facing > 0 && `postype == 2) || (c.facing < 0 && `postype == 3):
      `postype = 5;
      if(`offsetx != .com.FERR) `offsetx *= -1.0;
    else:
      if(`postype == 2){
        `postype = 4;
        `relativef *= c.facing;
        c.setPos!`self?(`=, `postype, `offsetx, `offsety, c.facing);
        break, break;
      }
      `postype = 4;
    comm:
      c.setPos!`self?(`=, `postype, `offsetx, `offsety, `relativef*c.facing);
    }
  default:
    c.setPos!`self?(`=, `postype, `offsetx, `offsety, `relativef);
  }
}
public void Explod::modify(&.Char c=, &.ModifyExplod mod=, index i)
{
  if(!c.matchExplodId(i, mod.id)) ret;
  if(mod.bindtime != .com.IERR) `bindtime = mod.bindtime;
  if(mod.scalex != .com.FERR) `scalex = mod.scalex;
  if(mod.scaley != .com.FERR) `scaley = mod.scaley;
  if(mod.removeongethit != .com.IERR) `removeongethit = mod.removeongethit;
  if(mod.removetime != .com.IERR) `removetime = mod.removetime;
  if(mod.velocityx != .com.FERR) `velocityx = mod.velocityx;
  if(mod.velocityy != .com.FERR) `velocityy = mod.velocityy;
  if(mod.accelx != .com.FERR) `accelx = mod.accelx;
  if(mod.accely != .com.FERR) `accely = mod.accely;
  if(mod.sprpriority != .com.IERR) `sprpriority = mod.sprpriority;
  if(mod.postype != .com.IERR) `postype = mod.postype;
  if(mod.offsetx != .com.FERR) `offsetx = mod.offsetx;
  if(mod.offsety != .com.FERR) `offsety = mod.offsety;
  if(mod.relativef != .com.IERR) `relativef = mod.relativef;
  if(mod.x != .com.FERR) `x = mod.x;
  if(mod.y != .com.FERR) `y = mod.y;
  if(mod.facing != .com.IERR) `setFacing(mod.facing);
  if(mod.vfacing != .com.IERR) `vfacing = mod.vfacing;
  if(mod.shadowr != .com.IERR) `shadowr = mod.shadowr;
  if(mod.shadowg != .com.IERR) `shadowg = mod.shadowg;
  if(mod.shadowb != .com.IERR) `shadowb = mod.shadowb;
  if(mod.ontop != .com.IERR) `ontop = mod.ontop;
  if(mod.alphas != .com.IERR) `alphas = mod.alphas;
  if(mod.alphad != .com.IERR) `alphad = mod.alphad;
  if(mod.supermovetime != .com.IERR) `supermovetime = mod.supermovetime;
  if(mod.pausemovetime != .com.IERR) `pausemovetime = mod.pausemovetime;
  if(mod.postype >= 0) `setPos(c=);
  if(`ontop != 0) `sprpriority = 0;
}



public ^&Char PlayerList!&Char?::get(int id)
{
  if(id < 0) ret .consts.null!`_t?();
  loop{index i = 0; while; do:
    if(.playerid[i].n == id) ret .chars[.playerid[i].pn][.playerid[i].hi];
    i++;
  while i < #.playerid:
  }
  loop{
    *`top.self p = `top;
    while;
  do:
    if(p~c~id == id || !p~c~id == id){
      .playerid.new[-1].n = id;
      .playerid[-1].pn = p~c~playerno;
      .playerid[-1].hi = p~c~helperindex;
      ret p~c;
    }
    p = p~next;
  while #p > 0:
  }
  ret .consts.null!`_t?();
}
public ^&Char PlayerList!&Char?::enemy(int pno, int n)
{
  int cnt = 0;
  loop{
    *`top.self p = `top;
    while;
  do:
    if((p~c~playerno&1) != (pno&1) && p~c~player && n == cnt++) ret p~c;
    p = p~next;
  while #p > 0:
  }
  ret .consts.null!`_t?();
}
public ^&Char PlayerList!&Char?::enemyNear(&.Char pyr=, int n)
{
  if(n < 0) ret .consts.null!pyr.self?();
  loop{index i = 0; while; do:
    if(pyr.enemyn[i].n == n) ret .chars[pyr.enemyn[i].pn][pyr.enemyn[i].hi];
    i++;
  while i < #pyr.enemyn:
  }
  ^^pyr.self en.new(n+1);
  void add(^`pyr.self e, index rng)
  {
    bool foo<_t>(_t a, _t b, int id1, int id2)
    {
      ret a <= b && (a < b || id1 < id2);
    }
    loop{index i = rng; while; do:
      if(#`en[i] == 0){
        `en[i] = e;
        ret;
      }
      if(
        (e~sysivar[.iLIFE] > 0 && `en[i]~sysivar[.iLIFE] <= 0)
        || (
          e~sysivar[.iLIFE] > 0
          ? `en[i]~sysivar[.iLIFE] > 0
          && foo!float?(
            #(e~sysfvar[.fX] - `pyr.sysfvar[.fX]),
            #(`en[i]~sysfvar[.fX] - `pyr.sysfvar[.fX]), e~id, `en[i]~id)
          : `en[i]~sysivar[.iLIFE] <= 0
          && foo!int?(
            `en[i]~sysivar[.iRECOVERTIME], e~sysivar[.iRECOVERTIME],
            e~id, `en[i]~id)))
      {
        self(`en[i], i+1);
        `en[i] = e;
        ret;
      }
      i++;
    while i < #`en:
    }
  }
  loop{
    *`top.self p = `top;
    while;
  do:
    if((p~c~playerno&1) != (pyr.playerno&1) && p~c~player) add(p~c, 0);
    p = p~next;
  while #p > 0:
  }
  if(#en[-1] == 0) ret .consts.null!&.Char?();
  pyr.enemyn.new[-1].n = n;
  pyr.enemyn[-1].pn = en[-1]~playerno;
  pyr.enemyn[-1].hi = en[-1]~helperindex;
  ret en[-1];
}
public int PlayerList!&Char?::numEnemy(int pno)
{
  if(.numenemy[pno] >= 0) ret .numenemy[pno];
  int cnt = 0;
  loop{
    *`top.self p = `top;
    while;
  do:
    if((p~c~playerno&1) != (pno&1) && p~c~player) cnt++;
    p = p~next;
  while #p > 0:
  }
  ret .numenemy[pno] = cnt;
}
public void PlayerList!&Char?::add(^&.Char c)
{
  .playerid.new(0);
  .resetNumenemy();
  if(#`top == 0){
    `top.new(1);
    `top~c = c;
    `end = `top;
    ret;
  }
  `end~next.new(1);
  `end = `end~next;
  `end~c = c;
}
public void PlayerList!&Char?::destroy(int id)
{
  if(#`top == 0) ret;
  .playerid.new(0);
  .resetNumenemy();
  if(`top~c~id == id){
    `top = `top~next;
    if(#`top == 0) `end.new(0);
    ret;
  }
  *`top.self p = `top;
  loop{while; do:
    if(p~next~c~id == id){
      p~next = p~next~next;
      if(#p~next == 0) `end = p;
      break, break;
    }
    p = p~next;
  while #p~next > 0:
  }
}
public void PlayerList!&Char?::action(
  float x, float tension, float cvx=,
  float highest=, float lowest=, float leftest=, float rightest=)
{
  bool foo = true;
  loop{
    *`top.self p = `top;
    while;
  do:
    if(p~c~id < 0){
      p~c~id ^= -1;
      if(foo){
        .commandUpdate();
        foo = false;
      }
    }
    branch{
    cond #p~c~stVal.hb.byid == 0:
      p~c~action();
    else:
      p~c~targetAction();
    }
  continue:
    p = p~next;
  while #p > 0:
  }
  if(foo) .commandUpdate();
  .update(tension, cvx=, highest=, lowest=, leftest=, rightest=);
  .com.gametime++;
  .rootAction();
}
public void PlayerList!&Char?::move(
  float highest=, float lowest=, float leftest=, float rightest=)
{
  loop{
    *`top.self p = `top;
    while;
  do:
    if(p~c~id < 0) continue;
    p~c~move(highest=, lowest=, leftest=, rightest=);
  continue:
    p = p~next;
  while #p > 0:
  }
}
public void PlayerList!&Char?::update(float tension, float cvx=)
{
  loop{
    *`top.self p = `top;
    while;
  do:
    if(p~c~id < 0) continue;
    cvx += p~c~update(tension);
  continue:
    p = p~next;
  while #p > 0:
  }
}
public void PlayerList!&Char?::clsn(&.Char pyr=)
{
  float pxmi, pxma;
  branch{
  cond pyr.facing > 0:
    pxmi = .com.xmin+pyr.bedge; pxma = .com.xmax-pyr.fedge;
  else:
    pxmi = .com.xmin+pyr.fedge; pxma = .com.xmax-pyr.bedge;
  }
  bool foo(
    int hitting, `pyr.self by=, &.Hitdef hit=, float y, int pro, int hits)
  {
    ^&.Explod expreset(&.Char p1=, &.Char p2=, float y)
    {
      float x = (p2.sysfvar[.fX] - p1.sysfvar[.fX]) * (float)p1.facing;
      index tmp;
      ^&.Explod e = `by.newExplod(tmp=);
      if(#e == 0) ret e;
      e~postype = 0;
      e~offsetx = x + `hit.sparkx * (`by.id == p1.id ? 1.0 : -1.0);
      e~offsety =
        y + `hit.sparky + (`by.id == p1.id ? 0.0 : p1.stVal.hit.sparky);
      e~relativef = 1;
      e~player = `by.id;
      e~scalex = e~scaley = 1.0;
      e~ontop = 1;
      e~sprpriority = 5;
      e~ownpal = 1;
      e~supermovetime = e~pausemovetime = -1;
      p1.setPos!e<>.self?(e<>=, e~postype, e~offsetx, e~offsety, e~relativef);
      `by.insertExplod(tmp, 0);
      ret e;
    }
    ^&.snd.Sound sou;
    branch{
    cond #hitting == 1:
      branch{
        if(hit.sparkno == .com.IERR) break;
        ^&.Explod e = 
          hit.reversal_attr > 0
          ? expreset(`pyr=, by=, y) : expreset(by=, `pyr=, y);
        if(#e == 0) break;
      cond hit.sparkno < 0:
        e~ani = .fight~getAction(!hit.sparkno);
      else:
        e~ani = by.getAction(hit.sparkno);
      }
    else:
      branch{
        if(hit.guard_sparkno == .com.IERR) break;
        ^&.Explod e =
          hit.reversal_attr > 0
          ? expreset(`pyr=, by=, y) : expreset(by=, `pyr=, y);
        if(#e == 0) break;
      cond hit.guard_sparkno < 0:
        e~ani = .fight~getAction(!hit.guard_sparkno);
      else:
        e~ani = by.getAction(hit.guard_sparkno);
      }
    }
    if(pro == 0) by.sprpriority = hit.p1sprpriority;
    `pyr.sprpriority = hit.p2sprpriority;
    if(hit.forcestand != 0 && `pyr.stVal.typ == .StTy::C){
      `pyr.stVal.typ = .StTy::S;
    }
    bool rtn = false, damageable = false, ho = false;
    int p2s = 0;
    if(
      !`pyr.cs1tmp || `pyr.stVal.playerno == by.playerno
      || !`pyr.ls(.lsGETHIT))
    {
      rtn = damageable = true;
      if(hitting > 0){
        if(!`pyr.ls(.lsGETHIT)) `pyr.cs1tmp = false;
        `pyr.sysivar[.iSPECIALFLAG] |= .lsGETHIT;
      }
      loop{index i = 0; while; do:
        if(
          `pyr.stVal.ho[i].time != 0
          && (`pyr.stVal.ho[i].attr & hit.attr & 63) != 0
          && (`pyr.stVal.ho[i].attr & hit.attr & !63) != 0)
        {
          if(hitting > 0){
            if(!`pyr.changeState1(`pyr.playerno, `pyr.stVal.ho[i].stateno)){
              break, break;
            }
            if(`pyr.stVal.ho[i].forceair != 0) `pyr.stVal.typ = .StTy::A;
            `pyr.setCtrl(false);
            branch{
            cond #hitting == 1 && hit.p2stateno >= 0 && hit.p2getp1state != 0:
              rtn = damageable = false;
            else:
              rtn = true;
            }
          }
          if(`pyr.stVal.mov != .MovTy::H) damageable = false;
          ho = true;
          break, break, break;
        }
        i++;
      while i < #`pyr.stVal.ho:
      }
      if(#hitting == 1 && hit.p2stateno >= 0 && hit.p2getp1state != 0){
        p2s = 1;
        if(`pyr.changeState1(by.playerno, hit.p2stateno)){
          `pyr.setCtrl(false);
          p2s = 2;
        }
      }
    }
    bool live = `pyr.sysivar[.iLIFE] > 0;
    bool kill = #hitting == 1 ? hit.kill != 0 : hit.guard_kill != 0;
    `pyr.stVal.hb.damage +=
      `pyr.getDamage(`pyr.stVal.hb.absdamage*hits, kill, false, by.attackmul);
    if(live && !kill && `pyr.stVal.hb.damage >= `pyr.sysivar[.iLIFE]){
      `pyr.stVal.hb.damage = `pyr.sysivar[.iLIFE] - 1;
    }
    if(damageable) branch{
    cond #hitting == 1:
      by.addPower(hit.hitgetpower);
      `pyr.addPower(hit.hitgivepower);
      branch{
        if(hit.hitsoundg == .com.IERR) break;
        sou = by.newChannel(-1, false);
        if(#sou == 0) break;
      cond hit.hitsoundg < 0:
        if(#.fight~fsn > 0){
          sou~sound = .fight~fsn~getSound(!hit.hitsoundg, hit.hitsoundn);
        }
      else:
        if(#by.sn > 0){
          sou~sound = by.sn~getSound(hit.hitsoundg, hit.hitsoundn);
        }
      comm:
        sou~chrx = `pyr.sysfvar[.fX...fX+1];
        sou~setDefaultParameter();
      }
      if(hit.palfx_time > 0){
        ^&.com.PalFX fx = `pyr.getPalfx();
        fx~clear();
        fx~player = `pyr.id;
        fx~time = hit.palfx_time;
        fx~mulr = (float)hit.palfx_mulr / 256.0;
        fx~mulg = (float)hit.palfx_mulg / 256.0;
        fx~mulb = (float)hit.palfx_mulb / 256.0;
        fx~addr = hit.palfx_addr;
        fx~addg = hit.palfx_addg;
        fx~addb = hit.palfx_addb;
        fx~amplr = hit.palfx_amplr;
        fx~amplg = hit.palfx_amplg;
        fx~amplb = hit.palfx_amplb;
        if(hit.palfx_cycletime > 0) fx~cycletime = hit.palfx_cycletime;
        fx~color =
          .m.max!float?(0.0)<, .m.min!float?(1.0)<,
          ((float)hit.palfx_color / 256.0);
        fx~invertall = hit.palfx_invertall;
      }
      if(hit.envshake_time > 0){
        .stage.envShake.time = hit.envshake_time;
        .stage.envShake.freq = (hit.envshake_freq / 180.0) * .m.PI;
        .stage.envShake.ampl = hit.envshake_ampl;
        .stage.envShake.phase = hit.envshake_phase;
        .stage.envShake.setDefPhase();
      }
      `pyr.getcombo += hit.numhits*hits;
      if(
        pro == 0 && rtn && !by.cs1tmp && `pyr.ls(.lsSCREENBOUNDX) && (
          (by.facing < 0 && `pyr.sysfvar[.fX] <= `pxmi)
          || (by.facing > 0 && `pyr.sysfvar[.fX] >= `pxma))
        ) switch(`pyr.stVal.typ)
      {
      case .StTy::S, .StTy::C:
        by.veloff = by.stVal.hit.ground_cornerpush_veloff * (float)by.facing;
      case .StTy::A:
        by.veloff = by.stVal.hit.air_cornerpush_veloff * (float)by.facing;
      case .StTy::L:
        by.veloff = by.stVal.hit.down_cornerpush_veloff * (float)by.facing;
      }
      if(
        `pyr.hittmp < 2
        || #`pyr.stVal.hb.byid == 0 || `pyr.stVal.hb.byid[-1] != by.id)
      {
        `pyr.stVal.hb.juggle = by.sysivar[.iAIRJUGGLE];
      }
      if(!by.ls(.lsNOJUGGLECHECK)){
        `pyr.stVal.hb.juggle -=
          pro != 0 ? by.stVal.hit.air_juggle : by.stVal.juggle;
      }
    else:
      by.addPower(hit.guardgetpower);
      `pyr.addPower(hit.guardgivepower);
      branch{
        if(hit.guardsoundg == .com.IERR) break;
        sou = by.newChannel(-1, false);
        if(#sou == 0) break;
      cond hit.guardsoundg < 0:
        if(#.fight~fsn > 0){
          sou~sound = .fight~fsn~getSound(!hit.guardsoundg, hit.guardsoundn);
        }
      else:
        if(#by.sn > 0){
          sou~sound = by.sn~getSound(hit.guardsoundg, hit.guardsoundn);
        }
      comm:
        sou~chrx = `pyr.sysfvar[.fX...fX+1];
        sou~setDefaultParameter();
      }
      if(
        pro == 0 && rtn && !by.cs1tmp && `pyr.ls(.lsSCREENBOUNDX) && (
          (by.facing < 0 && `pyr.sysfvar[.fX] <= `pxmi)
          || (by.facing > 0 && `pyr.sysfvar[.fX] >= `pxma))
        ) switch(`pyr.stVal.typ)
      {
      case .StTy::S, .StTy::C:
        by.veloff = by.stVal.hit.guard_cornerpush_veloff * (float)by.facing;
      case .StTy::A:
        by.veloff = by.stVal.hit.airguard_cornerpush_veloff * (float)by.facing;
      }
    comm:
      branch{
        int op2f = `pyr.facing, byf;
      cond pro == 0 || hit.p1facing != 0:
        by.setFacing(
          (int)(`pyr.sysfvar[.fX] - by.sysfvar[.fX]) * hit.p1facing);
        byf = by.facing;
      else:
        byf = pro;
      comm:
        `pyr.setFacing(byf * -hit.p2facing);
        if(
          (hitting > 0 || p2s == 2) && (
            hit.p2facing != 0 ? (op2f != `pyr.facing) == (hit.p2facing > 0)
            : (`pyr.facing < 0) == (byf < 0)))
        {
          `pyr.stVal.hb.xvel *= -1.0;
          if(`pyr.stVal.hb.fall.xvelocity != .com.FERR){
            `pyr.stVal.hb.fall.xvelocity *= -1.0;
          }
        }
      }
      if(#hitting == 1 && hit.p1stateno >= 0) branch{
      cond
        !by.ls(.lsGETHIT) && (!by.cs1tmp || by.stVal.playerno == by.playerno)
        && (hit.p2stateno < 0 || hit.p2getp1state == 0 || p2s > 0)
        :
        by.changeState1(by.playerno, hit.p1stateno);
      else:
        break, break;
      }
      if(rtn && (!ho || #`pyr.stVal.hb.byid == 0)){
        by.addTarget(`pyr.id);
        `pyr.stVal.hb.addByid(by.id);
      }
    }
    ret rtn;
  }
  bool juggcheck(int h, int a)
  {
    ret a <= 0 || a <= h;
  }
  pyr.inguarddist = false;
  pyr.stVal.hb.damage = 0;
  loop{
    *`top.self p = `top;
    float pl, pr, pv;
    branch{
    cond pyr.facing > 0:
      pl = pyr.sysfvar[.fX] - pyr.backw;
      pr = pyr.sysfvar[.fX] + pyr.frontw;
    else:
      pl = pyr.sysfvar[.fX] - pyr.frontw;
      pr = pyr.sysfvar[.fX] + pyr.backw;
    }
    pv = pyr.acttmp > 0 ? pyr.sysfvar[.fVX] : 0.0;
    while;
  do:
    if(p~c~id < 0) continue;
    if(
      (pyr.playerno&1) != (p~c~playerno&1) && pyr.pushable() && p~c~pushable()
      && (
        (
          pyr.stVal.typ != .StTy::A || pyr.stVal.mov != .MovTy::A
          || p~c~stVal.typ != .StTy::L)
        && (
          pyr.stVal.typ != .StTy::L
          || p~c~stVal.typ != .StTy::A || p~c~stVal.mov != .MovTy::A))
      && pyr.sysfvar[.fY] - p~c~sysfvar[.fY] < .com.BodyHeight
      && p~c~sysfvar[.fY] - pyr.sysfvar[.fY] < .com.BodyHeight)
    {
      float el, er;
      branch{
      cond p~c~facing > 0:
        el = p~c~sysfvar[.fX] - p~c~backw;
        er = p~c~sysfvar[.fX] + p~c~frontw;
      else:
        el = p~c~sysfvar[.fX] - p~c~frontw;
        er = p~c~sysfvar[.fX] + p~c~backw;
      }
      float ev = p~c~acttmp > 0 ? p~c~sysfvar[.fVX] : 0.0;
      if((pl < el || pl < er)  && (el < pr || er < pr)){
        const float foo = 0.5;
        branch{
          float tmp = pyr.sysfvar[.fX] - p~c~sysfvar[.fX];
        cond tmp < 0.0:
          pyr.sysfvar[.fX] -= (pr - el) * foo;
          p~c~sysfvar[.fX] += (pr - el) * foo;
        cond tmp > 0.0:
          pyr.sysfvar[.fX] += (er - pl) * foo;
          p~c~sysfvar[.fX] -= (er - pl) * foo;
        cond pyr.sysfvar[.fY] > p~c~sysfvar[.fY]:
          branch{
          cond pyr.facing < 0 ? pv > 0.0 : pv <= 0.0:
            pyr.sysfvar[.fX] -= (pr - el) * foo;
            p~c~sysfvar[.fX] += (pr - el) * foo;
          else:
            pyr.sysfvar[.fX] += (er - pl) * foo;
            p~c~sysfvar[.fX] -= (er - pl) * foo;
          }
        else:
          branch{
          cond p~c~facing < 0 ? ev > 0.0 : ev <= 0.0:
            pyr.sysfvar[.fX] += (er - pl) * foo;
            p~c~sysfvar[.fX] -= (er - pl) * foo;
          else:
            pyr.sysfvar[.fX] -= (pr - el) * foo;
            p~c~sysfvar[.fX] += (pr - el) * foo;
          }
        }
        if(pyr.ls(.lsSCREENBOUNDX)) branch{
        cond pyr.sysfvar[.fX] < pxmi:
          pyr.sysfvar[.fX] = pxmi;
        cond pyr.sysfvar[.fX] > pxma:
          pyr.sysfvar[.fX] = pxma;
        }
        if(p~c~ls(.lsSCREENBOUNDX)) branch{
          float l, r, x = p~c~sysfvar[.fX];
          branch{
          cond p~c~facing > 0:
            l = .com.xmin+p~c~bedge; r = .com.xmax-p~c~fedge;
          else:
            l = .com.xmin+p~c~fedge; r = .com.xmax-p~c~bedge;
          }
        cond x < l:
          p~c~sysfvar[.fX] = l;
        cond x > r:
          p~c~sysfvar[.fX] = r;
        }
      }
    }
    if(
      p~c~atktmp < 0 || p~c~id == pyr.id || (
        p~c~stVal.hit.affectteam != 0
        && ((pyr.playerno&1) != (p~c~playerno&1))
        != (p~c~stVal.hit.affectteam > 0))) continue;
    if(
      p~c~stVal.mov == .MovTy::A && (
        p~c~attackdist >= #(pyr.sysfvar[.fX] - p~c~sysfvar[.fX])))
    {
      pyr.inguarddist = true;
    }
    if(
      p~c~stVal.hit.hitonce >= 0 && (
        pyr.hittmp < 2
        || #pyr.stVal.hb.byid == 0 || pyr.stVal.hb.byid[-1] != p~c~id
        || p~c~ls(.lsNOJUGGLECHECK)
        || juggcheck(pyr.stVal.hb.juggle, p~c~stVal.juggle))
      && pyr.hittable(
        p~c~stVal.hit=, [bool(&.Hitdef h=){
          ret p~c~attrCheck(h=)&&p~c~hitCheck(pyr=);}]))
    {
      if(
        .m.inRange!float?(
          0.0, (float)p~c~stVal.hit.guard_dist,
          (pyr.sysfvar[.fX] - p~c~sysfvar[.fX])*(float)p~c~facing))
      {
        pyr.inguarddist = true;
      }
      if(pyr.hitCheck(p~c<>=)){
        branch{
          int h =
            pyr.stVal.setHb(
              p~c~stVal.hit=, !p~c~ls(.lsUNGUARDABLE) && pyr.ls(.lsGUARD),
              pyr.stVal.mov == .MovTy::H || pyr.ls(.lsGETHIT), pyr.facing);
          if(!foo(h, p~c<>=, p~c~stVal.hit=, 0.0, 0, 1)) break;
        cond #h == 1:
          p~c~stVal.mctyp = .MoveContact::Hit;
          if(p~c~stVal.hit.reversal_attr > 0){
            pyr.stVal.mctyp = .MoveContact::Reversed;
            pyr.stVal.mctime = -1;
            pyr.tmphit = true;
            if(pyr.hittmp == 0) pyr.hittmp = -1;
            if(!pyr.ls(.lsGETHIT)){
              pyr.sysivar[.iHITPAUSETIME] =
                .m.max!int?(1, p~c~stVal.hit.shaketime);
            }
          }
          if(!p~c~ls(.lsGETHIT)){
            p~c~sysivar[.iHITPAUSETIME] =
              .m.max!int?(1, p~c~stVal.hit.pausetime);
          }
          p~c~sysivar[.iUNIQHITCOUNT]++;
        else:
          p~c~stVal.mctyp = .MoveContact::Guarded;
          if(!p~c~ls(.lsGETHIT)){
            p~c~sysivar[.iHITPAUSETIME] =
              .m.max!int?(1, p~c~stVal.hit.guard_pausetime);
          }
        comm:
          if(h > 0) pyr.sysivar[.iHITPAUSETIME] = 0;
          if(p~c~stVal.hit.hitonce > 0) p~c~stVal.hit.hitonce = -1;
          p~c~stVal.mctime = -1;
        break:
          p~c~tmphit = true;
        }
      }
    }
  continue:
    p = p~next;
  while #p > 0:
  }
  loop{
    index i = 0;
    while;
  do:
    loop{
      index j = 0;
      bool hoge;
      while;
    do:
      if(
        pyr.playerno == i || .projs[i][j].id < 0 || .projs[i][j].hits <= 0 || (
          .projs[i][j].hit.affectteam != 0 && ((pyr.playerno&1) != (i&1))
          != (.projs[i][j].hit.affectteam > 0))) continue;
      if(
        (float).chars[i][0]~sysivar[.iPROJ_ATTACK_DIST]
        >= #(pyr.sysfvar[.fX] - .projs[i][j].x))
      {
        pyr.inguarddist = true;
      }
      hoge = true;
      if(
        .projs[i][j].hit.hitonce >= 0 && (
          pyr.hittmp < 2 || #pyr.stVal.hb.byid == 0
          || pyr.stVal.hb.byid[-1] != .chars[i][0]~id
          || .chars[i][0]~ls(.lsNOJUGGLECHECK)
          || juggcheck(pyr.stVal.hb.juggle, .projs[i][j].hit.air_juggle))
        && .projs[i][j].timemiss <= 0
        && .projs[i][j].hitpause <= 0 && pyr.hittable(
          .projs[i][j].hit=, [bool(&.Hitdef h=){
            ret
              (h.hitflag&(int).StTy::U) != 0
              && pyr.hitProjCheck(.projs[i][j]=);
          }]))
      {
        hoge = false;
        if(
          .m.inRange!float?(
            0.0, (float).projs[i][j].hit.guard_dist,
            (pyr.sysfvar[.fX] - .chars[i][0]~sysfvar[.fX])
            * (float).chars[i][0]~facing))
        {
          pyr.inguarddist = true;
        }
        if(pyr.projHitCheck(.projs[i][j]=)){
          int hit =
            pyr.stVal.setHb(
              .projs[i][j].hit=, pyr.ls(.lsGUARD),
               pyr.stVal.mov == .MovTy::H || pyr.ls(.lsGETHIT), pyr.facing);
          if(
            foo(
              hit, .chars[i][0]<>=, .projs[i][j].hit=,
              .projs[i][j].y - .chars[i][0]~sysfvar[.fY], .projs[i][j].facing,
              .projs[i][j].misstime <= 0 && (
                #hit == 1 ? .projs[i][j].hit.pausetime
                : .projs[i][j].hit.guard_pausetime) <= 0
              ? .projs[i][j].hits : 1))
          {
            if(hit > 0) pyr.sysivar[.iHITPAUSETIME] = 0;
            .projs[i][j].timemiss = !.m.max!int?(0, .projs[i][j].misstime);
            branch{
            cond #hit == 1:
              .projs[i][j].pctyp == .ProjContact::Hit;
              .projs[i][j].pctime = -1;
              .projs[i][j].hitpause =
                .m.max!int?(0, .projs[i][j].hit.pausetime);
            else:
              .projs[i][j].pctyp == .ProjContact::Guarded;
              .projs[i][j].pctime = -1;
              .projs[i][j].hitpause =
                .m.max!int?(0, .projs[i][j].hit.guard_pausetime);
            }
            if(.projs[i][j].hit.hitonce > 0) .projs[i][j].hit.hitonce = -1;
          }
        }
      }
      if(
        .projs[i][j].prioritypoint > 0 && pyr.atktmp >= 0
        && (
          pyr.stVal.hit.affectteam == 0 || (
           ((i&1) != (pyr.playerno&1)) == (pyr.stVal.hit.affectteam > 0)))
        && (pyr.stVal.hit.hitflag & (int).StTy::U) != 0
        && pyr.hitProjCheck(.projs[i][j]=) && (
          hoge || (
            pyr.stVal.hit.priority == .projs[i][j].hit.priority
            && .projs[i][j].hit.bothhittype != .PriTy::Dodge
            && pyr.stVal.hit.bothhittype == .PriTy::Hit)))
      {
        .projs[i][j].hits = 0;
        .projs[i][j].prioritypoint = 0;
        .projs[i][j].pctyp == .ProjContact::Cancel;
        .projs[i][j].pctime = -1;
      }
    continue:
      j++;
    while j < #.projs[i]:
    }
    i++;
  while i < #.projs:
  }
}
public void PlayerList!&Char?::getHit()
{
  loop{
    *`top.self p = `top;
    while;
  do:
    if(p~c~id < 0) continue;
    .players.clsn(p~c<>=);
  continue:
    p = p~next;
  while #p > 0:
  }
}
public void PlayerList!&Char?::tick()
{
  loop{
    *`top.self p = `top;
    while;
  do:
    if(p~c~id < 0) continue;
    p~c~tick();
  continue:
    p = p~next;
  while #p > 0:
  }
}



^int sndbuf;
sndbuf.new(.sdl.SNDBUFLEN);

void sndbufClear()
{
  loop{index i = 0; do:
    .sndbuf[i++] = 0;
  while  i < .sdl.SNDBUFLEN:
  }
}
sndbufClear();

void playSound()
{
  if(.sdl.setSndBuf(.sndbuf)){
    .sndbufClear();
    .syssnd.mix(
      .sndbuf, .com.xmin - .com.screenleft, .com.xmax + .com.screenright);
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(#.chars[i][j] > 0) loop{index k = 0; while; do:
          .chars[i][j]~sounds[k].mix(
            .sndbuf,
            .com.xmin - .com.screenleft, .com.xmax + .com.screenright);
          k++;
        while k < #.chars[i][j]~sounds:
        }
        j++;
      while j < #.chars[i]:
      }
      i++;
    while i < #.chars:
    }
  }
}
void stopAllSound()
{
  if(.sdl.setSndBuf(.sndbuf)){
    .sndbufClear();
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(#.chars[i][j] > 0) loop{index k = 0; while; do:
          .chars[i][j]~sounds[k].sound.new(0);
          k++;
        while k < #.chars[i][j]~sounds:
        }
        j++;
      while j < #.chars[i]:
      }
      i++;
    while i < #.chars:
    }
  }
}

public void charInit(&.Char c=, int no, int idx)
{
  c.clearVal();
  c.playerno = no;
  c.helperindex = idx;
  if(c.helperindex == 0){
    c.keyctrl = true;
    c.player = true;
  }
  c.key = .m.inRange!int?(0, #.com.com-1, no) && .com.com[no] == 0 ?  no : !no;
}

public ^&Char create(int no)
{
  index idx = 0;
  loop{while; do:
    if(.chars[no][idx]~helperindex < 0) break;
    idx++;
  while idx < #.chars[no]:
    if(idx >= .cfg.HelperMax) ret .consts.null!&.Char?();
    .chars[no].new[idx].new(1);
  }
  ^&.Char c = .chars[no][idx];
  .charInit(c<>=, no, idx);
  c~id = .id++;
  .players.add(c);
  ret c;
}
void gSetNormal(float scl, float x, float y)
{
  .com.scale = .stg~ztopscale*scl;
  .com.zoffset = (float).stg~zoffset*scl + (1.0 - scl)*240.0;
  .com.yoffset = (.stg~bga.yoffset-.stage.envShake.getOffset())*scl;
  .com.xoffset = .stg~bga.xoffset*scl;
  .com.scrxmin = (float).stg~cam.boundleft - 160.0/.stg~ztopscale;
  .com.scrxmax = (float).stg~cam.boundright + 160.0/.stg~ztopscale;
  .com.screenx = x - 160.0 / .com.scale;
  .com.screeny = y - .com.zoffset / .com.scale;
  .com.camerax = x;
  .com.cameray = y;
  .com.screenleft = (float).stg~screenleft;
  .com.screenright = (float).stg~screenright;
  .com.xmin = .com.screenx + .com.screenleft;
  .com.xmax = .com.screenx + (320.0 / .com.scale) - .com.screenright;
  if(.com.xmin > .com.xmax){
    .com.xmin = .com.xmax = (.com.xmin + .com.xmax) * 0.5;
  }
}

^&.fgt.LifePower getLifePower()
{
  %&.fgt.LifePower lpl;
  loop{index i = 0; while; do:
    branch{
    cond #.chars[i] > 0:
      lpl.new[-1].set(
        (float).chars[i][0]~sysivar[.iLIFE]
        / (float).chars[i][0]~sysivar[.iLIFEMAX],
        (float).chars[i][0]~getSharePower()
        / (float).chars[i][0]~sysivar[.iPOWERMAX],
        .chars[i][0]~getSharePower() / 1000);
    else:
      lpl.new[-1].set(0.0, 0.0, 0);
    }
    i++;
  while i < #.chars:
  }
  ret lpl;
}

void update(
  float tension, float cvx=,
  float highest=, float lowest=, float leftest=, float rightest=)
{
  .players.move(highest=, lowest=, leftest=, rightest=);
  .players.update(tension, cvx=);
  loop{index i = 0; while; do:
    loop{index j = 0; while; do:
      if(.projs[i][j].id >= 0) .projs[i][j].update();
      j++;
    while j < #.projs[i]:
    }
    i++;
  while i < #.projs:
  }
}

void commandUpdate()
{
  loop{index i = 0; while; do:
    if(#.chars[i] > 0){
      .chars[i][0]~cmd.step(
        .chars[i][0]~key, .chars[i][0]~facing,
        .chars[i][0]~key < 0, .chars[i][0]~isHitPaused());
    }
    i++;
  while i < #.chars:
  }
}

void rootAction()
{
  if(.com.tickNextFrame()){
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(.projs[i][j].id >= 0) .projs[i][j].projClsn();
        j++;
      while j < #.projs[i]:
      }
      i++;
    while i < #.projs:
    }
    .players.getHit();
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(.projs[i][j].id >= 0) .projs[i][j].tick();
        j++;
      while j < #.projs[i]:
      }
      i++;
    while i < #.projs:
    }
    .players.tick();
  }
}

void anim()
{
  loop{index i = 0; while; do:
    loop{index j = 0; while; do:
      if(.projs[i][j].id >= 0) .projs[i][j].anime();
      j++;
    while j < #.projs[i]:
    }
    i++;
  while i < #.projs:
  }
  loop{index i = 0; while; do:
    loop{index j = 0; while; do:
      .chars[i][j]~drawAnim();
      j++;
    while j < #.chars[i]:
    }
    i++;
  while i < #.chars:
  }
}

public float action(
  float x=, float y=, float leftest=, float rightest=, float scl)
{
  .anims.new(0);
  .topanims.new(0);
  .shadows.new(0);
  .resetDrawnClsnList();
  .gSetNormal(scl, x, y);
  float tension = (float).stg~cam.tension / .com.scale;
  float cvx = 0.0;
  float highest = 0.0, lowest = .com.screeny;
  rightest = leftest = x;
  int rs4t =
    -(
      .fight~ro.over_hittime
      + .fight~ro.over_waittime + .fight~ro.over_wintime);
  if(.com.intro == rs4t-1 && .com.turbo > 0.0 && #(x - .oldx) >= .com.turbo){
    .com.intro = rs4t;
  }
  branch{
  cond .com.tickFrame():
    .com.allPalFX~step();
    .stage.bgPalFX~step();
    .stage.envShake.next();
    if(.envcol_time > 0) .envcol_time--;
    branch{
    cond .super > 0:
      .super--;
    cond .pause > 0:
      .pause--;
    }
    if(.pausetime < 0){
      .pausetime = !.pausetime;
      .pause = .pausetime;
    }
    if(.supertime < 0){
      .supertime = !.supertime;
      .super = .supertime;
    }
    branch{
    cond .super <= 0 && .pause <= 0:
      .specialFlag = 0d0;
    else:
      .specialFlag &= !.gsROUNDNOTOVER;
    }
    if(#.superanim > 0) .superanim~ani.action();
    .players.action(x, tension, cvx=, highest=, lowest=, leftest=, rightest=);
  else:
    .update(tension, cvx=, highest=, lowest=, leftest=, rightest=);
    .rootAction();
  }
  %bool hbuf;
  loop{index i = 0; while; do:
    branch{
    cond #.chars[i] > 0:
      hbuf .=
        (.chars[i][0]~getcombo != 0 || .chars[i][0]~stVal.mov == .MovTy::H)
        && .chars[i][0]~sysivar[.iRECOVERTIME] > 0;
    else:
      hbuf .= false;
    }
    i++;
  while i < #.chars:
  }
  ^int cb;
  cb.new(2);
  cb[0] = cb[1] = 0;
  loop{index i = 0; while; do:
    loop{index j = 0; while; do:
      cb[!i&1] =
        .m.min!int?(999)<, .m.max!int?(cb[!i&1], .chars[i][j]~getcombo);
      j++;
    while j < #.chars[i]:
    }
    i++;
  while i < #.chars:
  }
  .fight~step(.com.tmode, .getLifePower(), hbuf, cb, .syssnd=);
  if(#.superanim > 0){
    .addAnimList(
      .topanims=, .superanim, 5, .superposx, .superposy, .com.scale,
      (float).superfacing, 1.0, 0.0, false, 1.0, 1.0, -1, 0, 256,
      .consts.null!&.com.PalFX?(), 0, 0.0);
    if(.superanim~ani.loopend) .superanim.new(0);
  }
  .anim();
  loop{index i = 0; while; do:
    loop{index j = #.expdrawlist[i]-1; while; do:
      if(.explods[i][.expdrawlist[i][j]].id != .com.IERR){
        .explods[i][.expdrawlist[i][j]].update();
      }
      if(.explods[i][.expdrawlist[i][j]].id == .com.IERR){
        .delIL(.expdrawlist[i]=, j);
      }
      j--;
    while j >= 0:
    }
    i++;
  while i < #.explods:
  }
  leftest -= x;
  rightest -= x;
  if(.com.intro == rs4t && #(leftest + rightest)*.com.scale > 64.0){
    float tmp;
    branch{
    cond leftest + rightest < 0.0:
      tmp =
        .m.max!float?(0.0, (.com.xmin - x - .com.screenleft) - leftest + 64.0);
      tmp = -.m.sqrt(tmp * (1.0/16.0));
    else:
      tmp =
        .m.max!float?(
          0.0, rightest - (.com.xmax - x + .com.screenright) + 64.0);
      tmp = .m.sqrt(tmp * (1.0/16.0));
    }
    cvx += tmp * .m.min!float?(1.0, .com.turbo);
  }
  branch{
    float tmp = leftest + rightest;
  cond cvx < 0.0:
    if(cvx < tmp) cvx = .m.min!float?(0.0, tmp);
  else:
    if(cvx > tmp) cvx = .m.max!float?(0.0, tmp);
  }
  if(.com.turbo > 0.0) .oldx = x;
  x += cvx;
  if(lowest >= highest) branch{
  cond highest < (float)-.stg~cam.floortension / .com.scale:
    y =
      (highest + (float).stg~cam.floortension / .com.scale)
      * .com.scale * .stg~cam.verticalfollow;
  else:
    y = 0.0;
  }
  bool finish()
  {
    bool p1 = false, p2 = false;
    loop{index i = 0; while; do:
      if(#.chars[i] > 0 && .chars[i][0]~sysivar[.iLIFE] > 0) break;
      i += 2;
    while i < #.chars:
      p1 = true;
    }
    loop{index i = 1; while; do:
      if(#.chars[i] > 0 && .chars[i][0]~sysivar[.iLIFE] > 0) break;
      i += 2;
    while i < #.chars:
      p2 = true;
    }
    branch{
    cond .com.time == 0:
      {
        .com.intro = -.fight~ro.over_hittime;
        if(p1 || p2) break;
        .winty[0] = .winty[1] = .fgt.WinTy::T;
        float l1 = 0.0, l2 = 0.0;
        loop{index i = 0; while; do:
          if(#.chars[i] > 0){
            l1 +=
              (.com.tmode[0] == (int).com.TeamMode::Simul ? 0.5 : 1.0)
              * (float).chars[i][0]~sysivar[.iLIFE]
              / (float).chars[i][0]~sysivar[.iLIFEMAX];
          }
          i += 2;
        while i < #.chars:
        }
        loop{index i = 1; while; do:
          if(#.chars[i] > 0){
            l2 +=
              (.com.tmode[1] == (int).com.TeamMode::Simul ? 0.5 : 1.0)
              * (float).chars[i][0]~sysivar[.iLIFE]
              / (float).chars[i][0]~sysivar[.iLIFEMAX];
          }
          i += 2;
        while i < #.chars:
        }
        branch{
        cond l1 > l2:
          p2 = true;
        cond l2 > l1:
          p1 = true;
        else:
          p1 = p2 = true;
        }
      }
    cond .gs(.gsNOKO):
      ret false;
    }
    if(.com.intro == -.fight~ro.over_hittime && (p1 || p2)) branch{
    cond
      .com.tmode[0] != (int).com.TeamMode::Turns
      && .com.tmode[1] != (int).com.TeamMode::Turns
      && .com.draws < .fight~ro.match_maxdrawgames && p1 && p2
      :
      .com.draws++;
    else:
      if(p2){
        loop{index i = 0; while; do:
          if(
            #.chars[i] > 0
            && .chars[i][0]~sysivar[.iLIFE]
            < .chars[i][0]~sysivar[.iLIFEMAX]) break;
          i += 2;
        while i < #.chars:
          .fgt.setPerfect(.winty[0]=);
        }
        .fight~wi[0].add(.winty[0]);
        .com.p1wins += 1;
      }
      if(p1){
        loop{index i = 1; while; do:
          if(
            #.chars[i] > 0
            && .chars[i][0]~sysivar[.iLIFE]
            < .chars[i][0]~sysivar[.iLIFEMAX]) break;
          i += 2;
        while i < #.chars:
          .fgt.setPerfect(.winty[1]=);
        }
        .fight~wi[1].add(.winty[1]);
        .com.p2wins += 1;
      }
    }
    if(.com.intro == -.fight~ro.over_hittime) branch{
    cond p1 && p2:
      .ko =
        .winty[0] == .fgt.WinTy::T || .winty[0] == .fgt.WinTy::PT
        ? .fgt.KOTy::TODraw : .fgt.KOTy::DKO;
      .com.win = -1;
    cond p1:
      .ko =
        .winty[1] == .fgt.WinTy::T || .winty[1] == .fgt.WinTy::PT
        ? .fgt.KOTy::TO : .fgt.KOTy::KO;
      .com.win = 1;
    cond p2:
      .ko =
        .winty[0] == .fgt.WinTy::T || .winty[0] == .fgt.WinTy::PT
        ? .fgt.KOTy::TO : .fgt.KOTy::KO;
      .com.win = 0;
    }
    ret p1 || p2;
  }
  void posreset()
  {
    loop{
      index i = 0;
      while;
    do:
      if(#.chars[i] > 0){
        if(.gs(.gsINTRO)) .charClear(i);
        .chars[i][0]~posReset((float).stg~p1.startx, (float).stg~p2.startx);
        .v.setI(0);
        .chars[i][0]~trSelfState(-1, 1);
      }
      i++;
    while i < #.chars:
      `x = (float).stg~cam.startx;
      `leftest =
        .m.max!float?(
          (float).m.min!int?(.stg~p1.startx, .stg~p2.startx) - `x,
          -160.0/.com.scale + .com.screenleft) + (`x - .oldx);
      `rightest =
        .m.min!float?(
          (float).m.max!int?(.stg~p1.startx, .stg~p2.startx) - `x,
          160.0/.com.scale - .com.screenright) + (`x - .oldx);
    }
  }
  int slowfade = .fight~ro.slow_time * 2 / 5;
  branch{
  cond .shuttertime > 0 ? .com.tickNextFrame() : .fight~ro.act(.syssnd=, .ko):
    branch{
    cond .com.intro > .fight~ro.ctrl_time:
      .com.intro--;
      if(.gs(.gsINTRO) && .com.intro <= .fight~ro.ctrl_time){
        branch{
        cond .shuttertime > 0 || .cmd.anybutton():
          if(.shuttertime < 15) .shuttertime++;
          branch{
          cond .shuttertime == 15:
            posreset();
            .resetGblEffect();
          else:
            break, else;
          }
        else:
          .com.intro = .fight~ro.ctrl_time+1;
        }
      }
    else:
      if(.shuttertime == 0 && .com.intro >= 1) .com.intro--;
      if(.shuttertime > 0) .shuttertime--;
    }
    if(
      .com.intro == 0 && .com.time > 0 && !.gs(.gsTIMERFREEZE)
      && (.super <= 0 || .superpausebg == 0) 
      && (.pause <= 0 || .pausebg == 0)) .com.time--;
    branch{
    cond .roundEnd() || finish():
      branch{
      cond
        .roundState() != 3 || (.super <= 0 && .pause <= 0) || .cmd.anybutton()
        :
      cond .com.intro >= .slowt-slowfade:
        .slowt++;
        break;
      else:
        break;
      comm:
        if(.winskipped || !.gs(.gsROUNDNOTOVER) || .com.intro >= rs4t){
          .com.intro--;
          if(.com.time != 0 && .com.intro == rs4t-1) loop{
            index i = 0;
            while;
          do:
            if(#.chars[i] > 0) branch{
            cond .chars[i][0]~isWin():
            cond .chars[i][0]~stVal.no != 5150:
              if(.chars[i][0]~sysivar[.iWAITWIN]-- > 0) .com.intro = rs4t;
            }
            i++;
          while i < #.chars:
          }
        }
      }
    else:
      if(.com.intro < 0) .com.intro = 0;
    }
  cond .fight~ro.cur == 1 && .com.tickNextFrame():
    posreset();
  }
  if(.com.turbo == 0.0 || .com.tickNextFrame()) branch{
    float spd =
      #.cmd.net == 0 && .com.pause && !.com.keyDown(.com.KeyEvent::Scroll)
      ? 0.0 : .com.Speed;
  cond
    !.gs(.gsNOKOSLOW) && .com.time != 0
    && .m.inRange!int?(.slowt, -.fight~ro.over_hittime-1, .com.intro)
    :
    .com.turbo = spd * 0.25;
  cond
    !.gs(.gsNOKOSLOW) && .com.time != 0
    && .m.inRange!int?(.slowt-slowfade, .slowt-1, .com.intro)
    :
    .com.turbo =
      spd*(0.25 + 0.75 * (float)(-.com.intro + .slowt)/(float)slowfade);
  else:
    .com.turbo = spd;
  }
  .sdl.pauseBGM(.gs(.gsNOMUSIC));
  .playSound();
  float foobar =
    .m.max!float?(220.0/.com.scale)<, .m.sqrt(
      (rightest - leftest)*(rightest - leftest)
      + (lowest - highest)*(lowest - highest));
  const float barbaz = 12.0;
  float tmp =
    (foobar*.com.scale) / .m.max!float?(.com.scale)<, (
      (400.0 - 80.0*.m.max!float?(1.0, .com.scale)) * 2.0**(barbaz-2.0));
  branch{
  cond tmp >= 3.0/2.0**barbaz:
    tmp = .m.max!float?(15.0/16.0)<, (67.0/64.0 - tmp*2.0**(barbaz-6.0));
  else:
    tmp =
      .m.min!float?(129.0/128.0)<, ((2.0**barbaz+3.0)/2.0**barbaz - tmp)**64.0;
  }
  branch{
  cond .super > 0 || .pause > 0:
    tmp = 1.0;
  cond tmp > 1.0:
    tmp = (tmp - 1.0)*.zoomdelay**8.0 + 1.0;
    if(foobar*tmp > .com.xmax - .com.xmin){
      tmp = (.com.xmax - .com.xmin) / foobar;
    }
    .zoomdelay = .m.min!float?(1.0, .zoomdelay + 1.0/32.0);
  else:
    .zoomdelay = 0.0;
  }
  leftest -= .com.screenleft;
  rightest += .com.screenright;
  leftest *= .stg~ztopscale;
  rightest *= .stg~ztopscale;
  ret tmp;
}
public void draw(float x, float y, float scl)
{
  ^&.fgt.LifePower lpl = .getLifePower();
  uint ecol =
    ((uint).envcol_b&0xff)
    | ((uint).envcol_g<<0d8&0xff00) | ((uint).envcol_r<<0d16&0xff0000);
  &.sdl.Rect onedot.set(0, 0, 0d1, 0d1), til.set(0, 0, 0d0, 0d0);
  ^ubyte px;
  px.new(1);
  px<> = 0d0;
  %byte dammy;
  %^/char winner;
  if(.com.win >= 0){
    winner.new[-1] = .chars[.com.win][0]~displayname;
    if(.com.tmode[.com.win] == (int).com.TeamMode::Simul){
      winner.new[-1] = .chars[.com.win+2][0]~displayname;
    }
  }
  ^^/char names;
  names.new(4);
  names[0] = .chars[0][0]~displayname;
  names[1] = .chars[1][0]~displayname;
  if(#.chars[2] > 0) names[2] = .chars[2][0]~displayname;
  if(#.chars[3] > 0) names[3] = .chars[3][0]~displayname;
  int ob = .com.brightness;
  .com.brightness = 256 >> (int)(.super > 0 && .superdarken != 0);
  if(.envcol_time == 0) branch{
  cond .gs(.gsNOBG):
    .sdl.screen.fill(.com.scrrect=, 0x00000000);
  else:
    if(.stg~debugbg) .sdl.screen.fill(.com.scrrect=, 0x00ff00ff);
    .stg~bgDraw(false, x, y, scl);
  }
  branch{
  cond<envu> .envcol_time != 0 && .envcol_under != 0:
    .sdl.screen.fill(.com.scrrect=, ecol);
  cond<envt> .envcol_time != 0:
    break;
  comm:
    if(!.gs(.gsGLOBALNOSHADOW)){
      if(.stg~reflection > 0) .drawReflection(x, y);
      if(.stg~sdw.intensity > 0) .drawShadowList(x, y);
    }
  else:
    .fight~draw(0, lpl, names, .gs(.gsNOBARDISPLAY));
    .fight~ro.draw(0, .ko, winner);
  }
  if(.envcol_time == 0 || .envcol_under != 0){
    .drawAnimList(.anims=, x, y);
  }
  if(.envcol_time == 0 && !.gs(.gsNOFG)) .stg~bgDraw(true, x, y, scl);
  if(.envcol_time != 0 && .envcol_under == 0){
    .tmppl<> = ecol;
    .sdl.screen.fill(.com.scrrect=, ecol);
  }
  .fight~draw(1, lpl, names, .gs(.gsNOBARDISPLAY));
  .fight~ro.draw(1, .ko, winner);
  .drawAnimList(.topanims=, x, y);
  .fight~draw(2, lpl, names, .gs(.gsNOBARDISPLAY));
  .fight~ro.draw(2, .ko, winner);
  void fade(.com.scrrect.self rect=, int alpha)
  {
    .tmppl<> = 0x000000;
    .sdl.screen.renderMugenZoom(
      rect=, 0.0, 0.0, `px, .tmppl, -1, `onedot=, 0.0, 0.0, `til=,
      (float).cfg.Width, (float).cfg.Width, (float).cfg.Height, 0.0, 0d0,
      alpha, 0, `dammy=);
  }
  if(.com.intro > .fight~ro.ctrl_time+1){
    fade(
      .com.scrrect=,
      256 * (.com.intro - (.fight~ro.ctrl_time+1)) / .fight~ro.start_waittime);
  }
  int tmp =
    .fight~ro.over_hittime + .fight~ro.over_waittime
    + (.fight~ro.over_time - .fight~ro.start_waittime);
  if(.fight~ro.over_time >= .fight~ro.start_waittime && .com.intro < -tmp){
    fade(.com.scrrect=, 256 * (-tmp - .com.intro) / .fight~ro.start_waittime);
  }
  if(.shuttertime > 0){
    *.com.scrrect.self rect = .com.scrrect;
    rect.h = (uint).shuttertime * ((.com.scrrect.h+0d1)>>0d1) / 0d15;
    fade(rect=, 255);
    rect.y = (int)(.com.scrrect.h - rect.h);
    fade(rect=, 255);
  }
  .com.brightness = ob;
  if(.com.clsndraw) .drawClsn();
}

void resetGblEffect()
{
  .com.allPalFX~clear();
  .stage.bgPalFX~clear();
  .stage.envShake.clear();
  .pause = 0;
  .pausetime = 0;
  .super = 0;
  .supertime = 0;
  .superanim.new(0);
  .envcol_time = 0;
  .specialFlag = 0d0;
}
void resetGbl()
{
  .resetGblEffect();
  .fight~reset();
  .ko = .fgt.KOTy::NotYet;
  .com.win = -1;
  .winty[0] = .winty[1] = .fgt.WinTy::N;
  .zoomdelay = 0.0;
  .playerid.new(0);
  .resetNumenemy();
  .slowt = -(.fight~ro.over_hittime+((.fight~ro.slow_time+3)>>2));
  .shuttertime = 0;
  .winskipped = false;
}

void charClear(int pn)
{
  loop{index j = 1; while; do:
    .chars[pn][j]~destroySelf();
    .chars[pn][j]~sounds.new(0);
    j++;
  while j < #.chars[pn]:
  }
  .projs[pn].new(0);
  .explods[pn].new(0);
  .expdrawlist[pn].new(0);
  .chars[pn][0]~children.new(0);
  .chars[pn][0]~targets.new(0);
  .chars[pn][0]~sounds.new(0);
}

public void nextRound()
{
  .resetGbl();
  .com.intro = .fight~ro.start_waittime + .fight~ro.ctrl_time+1;
  .com.time = .cfg.Time;
  .id = .cfg.HelperMax;
  if(.stg~resetbg) .stg~reset();
  .gSetNormal(1.0, (float).stg~cam.startx, 0.0);
  loop{index i = 0; while; do:
    if(#.chars[i] == 0) continue;
    .id = .chars[i][0]~id + 1;
    .charClear(i);
    .chars[i][0]~posReset((float).stg~p1.startx, (float).stg~p2.startx);
    .chars[i][0]~setCtrl(false);
    .chars[i][0]~stVal.clear();
    .chars[i][0]~clearSpSysVar();
    .chars[i][0]~rangeSetIVar(
      0, .chars[i][0]~sysivar[.iINTPERSISTINDEX]-1, 0);
    .chars[i][0]~rangeSetFVar(
      0, .chars[i][0]~sysivar[.iFLOATPERSISTINDEX]-1, 0.0);
  continue:
    i++;
  while i < #.chars:
  }
  loop{
    index i = 0;
    while;
  do:
    if(#.chars[i] > 0){
      .chars[i][0]~trChangeAnim(0);
      .v.setI(5900);
      .chars[i][0]~trSelfState(-1, -1);
    }
    i++;
  while i < #.chars:
  }
}


public bool roundOver()
{
  if(.roundState() == 4 && .cmd.anybutton()){
    .com.intro =
      .m.min!int?(
        .com.intro,
        -(
          .fight~ro.over_hittime + .fight~ro.over_waittime
          + (.fight~ro.over_time - .fight~ro.start_waittime)));
    .winskipped = true;
  }
  ret
    .com.intro < -(
      .fight~ro.over_hittime + .fight~ro.over_waittime + .fight~ro.over_time);
}

