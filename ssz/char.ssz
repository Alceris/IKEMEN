
lib file = <file.ssz>;
lib s = <string.ssz>;
lib sdl = <alpha/sdlplugin.ssz>;
lib consts = <consts.ssz>;
lib m = <math.ssz>;
lib se = <alpha/sdlevent.ssz>;
lib sff = "sff.ssz";
lib cmd = "command.ssz";
lib stage = "stage.ssz";
lib com = "common.ssz";
lib cfg = "config.ssz";
lib snd = "sound.ssz";
lib fgt = "fight.ssz";
lib act = "action.ssz";
lib mes = <alpha/mesdialog.ssz>;
lib fnt = "font.ssz";
lib al = <alert.ssz>;
lib tbl = <table.ssz>;


int changeStateNest = 0;
float oldx = 0.0;
int waitdown = 0, shuttertime = 0;
bool winskipped = false;

public float zoomdelay = 0.0;

|fgt.KOTy ko = fgt.KOTy::NotYet;
^|fgt.WinTy winty.new(2);
winty[0] = fgt.WinTy::N;
winty[1] = fgt.WinTy::N;

public ^&.stage.Stage stg;

%&act.DrawnClsn drawc1, drawc2, drawc2sp, drawwh;
void resetDrawnClsnList()
{
  .drawc1.new(0);
  .drawc2.new(0);
  .drawc2sp.new(0);
  .drawwh.new(0);
}
void drawClsn()
{
  ^ubyte pxl;
  pxl.new(1);
  pxl<> = 0x0;
  &.sff.Sprite spr.rct.set(0, 0, 0x1, 0x1);
  spr.colorPallet.new(256);
  spr.colorPallet<> = 0xff0000;
  spr.setPxl(pxl);
  loop{index i = 0; while; do:
    .drawc1[i].draw(spr=, (int)0x3feff);
    i++;
  while i < #.drawc1:
  }
  spr.colorPallet<> = 0x0000ff;
  loop{index i = 0; while; do:
    .drawc2[i].draw(spr=, (int)0x3feff);
    i++;
  while i < #.drawc2:
  }
  spr.colorPallet<> = 0x00ff00;
  loop{index i = 0; while; do:
    .drawc2sp[i].draw(spr=, (int)0x3feff);
    i++;
  while i < #.drawc2sp:
  }
  spr.colorPallet<> = 0x404040;
  loop{index i = 0; while; do:
    .drawwh[i].draw(spr=, (int)0x3feff);
    i++;
  while i < #.drawwh:
  }
}

&AnimList
{
  public ^&.act.Action anim;
  public int priority = 0;
  public float x = 0.0, y = 0.0, cscl = 1.0;
  public float xscl = 1.0, yscl = 1.0, angle = 0.0, axscl = 1.0, ayscl = 1.0;
  public bool aset = false, oVer = false;
  public short bright = 256;
  public int salpha = -1, dalpha = 0;
  public ^&.com.PalFX fx;
  public ^self next;
}

^&AnimList anims, topanims;

&ShadowList
{
  public ^&.AnimList al;
  public int color, alpha;
  public float offsety = 0.0;
  public ^self next;
}

^&ShadowList shadows;

public void addAnimList(
  ^&.AnimList al=, ^&.act.Action a, int p,
  float x, float y, float cs, float xs, float ys,
  float an, bool as, bool oVer, float ax, float ay,
  int sa, int da, int b, ^&.com.PalFX fx, int sc, int salp, float so)
{
  void newdainyuu(^&.AnimList anl=)
  {
    anl.new(1);
    anl~anim = `a;
    anl~priority = `p;
    anl~x = `x;
    anl~y = `y;
    anl~cscl = `cs;
    anl~xscl = `xs;
    anl~yscl = `ys;
    anl~angle = `an;
    anl~aset = `as;
    anl~oVer = `oVer;
    anl~bright = `b;
    anl~axscl = `ax;
    anl~ayscl = `ay;
    anl~salpha = `sa;
    anl~dalpha = `da;
    anl~fx = `fx;
    if(`sc != 0) .addShadowList(anl, `sc, `so, `salp);
  }
  ^&.AnimList tmp = al;
  branch{
  cond<a> #al == 0:
  cond<b> p <= al~priority:
  else:
    break;
  comm:
    newdainyuu(al=);
  diff<b>:
    al~next = tmp;
  comm:
    ret;
  }
  loop{while; do:
    if(p <= tmp~next~priority){
      ^&.AnimList tmp2 = tmp~next;
      newdainyuu(tmp~next=);
      tmp~next~next = tmp2;
      break, break;
    }
    tmp = tmp~next;
  while #tmp~next > 0:
    newdainyuu(tmp~next=);
  }
}

public void drawAnimList(^&.AnimList al=, float x, float y)
{
  loop{while; do:
    if(#al~anim > 0){
      al~anim~ani.salpha = al~salpha;
      al~anim~ani.dalpha = al~dalpha;
      branch{
        int ob = .com.brightness;
        .com.brightness = al~bright;
        float cs = al~cscl;
      cond al~angle != 0.0:
        al~anim~ani.angleDraw(
          .com.xoffset-(x-al~x)*cs, .com.zoffset+.com.yoffset-(y-al~y)*cs,
          cs*al~xscl, cs*al~yscl, al~angle*(.m.PI/180.0),
          al~aset, al~axscl, al~ayscl, al~fx, al~oVer);
      else:
        al~anim~ani.draw(
          .com.scrrect=, .com.xoffset/cs - (x-al~x),
          (.com.zoffset+.com.yoffset)/cs - (y-al~y), cs, cs, al~xscl, al~xscl,
          al~yscl, 0.0, (float).com.GameWidth/2.0, al~fx, al~oVer);
      break:
        .com.brightness = ob;
      }
    }
    al = al~next;
  while #al > 0:
  }
}

public void addShadowList(^&.AnimList al, int sc, float so, int alpha)
{
  void newdainyuu(^&.ShadowList shl=)
  {
    shl.new(1);
    shl~al = `al;
    shl~color = `sc;
    shl~alpha = .m.max!int?(0, .m.min!int?(256, `alpha));
    shl~offsety = `so * (`al~oVer ? 1.5 : 1.0);
  }
  int p = al~priority;
  ^&.ShadowList tmp = .shadows;
  branch{
  cond<a> #.shadows == 0:
  cond<b> p <= .shadows~al~priority:
  else:
    break;
  comm:
    newdainyuu(.shadows=);
  diff<b>:
    .shadows~next = tmp;
  comm:
    ret;
  }
  loop{while; do:
    if(p <= tmp~next~al~priority){
      ^&.ShadowList tmp2 = tmp~next;
      newdainyuu(tmp~next=);
      tmp~next~next = tmp2;
      break, break;
    }
    tmp = tmp~next;
  while #tmp~next > 0:
    newdainyuu(tmp~next=);
  }
}

public void drawShadowList(float x, float y)
{
  ^&.ShadowList sl = .shadows;
  ^uint pal, oldpal;
  loop{
    int intensity, color;
    while;
  do:
    if(#sl~al~anim == 0 || #sl~al~anim~ani.spr == 0) continue;
    intensity = .stg~sdw.intensity;
    color = sl~color;
    branch{
      int alpha = sl~alpha;
      branch{
      cond sl~al~y < (float).stg~sdw.fadeend:
        break, break, continue;
      cond sl~al~y < (float).stg~sdw.fadebgn:
        alpha =
          (int)(
            (float)alpha * ((float).stg~sdw.fadeend - sl~al~y)
            / ((float).stg~sdw.fadeend - (float).stg~sdw.fadebgn));
      }
    cond color < 0:
      color = (int).stg~sdw.color;
      if(alpha >= 255){
        pal = . stg~sdw.pal;
        break, break;
      }
      intensity = intensity * alpha >> 8;
    else:
      intensity = 0;
    comm:
      pal = .com.tmppl;
      loop{
        index i = 0;
        uint c =
          (uint)(
            ((color&255)*alpha>>8&255) | ((color&255<<8)*alpha>>8&255<<8)
            | ((color&255<<16)*alpha>>8)&255<<16)
          & 0xffffff;
      do:
        pal[i] = c;
      while ++i < 256:
      }
    }
    {
      oldpal = sl~al~anim~ani.spr~colorPallet;
      sl~al~anim~ani.spr~colorPallet = pal;
      float syscl = .stg~sdw.yscale;
      ~$void() draw = [void(){
        branch{
          float cs = sl~al~cscl;
        cond sl~al~angle != 0.0:
          {
            float agl = sl~al~angle*(.m.PI/180.0);
            float ss = syscl < 0.0 ? -1.0 : 1.0;//pow用
            sl~al~anim~ani.angleDraw(
              .com.xoffset-(x-sl~al~x)*cs,
              .com.zoffset + .com.yoffset - (y+sl~al~y*syscl-sl~offsety)*cs,
              cs*sl~al~xscl * #syscl**#.m.sin(agl),
              cs*-sl~al~yscl * ss * #syscl**#.m.cos(agl), agl, sl~al~aset,
              sl~al~axscl, sl~al~ayscl, .stage.bgPalFX, sl~al~oVer);
          }
        else:
          sl~al~anim~ani.draw(
            .com.scrrect=, .com.xoffset/cs - (x-sl~al~x),
            (.com.zoffset+.com.yoffset)/cs - (y+sl~al~y*syscl-sl~offsety),
            cs, cs, sl~al~xscl, sl~al~xscl, -sl~al~yscl*syscl, 0.0,
            (float).com.GameWidth/2.0, .stage.bgPalFX, sl~al~oVer);
        }
      }];
      if(color > 0){
        sl~al~anim~ani.salpha = 1;
        sl~al~anim~ani.dalpha = 255;
        draw(::);
      }
      if(intensity > 0){
        sl~al~anim~ani.salpha = 0;
        sl~al~anim~ani.dalpha = 255-intensity;
        draw(::);
      }
    break:
      sl~al~anim~ani.spr~colorPallet = oldpal;
    }
  continue:
    sl = sl~next;
  while #sl > 0:
  }
}

public void drawReflection(float x, float y)
{
  ^&.ShadowList sl = .shadows;
  loop{while; do:
    if(#sl~al~anim > 0 && #sl~al~anim~ani.frames > 0){
      if(sl~al~salpha < 0){
        sl~al~salpha =
          (int)
            sl~al~anim~ani.frames[sl~al~anim~ani.drawidx].salpha;
        sl~al~dalpha =
          (int)
            sl~al~anim~ani.frames[sl~al~anim~ani.drawidx].dalpha;
      }
      int refl = .stg~reflection*sl~alpha >> 8;
      sl~al~anim~ani.salpha = (int)((float)sl~al~salpha*(float)refl / 255.0);
      sl~al~anim~ani.dalpha = .m.min!int?(255, sl~al~dalpha + (255-refl));
      if(sl~al~anim~ani.salpha == 1 && sl~al~anim~ani.dalpha == 255){
        sl~al~anim~ani.salpha = 0;
      }
      branch{
        float cs = sl~al~cscl;
      cond sl~al~angle != 0.0:
        sl~al~anim~ani.angleDraw(
          .com.xoffset-(x-sl~al~x)*cs,
          .com.zoffset+.com.yoffset-(y+sl~al~y-sl~offsety)*cs,
          cs*sl~al~xscl, cs*-sl~al~yscl, sl~al~angle*(.m.PI/180.0),
          sl~al~aset, sl~al~axscl, sl~al~ayscl, sl~al~fx, sl~al~oVer);
      else:
        sl~al~anim~ani.draw(
          .com.scrrect=, .com.xoffset/cs - (x-sl~al~x),
          (.com.zoffset+.com.yoffset)/cs - (y+sl~al~y-sl~offsety),
          cs, cs, sl~al~xscl, sl~al~xscl, -sl~al~yscl, 0.0,
          (float).com.GameWidth/2.0, sl~al~fx, sl~al~oVer);
      }
    }
    sl = sl~next;
  while #sl > 0:
  }
}


&AfterImage
{
  &ImgInfo
  {
    public ^&.act.Action anim;
    public float x = 0.0, y = 0.0, xscl = 1.0, yscl = 1.0;
    public float angle = 0.0, axscl = 1.0, ayscl = 1.0;
    public bool aset = false, oVer = false;
    new()
    {
      `anim.new(1);
    }
  }
  public int time;
  public int length;
  public int postbrightr;
  public int postbrightg;
  public int postbrightb;
  public int addr;
  public int addg;
  public int addb;
  public float mulr;
  public float mulg;
  public float mulb;
  public int timegap;
  public int framegap;
  public int alphas;
  public int alphad;
  public ^&.com.PalFX palfx;
  public ^&ImgInfo imgs;
  public int imgidx;
  public int restgap;
  public int reccount;
  new()
  {
    `palfx.new(.cfg.AfterImageMax);
    loop{index i = 0; while; do:
      `palfx[i].time = -1;
      `palfx[i].negType = 1;
      i++;
    while i < #`palfx:}
    `clear();
    `timegap = 0;
    `imgs.new(64);
  }
  public void clear()
  {
    `time = 0;
    `length = 20;
    if(#`palfx > 0){
      `palfx~color = 1.0;
      `palfx~invertall = 0;
      `palfx~addr = 30;
      `palfx~addg = 30;
      `palfx~addb = 30;
      `palfx~mulr = 120;
      `palfx~mulg = 120;
      `palfx~mulb = 220;
    }
    `postbrightr = 0;
    `postbrightg = 0;
    `postbrightb = 0;
    `addr = 10;
    `addg = 10;
    `addb = 25;
    `mulr = 0.65;
    `mulg = 0.65;
    `mulb = 0.75;
    `timegap = 1;
    `framegap = 6;
    `alphas = -1;
    `alphad = 0;
    `imgidx = 0;
    `restgap = 0;
    `reccount = 0;
  }
  public void setPalcolor(int palcol)
  {
    if(#`palfx > 0){
      `palfx~color = (float)palcol / 256.0;
      .m.limRange!float?(`palfx~color=, 0.0, 1.0);
    }
  }
  public void setPalinvertall(bool palinv)
  {
    if(#`palfx > 0) `palfx~invertall = (int)palinv;
  }
  public void setPalbrightR(int palbrr)
  {
    if(#`palfx > 0) `palfx~addr = palbrr;
  }
  public void setPalbrightG(int palbrg)
  {
    if(#`palfx > 0) `palfx~addg = palbrg;
  }
  public void setPalbrightB(int palbrb)
  {
    if(#`palfx > 0) `palfx~addb = palbrb;
  }
  public void setPalcontrastR(int palcor)
  {
    if(#`palfx > 0) `palfx~mulr = palcor;
  }
  public void setPalcontrastG(int palcog)
  {
    if(#`palfx > 0) `palfx~mulg = palcog;
  }
  public void setPalcontrastB(int palcob)
  {
    if(#`palfx > 0) `palfx~mulb = palcob;
  }
  public void setupPalfx()
  {
    loop{
      index i = 1;
      int pbr = `postbrightr, pbg = `postbrightg, pbb = `postbrightb;
      while;
    do:
      `palfx[i].color = `palfx[i-1].color;
      `palfx[i].invertall = `palfx[i-1].invertall;
      `palfx[i].addr = `palfx[i-1].addr + `addr + pbr;
      `palfx[i].addg = `palfx[i-1].addg + `addg + pbg;
      `palfx[i].addb = `palfx[i-1].addb + `addb + pbb;
      pbr = pbg = pbb = 0;
      `palfx[i].mulr = (int)((float)`palfx[i-1].mulr * `mulr);
      `palfx[i].mulg = (int)((float)`palfx[i-1].mulg * `mulg);
      `palfx[i].mulb = (int)((float)`palfx[i-1].mulb * `mulb);
      i++;
    while i < #`palfx:
    }
  }
  public void recAfterImg(
    &.act.Action a=, float x, float y, float xs, float ys,
    float an, bool as, bool oVer, float ax, float ay)
  {
    if(`time == 0){
      `reccount = `timegap = 0;
      ret;
    }
    if(`time > 0) `time--;
    if(`restgap <= 0){
      `imgs[`imgidx].anim~copy(a=);
      `imgs[`imgidx].x = x;
      `imgs[`imgidx].y = y;
      `imgs[`imgidx].xscl = xs;
      `imgs[`imgidx].yscl = ys;
      `imgs[`imgidx].angle = an;
      `imgs[`imgidx].aset = as;
      `imgs[`imgidx].oVer = oVer;
      `imgs[`imgidx].axscl = ax;
      `imgs[`imgidx].ayscl = ay;
      `imgidx = `imgidx+1 & 63;
      if(`reccount < #`imgs) `reccount++;
      `restgap = `timegap;
    }
    `restgap--;
  }
  public void recAndAddAL(
    &.act.Action a=, int p,
    float x, float y, float xs, float ys,
    float an, bool as, bool oVer, float ax, float ay, bool rec, int br)
  {
    if(
      `time == 0 || !.m.inRange!int?(1, 32767, `timegap)
      || !.m.inRange!int?(1, 32767, `framegap))
    {
      `time = 0;
      `reccount = `timegap = 0;
      ret;
    }
    loop{
      index i = `framegap;
      index end = (.m.min!int?(`reccount, `length)/`framegap) * `framegap;
      .m.limMax!index?(end=, .cfg.AfterImageMax*`framegap);
      while;
    do:
      .addAnimList(
        .anims=, `imgs[`imgidx-i&63].anim, p-2,
        `imgs[`imgidx-i&63].x, `imgs[`imgidx-i&63].y, .com.scale,
        `imgs[`imgidx-i&63].xscl, `imgs[`imgidx-i&63].yscl,
        `imgs[`imgidx-i&63].angle, `imgs[`imgidx-i&63].aset,
        `imgs[`imgidx-i&63].oVer,
        `imgs[`imgidx-i&63].axscl, `imgs[`imgidx-i&63].ayscl,
        `alphas, `alphad, br, `palfx[i/`framegap - 1 .. i/`framegap],
        0, 0, 0.0);
      i += `framegap;
    while i <= end:
    }
    if(rec) `recAfterImg(a=, x, y, xs, ys, an, as, oVer, ax, ay);
  }
}


void pLrSet(float dl=, float dr=, float sl, float sr)
{
  dl = sl;
  dr = sr;
}
void mLrSet(float dl=, float dr=, float sl, float sr)
{
  dl = -sr;
  dr = -sl;
}

&ClsnHantei
{
  float xscl1, yscl1;
  float xofs1, yofs1;
  func$void(float=, float=, float, float) lrset1 = .pLrSet;
  float xscl2, yscl2;
  float xofs2, yofs2;
  func$void(float=, float=, float, float) lrset2 = .pLrSet;
  public void set(
    float xs1, float ys1, float xo1, float yo1, `lrset1.self lr1, 
    float xs2, float ys2, float xo2, float yo2, `lrset2.self lr2)
  {
    `xscl1 = xs1;
    `yscl1 = ys1;
    `xofs1 = xo1;
    `yofs1 = yo1;
    `lrset1 = lr1;
    `xscl2 = xs2;
    `yscl2 = ys2;
    `xofs2 = xo2;
    `yofs2 = yo2;
    `lrset2 = lr2;
  }
  /bool hantei(&.act.Rect c1, &.act.Rect c2)
  {
    float l1, r1, l2, r2;
    `lrset1(:l1=, r1=, (float)c1.l, (float)(c1.r+1):);
    `lrset2(:l2=, r2=, (float)c2.l, (float)(c2.r+1):);
    ret
      l1*`xscl1+`xofs1 <= r2*`xscl2+`xofs2
      && l2*`xscl2+`xofs2 <= r1*`xscl1+`xofs1
      && (float)(c1.t-1)*`yscl1+`yofs1 <= (float)c2.b*`yscl2+`yofs2
      && (float)(c2.t-1)*`yscl2+`yofs2 <= (float)c1.b*`yscl1+`yofs1;
  }
}


|VarTy
{
  Int, Float, SFalse
}
public &Var
{
  public |.VarTy typ = .VarTy::Int;
  public int i = 0;
  public float f = 0.0;
  public void setI(int i)
  {
    `typ = .VarTy::Int;
    `i = i;
  }
  public void setF(float f)
  {
    if(.m.isnan(f)){
      `setSF();
      ret;
    }
    `typ = .VarTy::Float;
    `f = f;
  }
  public void setB(bool b)
  {
    `typ = .VarTy::Int;
    `i = (int)b;
  }
  public void setSF()
  {
    `typ = .VarTy::SFalse;
  }
  /bool isT()
  {
    if(`isSF()) ret false;
    ret `typ == .VarTy::Int ? `i != 0 : `f != 0.0;
  }
  /bool isSF()
  {
    ret `typ == .VarTy::SFalse;
  }
  /int toI()
  {
    if(`isSF()) ret 0;
    ret `typ == .VarTy::Int ? `i : (int)`f;
  }
  /double toF()
  {
    if(`isSF()) ret 0.0;
    ret `typ == .VarTy::Int ? (double)`i : `f;
  }
}
public &Var v;//work
public ^&Char c;//work
type _t = $void(&Char=);
void rd(~$void(&.Char=) f)
{
  if(#.c == 0){
    .v.setSF();
    ret;
  }
  f(:.c<>=:);
}

public void appendClipboardText(int p, ^/char text)
{
  .com.clipboardText[p].[void(cb=){
    loop{
      index i = 0;
      if(#cb == 0) cb.new(1);
      ^%char line = cb[#cb-1..-1];
      int w = .fnt.debugFont~textWidth(line<>);
      ~$void(char) appendChar = [void(char c){
        w += .fnt.debugFont~charWidth(c) + .fnt.debugFont~spacingx;
        if(w > .cfg.Width){
          w = .fnt.debugFont~charWidth(c) + .fnt.debugFont~spacingx;
          cb.new[-1];
          line = cb[#cb-1..-1];
        }
        line<> .= c;
      }];
      while;
    do:
      switch(text[i]){
      case '\n':
        cb.new[-1];
        line = cb[#cb-1..-1];
        w = 0;
      case '\t':
        loop{index j = 0, n = 8 - #line<>%8; do:
          line<> .= ' ';
          w += .fnt.debugFont~sizex + .fnt.debugFont~spacingx;
          j++;
        while j < n:}
      default:
        appendChar(:text[i]:);
      }
      i++;
    while i < #text:}
    if(#cb > 10){
      ^%char tmp = cb[#cb-10..-1];
      cb.new(0);
      cb .= tmp;
    }
  }];
}

void appendToClipboard(int p, ^/char formatText, ^&.Var vars)
{
  &.s.Format fm.set(formatText);
  loop{index j = 0; while; do:
    branch{
    cond vars[j].typ == .VarTy::Float:
      fm.f(vars[j].toF());
    else:
      fm.d(vars[j].toI());
    }
    j++;
  while j < #vars:}
  ^/char tmp = .s.join(\n, .s.split("\n", fm.out));
  tmp = .s.join(\t, .s.split("\t", tmp));
  tmp = .s.join(\\, .s.split("\\", tmp));
  .appendClipboardText(p, tmp);
}

|StTy
{
  S=0x1, C=0x2, A=0x4, L=0x8, N=0x10, U=0x20//L->D N->F U->P
}
|AtTy
{
  NA=   0x40, NT=   0x80, NP=  0x100,
  SA=  0x200, ST=  0x400, SP=  0x800,
  HA= 0x1000, HT= 0x2000, HP= 0x4000
}
|MovTy
{
  I=0x8000, A, H=0x10000, U//I->- H->+
}
|AnimTy
{
  Light, Medium, Hard, Back, Up, Diagup, Unknown
}
|PriTy
{
  Hit, Miss, Dodge
}
|ReactTy
{
  Non, High, Low, Trip, Unknown
}
&Fall
{
  public |.AnimTy animtype;
  public float xvelocity;
  public float yvelocity;
  public int recover;
  public int recovertime;
  public int damage;
  public int kill;
  public int envshake_time;
  public float envshake_freq;
  public int envshake_ampl;
  public float envshake_phase;
  public void clear()
  {
    `animtype = .AnimTy::Unknown;
    `xvelocity = 0.0/0.0;
    `yvelocity = -4.5;
    `recover = 0;
    `recovertime = 0;
    `damage = 0;
    `kill = 0;
    `envshake_time = 0;
    `envshake_freq = 0.0;
    `envshake_ampl = 0;
    `envshake_phase = 0.0;
  }
  public void setDefault()
  {
    `animtype = .AnimTy::Unknown;
    `xvelocity = 0.0/0.0;
    `yvelocity = -4.5;
    `recover = 1;
    `recovertime = 4;
    `damage = 0;
    `kill = 1;
    `envshake_time = 0;
    `envshake_freq = 60.0;
    `envshake_ampl = -4;
    `envshake_phase = 0.0/0.0;
  }
}
&Hitdef
{
  public int attr;
  public int reversal_attr;
  public int hitflag;
  public int guardflag;
  public int affectteam;
  public |.AnimTy animtype;
  public |.AnimTy air_animtype;
  public int priority;
  public |.PriTy bothhittype;
  public int hitdamage;
  public int guarddamage;
  public int pausetime;
  public int shaketime;
  public int guard_pausetime;
  public int guard_shaketime;
  public int sparkno;
  public int guard_sparkno;
  public float sparkx;
  public float sparky;
  public int hitsoundg;
  public int hitsoundn;
  public int guardsoundg;
  public int guardsoundn;
  public |.ReactTy ground_type;
  public |.ReactTy air_type;
  public int ground_slidetime;
  public int guard_slidetime;
  public int ground_hittime;
  public int guard_hittime;
  public int air_hittime;
  public int guard_ctrltime;
  public int airguard_ctrltime;
  public int guard_dist;
  public float yaccel;
  public float ground_velocityx;
  public float ground_velocityy;
  public float guard_velocity;
  public float air_velocityx;
  public float air_velocityy;
  public float airguard_velocityx;
  public float airguard_velocityy;
  public float ground_cornerpush_veloff;
  public float air_cornerpush_veloff;
  public float down_cornerpush_veloff;
  public float guard_cornerpush_veloff;
  public float airguard_cornerpush_veloff;
  public int air_juggle;
  public int p1sprpriority;
  public int p2sprpriority;
  public int p1getp2facing;
  public int p1facing;
  public int p2facing;
  public int p1stateno;
  public int p2stateno;
  public int p2getp1state;
  public int forcestand;
  public int ground_fall;
  public int air_fall;
  public float down_velocityx;
  public float down_velocityy;
  public int down_hittime;
  public int down_bounce;
  public int id;
  public int chainid;
  public int nochainid1;
  public int nochainid2;
  public int hitonce;
  public int kill;
  public int guard_kill;
  public int numhits;
  public int hitgetpower;
  public int guardgetpower;
  public int hitgivepower;
  public int guardgivepower;
  public int palfx_time;
  public int palfx_mulr;
  public int palfx_mulg;
  public int palfx_mulb;
  public int palfx_addr;
  public int palfx_addg;
  public int palfx_addb;
  public int palfx_amplr;
  public int palfx_amplg;
  public int palfx_amplb;
  public int palfx_cycletime;
  public int palfx_color;
  public int palfx_invertall;
  public int envshake_time;
  public float envshake_freq;
  public int envshake_ampl;
  public float envshake_phase;
  public float mindistx;
  public float maxdistx;
  public float mindisty;
  public float maxdisty;
  public float snapx;
  public float snapy;
  public float snapz;
  public int snapt;
  public int forcenofall;
  public &.Fall fall;
  public int player;
  public void clear()
  {
    `attr = 0;
    `reversal_attr = 0;
    `hitflag = (int).StTy::S | (int).StTy::C | (int).StTy::A | (int).StTy::N;
    `guardflag = 0;
    `affectteam = 1;
    `animtype = .AnimTy::Light;
    `air_animtype = .AnimTy::Unknown;
    `priority = 4;
    `bothhittype = .PriTy::Hit;
    `hitdamage = 0;
    `guarddamage = 0;
    `pausetime = 0;
    `shaketime = 0;
    `guard_pausetime = -1;
    `guard_shaketime = -1;
    `sparkno = .com.IERR;
    `guard_sparkno = .com.IERR;
    `sparkx = 0.0;
    `sparky = 0.0;
    `hitsoundg = .com.IERR;
    `hitsoundn = -1;
    `guardsoundg = .com.IERR;
    `guardsoundn = -1;
    `ground_type = .ReactTy::High;
    `air_type = .ReactTy::Unknown;
    `ground_slidetime = 0;
    `guard_slidetime = -1;
    `ground_hittime = 0;
    `guard_hittime = -1;
    `air_hittime = 20;
    `guard_ctrltime = -1;
    `airguard_ctrltime = -1;
    `guard_dist = -1;
    `yaccel = 0.0/0.0;
    `ground_velocityx = 0.0;
    `ground_velocityy = 0.0;
    `guard_velocity = 0.0/0.0;
    `air_velocityx = 0.0;
    `air_velocityy = 0.0;
    `airguard_velocityx = 0.0/0.0;
    `airguard_velocityy = 0.0/0.0;
    `ground_cornerpush_veloff = 0.0/0.0;
    `air_cornerpush_veloff = 0.0/0.0;
    `down_cornerpush_veloff = 0.0/0.0;
    `guard_cornerpush_veloff = 0.0/0.0;
    `airguard_cornerpush_veloff = 0.0/0.0;
    `air_juggle = 0;
    `p1sprpriority = 1;
    `p2sprpriority = 0;
    `p1getp2facing = 0;
    `p1facing = 0;
    `p2facing = 0;
    `p1stateno = -1;
    `p2stateno = -1;
    `p2getp1state = 1;
    `forcestand = .com.IERR;
    `ground_fall = 0;
    `air_fall = .com.IERR;
    `down_velocityx = 0.0/0.0;
    `down_velocityy = -4.5;
    `down_hittime = 0;
    `down_bounce = 0;
    `id = 0;
    `chainid = -1;
    `nochainid1 = -1;
    `nochainid2 = -1;
    `hitonce = 0;
    `kill = 1;
    `guard_kill = 1;
    `numhits = 1;
    `hitgetpower = .com.IERR;
    `guardgetpower = .com.IERR;
    `hitgivepower = .com.IERR;
    `guardgivepower = .com.IERR;
    `palfx_time = 0;
    `palfx_mulr = 256;
    `palfx_mulg = 256;
    `palfx_mulb = 256;
    `palfx_addr = 0;
    `palfx_addg = 0;
    `palfx_addb = 0;
    `palfx_amplr = 0;
    `palfx_amplg = 0;
    `palfx_amplb = 0;
    `palfx_cycletime = 0;
    `palfx_color = 256;
    `palfx_invertall = 0;
    `envshake_time = 0;
    `envshake_freq = 60.0;
    `envshake_ampl = -4;
    `envshake_phase = 0.0/0.0;
    `mindistx = 0.0/0.0;
    `maxdistx = 0.0/0.0;
    `mindisty = 0.0/0.0;
    `maxdisty = 0.0/0.0;
    `snapx = 0.0;
    `snapy = 0.0/0.0;
    `snapz = 0.0;
    `snapt = 0;
    `forcenofall = 0;
    `fall.setDefault();
    `player = -1;
  }
  public void invalidate()
  {
    `attr |= (int)0x80000000;
    `reversal_attr |= (int)0x80000000;
  }
}
&HitBy
{
  public &ByData
  {
    public int id;
    public int juggle;
    public void set(int id, int juggle)
    {
      `id = id;
      `juggle = juggle;
    }
  }
  public %&ByData by;
  public int hitf1;
  public int hitt1;
  public int hitf2;
  public int hitt2;
  public int attr;
  public int typ;
  public int airanimtype;
  public int groundanimtype;
  public int airtype;
  public int groundtype;
  public int damage;
  public int absdamage;
  public int hitcount;
  public int fallcount;
  public int hitshaketime;
  public int hittime;
  public int slidetime;
  public int ctrltime;
  public float xvel;
  public float yvel;
  public float yaccel;
  public int hitid;
  public int guarded;
  public int fallf;
  public int p1getp2facing;
  public float mindistx;
  public float maxdistx;
  public float mindisty;
  public float maxdisty;
  public float snapx;
  public float snapy;
  public float snapz;
  public int snapt;
  public &.Fall fall;
  public void clear()
  {
    `by.new(0);
    `hitf1 = 0;
    `hitt1 = 0;
    `hitf2 = 0;
    `hitt2 = 0;
    `attr = 0;
    `typ = -1;
    `airanimtype = 0;
    `groundanimtype = 0;
    `airtype = 0;
    `groundtype = 0;
    `damage = 0;
    `absdamage = 0;
    `hitcount = 0;
    `fallcount = 0;
    `hitshaketime = 0;
    `hittime = -1;
    `slidetime = 0;
    `ctrltime = 0;
    `xvel = 0.0;
    `yvel = 0.0;
    `yaccel = 0.0/0.0;
    `hitid = -1;
    `guarded = 0;
    `fallf = 0;
    `p1getp2facing = 0;
    `mindistx = 0.0/0.0;
    `maxdistx = 0.0/0.0;
    `mindisty = 0.0/0.0;
    `maxdisty = 0.0/0.0;
    `snapx = 0.0;
    `snapy = 0.0/0.0;
    `snapz = 0.0;
    `snapt = 0;
    `fall.clear();
  }
  /float getYaccel()
  {
    ret .m.isnan(`yaccel) ? 0.35 : `yaccel;
  }
  /bool byidMatch(int id)
  {
    loop{index i = 0; while; do:
      if(`by[i].id == id) ret true;
      i++;
    while i < #`by:
    }
    ret false;
  }
  /int getJuggle(int id, int defval)
  {
    loop{index i = 0; while; do:
      if(`by[i].id == id) ret `by[i].juggle;
      i++;
    while i < #`by:
    }
    ret defval;
  }
  public void dropByid(int id)
  {
    loop{index i = 0; while; do:
      if(`by[i].id == id){
        %&`ByData tmp .= `by[0..i] .= `by[i+1..-1];
        `by = tmp;
        ret ;
      }
      i++;
    while i < #`by:
    }
  }
  public void addByid(int id, int juggle)
  {
    int jgl = `getJuggle(id, juggle);
    `dropByid(id);
    `by.new[-1].set(id, jgl);
  }
}
&HitOverride
{
  public int attr;
  public int stateno;
  public int time;
  public int forceair;
  public int player;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `attr = 0;
    `stateno = -1;
    `time = 0;
    `forceair = 0;
    `player = -1;
  }
}
|MoveContact
{
  Hit, Guarded, Reversed
}
|ProjContact
{
  Hit, Guarded, Cancel
}
&Persistent
{
  public int p = 0;
}
&StateVal
{
  public ^&.Persistent ps;
  public int no, prevno;
  public short playerno, hitdefContact;
  public int time;
  public |.StTy typ;
  public |.StTy phy;
  public |.MovTy mov;
  public int juggle;
  public &.Hitdef hit;
  public &.HitBy hb;
  public ^&.HitOverride ho;
  public |.MoveContact mctyp;
  public int mctime;
  public int fallTime;
  new()
  {
    `ho.new(8);
    `clear();
  }
  public void clear()
  {
    `ps.new(0);
    `no = 0;
    `prevno = 0;
    `playerno = 0;
    `hitdefContact = 0;
    `time = 0;
    `typ = .StTy::S;
    `phy = .StTy::N;
    `mov = .MovTy::I;
    `hit.clear();
    `hb.clear();
    loop{index i=0;do:`ho[i].clear();while ++i<#`ho:}
    `mctyp = .MoveContact::Hit;
    `mctime = 0;
    `fallTime = 0;
  }
  public int hitCheck(&.Hitdef hit=, bool guard)
  {
    ret
      (guard && ((int)`typ&hit.guardflag) != 0 ? 2 : 1) * (
        (int)(`typ == .StTy::A ? hit.air_type : hit.ground_type) == 0
        || hit.reversal_attr > 0
        ? -1 : 1);
  }
  public int setHb(&.Hitdef hit=, bool guard, bool combo)
  {
    bool cmb = combo && `hb.guarded == 0;
    int fall = `hb.fallf, hc = `hb.hitcount, fc = `hb.fallcount;
    %&`hb.ByData bi = `hb.by;
    `hb.clear();
    `hb.by = bi;
    `hb.attr = hit.attr;
    `hb.hitid = hit.id;
    `hb.fall = hit.fall;
    `fallTime = 0;
    `hb.yaccel = hit.yaccel;
    `hb.p1getp2facing = hit.p1getp2facing;
    `hb.mindistx = hit.mindistx;
    `hb.maxdistx = hit.maxdistx;
    `hb.mindisty = hit.mindisty;
    `hb.maxdisty = hit.maxdisty;
    `hb.snapx = hit.snapx;
    `hb.snapy = hit.snapy;
    `hb.snapz = hit.snapz;
    `hb.snapt = hit.snapt;
    if(hit.forcenofall != 0) fall = 0;
    branch{
    cond `typ == .StTy::A:
      `hb.airtype = `hb.typ = (int)hit.air_type;
    else:
      `hb.groundtype = `hb.typ = (int)hit.ground_type;
    }
    `hb.airanimtype = (int)hit.air_animtype;
    `hb.groundanimtype = (int)hit.animtype;
    if(guard && ((int)`typ&hit.guardflag) != 0){
      `hb.hitshaketime = .m.max!int?(0, hit.guard_shaketime);
      `hb.hittime = .m.max!int?(0, hit.guard_hittime);
      `hb.slidetime = hit.guard_slidetime;
      `hb.guarded = 1;
      branch{
      cond `typ == .StTy::A:
        `hb.ctrltime = hit.airguard_ctrltime;
        `hb.xvel = hit.airguard_velocityx;
        `hb.yvel = hit.airguard_velocityy;
      else:
        `hb.ctrltime = hit.guard_ctrltime;
        `hb.xvel = hit.guard_velocity;
        `hb.yvel = hit.ground_velocityy;
      }
      `hb.absdamage = hit.guarddamage;
      `hb.hitcount = hc;
      ret 2 * (`hb.typ == 0 || hit.reversal_attr > 0 ? -1 : 1);
    }
    `hb.hitshaketime = .m.max!int?(0, hit.shaketime);
    `hb.slidetime = hit.ground_slidetime;
    branch{
    cond `typ == .StTy::A:
      `hb.hittime = hit.air_hittime;
      `hb.ctrltime = hit.air_hittime;
      `hb.xvel = hit.air_velocityx;
      `hb.yvel = hit.air_velocityy;
      `hb.fallf = hit.air_fall;
    cond `typ == .StTy::L:
      `hb.hittime = hit.down_hittime;
      `hb.ctrltime = hit.down_hittime;
      `hb.xvel = hit.down_velocityx;
      `hb.yvel = hit.down_velocityy;
      if(hit.down_bounce == 0){
        `hb.fall.xvelocity = 0.0/0.0;
        `hb.fall.yvelocity = 0.0;
      }
    else:
      `hb.hittime = hit.ground_hittime;
      `hb.ctrltime = hit.ground_hittime;
      `hb.xvel = hit.ground_velocityx;
      `hb.yvel = hit.ground_velocityy;
      `hb.fallf = hit.ground_fall;
    }
    if(`hb.hittime < 0) `hb.hittime = 0;
    `hb.absdamage = hit.hitdamage;
    `hb.hitcount = cmb ? hc+1 : 1;
    `hb.fallcount = fc;
    `hb.fallf |= fall;
    ret 1 * (`hb.typ == 0 || hit.reversal_attr > 0 ? -1 : 1);
  }
}
const index iLIFE              = 10;
const index iLIFEMAX           = 11;
const index iLIFEMAX2          = 12;
const index iPOWER             = 13;
const index iPOWERMAX          = 14;
const index iPOWERMAX2         = 15;
const index iATTACK            = 16;
const index iDEFENCE           = 17;
const index iLIEDOWN_TIME      = 18;
const index iAIRJUGGLE         = 19;
const index iSPARKNO           = 20;
const index iGUARD_SPARKNO     = 21;
const index iKO_ECHO           = 22;
const index iVOLUME            = 23;
const index iINTPERSISTINDEX   = 24;
const index iFLOATPERSISTINDEX = 25;
const index iGROUND_BACK       = 26;
const index iGROUND_FRONT      = 27;
const index iAIR_BACK          = 28;
const index iAIR_FRONT         = 29;
const index iHEIGHT            = 30;
const index iATTACK_DIST       = 31;
const index iPROJ_ATTACK_DIST  = 32;
const index iPROJ_DOSCALE      = 33;
const index iHEAD_POSX         = 34;
const index iHEAD_POSY         = 35;
const index iMID_POSX          = 36;
const index iMID_POSY          = 37;
const index iSHADOWOFFSET      = 38;
const index iDRAW_OFFSETX      = 39;
const index iDRAW_OFFSETY      = 40;
const index iAIRJUMP_CNT       = 41;
const index iAIRJUMP_NUM       = 42;
const index iAIRJUMP_HEIGHT    = 43;
const index iHITCOUNT          = 44;
const index iUNIQHITCOUNT      = 45;
const index iPAUSEMOVETIME     = 46;
const index iSUPERMOVETIME     = 47;
const index iBINDTIME          = 48;
const index iBINDTOID          = 49;
const index iBINDFACING        = 50;
const index iHITPAUSETIME      = 51;
const index iALPHAS            = 52;
const index iALPHAD            = 53;
const index iRECOVERTIME       = 54;
const index iSPECIALFLAG       = 55;
const index iSYSFLAG           = 56;
const index iZ_WIDTH              = 57;
const index iATTACK_Z_WIDTH_FRONT = 58;
const index iATTACK_Z_WIDTH_BACK  = 59;

const index fX                = 10;
const index fY                = 11;
const index fVX               = 12;
const index fVY               = 13;
const index fFALL_DEFENCE_MUL = 14;
const index fXSCALE           = 15;
const index fYSCALE           = 16;
const index fWALK_FWD         = 17;
const index fWALK_BACK        = 18;
const index fRUN_FWDX         = 19;
const index fRUN_FWDY         = 20;
const index fRUN_BACKX        = 21;
const index fRUN_BACKY        = 22;
const index fJUMP_NEUX        = 23;
const index fJUMP_NEUY        = 24;
const index fJUMP_BACK        = 25;
const index fJUMP_FWD         = 26;
const index fRUNJUMP_BACKX    = 27;
const index fRUNJUMP_BACKY    = 28;
const index fRUNJUMP_FWDX     = 29;
const index fRUNJUMP_FWDY     = 30;
const index fAIRJUMP_NEUX     = 31;
const index fAIRJUMP_NEUY     = 32;
const index fAIRJUMP_BACK     = 33;
const index fAIRJUMP_FWD      = 34;
const index fYACCEL           = 35;
const index fSTAND_FRICTION   = 36;
const index fCROUCH_FRICTION  = 37;
const index fBINDPOSX         = 38;
const index fBINDPOSY         = 39;
const index fANGLE            = 40;
const index fANGLESCALEX      = 41;
const index fANGLESCALEY      = 42;
const index fCLSNXSCALE       = 43;
const index fCLSNYSCALE       = 44;
const index fAIR_GETHIT_GROUNDRECOVERX                 = 45;
const index fAIR_GETHIT_GROUNDRECOVERY                 = 46;
const index fAIR_GETHIT_AIRRECOVER_MULX                = 47;
const index fAIR_GETHIT_AIRRECOVER_MULY                = 48;
const index fAIR_GETHIT_AIRRECOVER_ADDX                = 49;
const index fAIR_GETHIT_AIRRECOVER_ADDY                = 50;
const index fAIR_GETHIT_AIRRECOVER_BACK                = 51;
const index fAIR_GETHIT_AIRRECOVER_FWD                 = 52;
const index fAIR_GETHIT_AIRRECOVER_UP                  = 53;
const index fAIR_GETHIT_AIRRECOVER_DOWN                = 54;
const index fSTAND_FRICTION_THRESHOLD                  = 55;
const index fCROUCH_FRICTION_THRESHOLD                 = 56;
const index fAIR_GETHIT_GROUNDLEVEL                    = 57;
const index fAIR_GETHIT_GROUNDRECOVER_GROUND_THRESHOLD = 58;
const index fAIR_GETHIT_GROUNDRECOVER_GROUNDLEVEL      = 59;
const index fAIR_GETHIT_AIRRECOVER_THRESHOLD           = 60;
const index fAIR_GETHIT_AIRRECOVER_YACCEL              = 61;
const index fAIR_GETHIT_TRIP_GROUNDLEVEL               = 62;
const index fDOWN_BOUNCE_OFFSETX                       = 63;
const index fDOWN_BOUNCE_OFFSETY                       = 64;
const index fDOWN_BOUNCE_YACCEL                        = 65;
const index fDOWN_BOUNCE_GROUNDLEVEL                   = 66;
const index fDOWN_FRICTION_THRESHOLD                   = 67;
const index fWALK_UP_X                                 = 68;
const index fWALK_DOWN_X                               = 69;
const index fRUN_UP_X                                  = 70;
const index fRUN_UP_Y                                  = 71;
const index fRUN_DOWN_X                                = 72;
const index fRUN_DOWN_Y                                = 73;
const index fJUMP_UP_X                                 = 74;
const index fJUMP_DOWN_X                               = 75;
const index fRUNJUMP_UP_X                              = 76;
const index fRUNJUMP_DOWN_X                            = 77;
const index fAIRJUMP_UP_X                              = 78;
const index fAIRJUMP_DOWN_X                            = 79;


const int lsINVISIBLE     = 0b00000000000000000000000000000001;
const int lsNOSTANDGUARD  = 0b00000000000000000000000000000010;
const int lsNOCROUCHGUARD = 0b00000000000000000000000000000100;
const int lsNOAIRGUARD    = 0b00000000000000000000000000001000;
const int lsNOAUTOTURN    = 0b00000000000000000000000000010000;
const int lsNOJUGGLECHECK = 0b00000000000000000000000000100000;
const int lsNOSHADOW      = 0b00000000000000000000000001000000;
const int lsNOWALK        = 0b00000000000000000000000010000000;
const int lsUNGUARDABLE   = 0b00000000000000000000000100000000;
const int lsPOSFREEZEX    = 0b00000000000000000000001000000000;
const int lsPOSFREEZEY    = 0b00000000000000000000010000000000;
const int lsPLAYERPUSH    = 0b00000000000000000000100000000000;
const int lsSCREENBOUND   = 0b00000000000000000001000000000000;
const int lsMOVECAMERAX   = 0b00000000000000000010000000000000;
const int lsMOVECAMERAY   = 0b00000000000000000100000000000000;
const int lsGETHIT        = 0b00000000000000001000000000000000;
const int lsANGLEDRAW     = 0b00000000000000010000000000000000;
const int lsTRANS         = 0b00000000000000100000000000000000;
const int lsFRONTWCHANGE  = 0b00000000000001000000000000000000;
const int lsBACKWCHANGE   = 0b00000000000010000000000000000000;
const int lsFEDGECHANGE   = 0b00000000000100000000000000000000;
const int lsBEDGECHANGE   = 0b00000000001000000000000000000000;
const int lsGUARD         = 0b00000000010000000000000000000000;

const int lasMask =
  lsNOAUTOTURN | lsNOWALK | lsNOSTANDGUARD | lsNOCROUCHGUARD | lsNOAIRGUARD
  | lsNOSHADOW | lsINVISIBLE | lsUNGUARDABLE | lsNOJUGGLECHECK | lsANGLEDRAW;

public uint specialFlag;
const uint gsINTRO          = 0b00000000000000000000000000000001;
const uint gsROUNDNOTOVER   = 0b00000000000000000000000000000010;
const uint gsNOBARDISPLAY   = 0b00000000000000000000000000000100;
const uint gsNOBG           = 0b00000000000000000000000000001000;
const uint gsNOFG           = 0b00000000000000000000000000010000;
const uint gsNOKOSLOW       = 0b00000000000000000000000000100000;
const uint gsGLOBALNOSHADOW = 0b00000000000000000000000001000000;
const uint gsNOMUSIC        = 0b00000000000000000000000010000000;
const uint gsTIMERFREEZE    = 0b00000000000000000000000100000000;
const uint gsNOKO           = 0b00000000000000000000001000000000;
const uint gsNOKOSND        = 0b00000000000000000000010000000000;
public bool gs(uint mask)
{
  ret (.specialFlag & mask) == mask;
}

const int sfAIRJUMP         = 0b00000000000000000000000000000001;
const int sfOVER            = 0b00000000000000000000000000000010;
const int sfKO              = 0b00000000000000000000000000000100;
const int sfKO_ROUND_MIDDLE = 0b00000000000000000000000000001000;

&PlayerList<_t>
{
  &Node<_t>
  {
    public ^_t c;
    public ^self next;
  }
  ^&Node!_t? top, end;
  public void clear()
  {
    `top.new(0);
    `end.new(0);
  }
}

public ^%^&Char chars.new(4);
/^%&Projectile projs.new(#chars);
/^%&Explod explods.new(#chars);
^&.tbl.IntTable!int, &Char::State? states.new(#chars);


^%index expdrawlist.new(#.chars), topexpdrawlist.new(#.chars);

void delIL(%index l=, index i)
{
  ^index l1 = l[0..i], l2 = l[i+1..-1];
  l.new(0);
  l .= l1 .= l2;
}

void insIL(%index l=, index i, index x)
{
  ^index l1 = l[0..i], l2 = l[i..-1];
  l.new(0);
  l .= l1 .= x .= l2;
}

&RdCacheInfo
{
  public int n, pn, hi;
}
%&RdCacheInfo playerid;
^int numenemy.new(#.chars);
void resetNumenemy()
{
  loop{index i = 0; do: .numenemy[i] = -1; while ++i < #.numenemy:}
}
resetNumenemy();

public ^&.fgt.Fight fight;
public bool roundEnd()
{
  ret .com.intro < -.fight~ro.over_hittime;
}


public &PlayerList!&Char? players;
public int id = cfg.HelperMax;
/int pause = 0, pausetime = 0, pausebg = 0;
/int super = 0, supertime = 0, superpausebg = 0;
int pauseplayer = -1, superplayer = -1;
^&.act.Action superanim;
float superposx = 0.0, superposy = 0.0;
int superfacing = 1;
int superdarken = 1;
float superp2defmul = 1.0;
int superunhittable = 1;
/int envcol_time = 0;
/int envcol_under = 0;
int envcol_r = 255;
int envcol_g = 255;
int envcol_b = 255;

&ModifyExplod
{
  public int id;
  public int bindtime;
  public float scalex;
  public float scaley;
  public int removeongethit;
  public int removetime;
  public float velocityx;
  public float velocityy;
  public float accelx;
  public float accely;
  public int sprpriority;
  public int postype;
  public float offsetx;
  public float offsety;
  public int relativef;
  public float x;
  public float y;
  public int facing;
  public int vfacing;
  public int shadowr;
  public int shadowg;
  public int shadowb;
  public int ontop;
  public int alphas;
  public int alphad;
  public int supermovetime;
  public int pausemovetime;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `id = -1;
    `bindtime = .com.IERR;
    `scalex = 0.0/0.0;
    `scaley = 0.0/0.0;
    `removeongethit = .com.IERR;
    `removetime = .com.IERR;
    `velocityx = 0.0/0.0;
    `velocityy = 0.0/0.0;
    `accelx = 0.0/0.0;
    `accely = 0.0/0.0;
    `sprpriority = .com.IERR;
    `postype = .com.IERR;
    `offsetx = 0.0/0.0;
    `offsety = 0.0/0.0;
    `relativef = .com.IERR;
    `x = 0.0/0.0;
    `y = 0.0/0.0;
    `facing = .com.IERR;
    `vfacing = .com.IERR;
    `shadowr = .com.IERR;
    `shadowg = .com.IERR;
    `shadowb = .com.IERR;
    `ontop = .com.IERR;
    `alphas = .com.IERR;
    `alphad = .com.IERR;
    `supermovetime = .com.IERR;
    `pausemovetime = .com.IERR;
  }
  public void setX(float x)
  {
    `x = x;
  }
  public void setY(float y)
  {
    `y = y;
  }
}
public &Explod
{
  public int id;
  public int bindtime;
  public float scalex;
  public float scaley;
  public int time;
  public int removeongethit;
  public int removetime;
  public float velocityx;
  public float velocityy;
  public float accelx;
  public float accely;
  public int sprpriority;
  public int postype;
  public float offsetx;
  public float offsety;
  public int relativef;
  public float x;
  public float y;
  public int facing;
  public int vfacing;
  public int shadowr;
  public int shadowg;
  public int shadowb;
  public int supermovetime;
  public int pausemovetime;
  public ^&.act.Action ani;
  public int ontop;
  public int alphas;
  public int alphad;
  public int ownpal;
  public int player;
  public int bindid;
  public int ignorehitpause;
  public float ticOldX, ticNewX;
  public float ticOldY, ticNewY;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `id = .com.IERR;
    `bindtime = 0;
    `scalex = 1.0;
    `scaley = 1.0;
    `time = 0;
    `removeongethit = 0;
    `removetime = -2;
    `velocityx = 0.0;
    `velocityy = 0.0;
    `accelx = 0.0;
    `accely = 0.0;
    `sprpriority = 0;
    `postype = 0;
    `offsetx = 0.0;
    `offsety = 0.0;
    `relativef = 1;
    `x = 0.0;
    `y = 0.0;
    `facing = 1;
    `vfacing = 1;
    `shadowr = 0;
    `shadowg = 0;
    `shadowb = 0;
    `supermovetime = 0;
    `pausemovetime = 0;
    `ani.new(0);
    `ontop = 0;
    `alphas = .com.IERR;
    `alphad = .com.IERR;
    `ownpal = 0;
    `player = -1;
    `bindid = -1;
    `ignorehitpause = 1;
    `ticOldX = `ticNewX = `x;
    `ticOldY = `ticNewY = `y;
  }
  public void setFacing(int f)
  {
    if(f == 0) ret;
    if((`facing < 0) != (f < 0)){
      `facing *= -1;
      `velocityx *= -1.0;
    }
  }
  public void setX(float x)
  {
    `x = `ticOldX = `ticNewX = x;
  }
  public void setY(float y)
  {
    `y = `ticOldY = `ticNewY = y;
  }
}
public &Projectile
{
  public &.Hitdef hit;
  public int id;
  public int anim;
  public int hitanim;
  public int remanim;
  public int cancelanim;
  public float scalex;
  public float scaley;
  public int remove;
  public int removetime;
  public float velocityx;
  public float velocityy;
  public float remvelocityx;
  public float remvelocityy;
  public float accelx;
  public float accely;
  public float velmulx;
  public float velmuly;
  public int hits;
  public int misstime;
  public int priority;
  public int prioritypoint;
  public int sprpriority;
  public int edgebound;
  public int stagebound;
  public int heightboundt;
  public int heightboundb;
  public float x;
  public float y;
  public int facing;
  public int shadowr;
  public int shadowg;
  public int shadowb;
  public int supermovetime;
  public int pausemovetime;
  public ^&.act.Action ani;
  public int timemiss, hitpause, playerno;
  public |.ProjContact pctyp;
  public int pctime;
  public float ticOldX, ticNewX;
  public float ticOldY, ticNewY;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `hit.clear();
    `id = .com.IERR;
    `anim = 0;
    `hitanim = -1;
    `remanim = .com.IERR;
    `cancelanim = .com.IERR;
    `scalex = 1.0;
    `scaley = 1.0;
    `remove = 1;
    `removetime = -1;
    `velocityx = 0.0;
    `velocityy = 0.0;
    `remvelocityx = 0.0;
    `remvelocityy = 0.0;
    `accelx = 0.0;
    `accely = 0.0;
    `velmulx = 1.0;
    `velmuly = 1.0;
    `hits = 1;
    `misstime = 0;
    `priority = 1;
    `prioritypoint = 1;
    `sprpriority = 3;
    `edgebound = 40;
    `stagebound = 40;
    `heightboundt = -240;
    `heightboundb = 1;
    `x = 0.0;
    `y = 0.0;
    `facing = 1;
    `shadowr = 0;
    `shadowg = 0;
    `shadowb = 0;
    `supermovetime = 0;
    `pausemovetime = 0;
    `ani.new(0);
    `timemiss = 0;
    `hitpause = 0;
    `playerno = 0;
    `pctyp = .ProjContact::Hit;
    `pctime = 0;
    `ticOldX = `ticNewX = `x;
    `ticOldY = `ticNewY = `y;
  }
  public void setX(float x)
  {
    `x = `ticOldX = `ticNewX = x;
  }
  public void setY(float y)
  {
    `y = `ticOldY = `ticNewY = y;
  }
  public void remvel()
  {
    if(#`ani > 0) `ani~ani.updateSprite();
    `velocityx = `remvelocityx;
    `velocityy = `remvelocityy;
    `accelx = `accely = 0.0;
    `velmulx = `velmuly = 1.0;
    `anim = -1;
    `hits = 0;
    `prioritypoint = 0;
  }
  public void update()
  {
    if(.com.tickFrame()){
      branch{
      cond `anim >= 0:
        branch{
        cond `prioritypoint <= 0 && `remove != 0:
          `ani = .chars[`playerno][0]~getAction(`cancelanim);
        cond `hits <= 0 && `remove != 0:
          `ani = .chars[`playerno][0]~getAction(`hitanim);
        cond
          (
            `x < .com.xmin-(float)`edgebound
            || .com.xmax+(float)`edgebound < `x)
          || (
            `x < .com.scrxmin-(float)`stagebound
            || .com.scrxmax+(float)`stagebound < `x)
          || (`velocityy > 0.0 && `y > (float)`heightboundb)
          || (`velocityy < 0.0 && `y < (float)`heightboundt)
          || `removetime == 0
          || (`removetime <= -2 && (#`ani == 0 || `ani~ani.loopend))
          :
          `ani = .chars[`playerno][0]~getAction(`remanim);
        else:
          break;
        comm:
          if(#`ani > 0 && `ani~ani.totaltime == -1) `ani.new(0);
          `remvel();
        }
      else:
        branch{
        cond #`ani > 0 && `ani~ani.loopend:
          `ani.new(0);
        cond `id >= 0 && `hitpause == 0 && `removetime <= 0:
          `id = !`id;
        }
      }
      `ticOldX = `x;
      `ticNewX = `x + `velocityx*(float)`facing;
      `ticOldY = `y;
      `ticNewY = `y + `velocityy;
    }
    if(`paused() || `hitpause != 0) ret;
    float sp = .com.tickInterpola();
    `x = `ticNewX - (`ticNewX - `ticOldX) * (1.0 - sp);
    `y = `ticNewY - (`ticNewY - `ticOldY) * (1.0 - sp);
    if(.com.tickNextFrame()){
      `velocityx += `accelx;
      `velocityy += `accely;
      `velocityx *= `velmulx;
      `velocityy *= `velmuly;
      if(`velocityx < 0.0){
        `facing *= -1;
        `velocityx *= -1.0;
        `accelx *= -1.0;
      }
    }
  }
  public bool hitCheck(&.Projectile pr=)
  {
    if(#pr.ani == 0 || #pr.ani~ani.frames == 0) ret false;
    if(#`ani == 0 || #`ani~ani.frames == 0) ret false;
    ^&.act.Frame frm;
    ^&.act.Rect clsn1 = pr.ani~ani.currentFrame()=>frm$frm~clsn2;
    ^&.act.Rect clsn2 = `ani~ani.currentFrame()=>frm$frm~clsn2;
    &.ClsnHantei ch.set(
      pr.scalex, pr.scaley, pr.x, pr.y, pr.facing > 0 ? .pLrSet : .mLrSet,
      `scalex, `scaley, `x, `y, `facing > 0 ? .pLrSet : .mLrSet);
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(ch.hantei(clsn1[i], clsn2[j])) ret true;
        j++;
      while j < #clsn2:}
      i++;
    while i < #clsn1:}
    ret false;
  }
  public void projClsn()
  {
    if(`hit.attr < 0) ret;
    loop{index i = 0; while; do:
      if(i != `playerno) loop{
        index j = 0;
        while;
      do:
        if(
          .projs[i][j].id < 0 || (
            .projs[i][j].hit.affectteam != 0 && (
              (`playerno&1) != (i&1)) != (.projs[i][j].hit.affectteam > 0))
          ) continue;
        if(.projs[i][j].hit.attr >= 0 && `hitCheck(.projs[i][j]=)){
          `prioritypoint -= .projs[i][j].priority;
        }
      continue:
        j++;
      while j < #.projs[i]:
      }
      i++;
    while i < #.projs:
    }
    if(`prioritypoint <= 0 && `hits > 0 && `priority > 0){
      `hits -= 1 + -`prioritypoint / `priority;
      if(`hits > 0){
        `prioritypoint = `prioritypoint % `priority + `priority;
      }
    }
  }
  bool paused()
  {
    branch{
    cond .super > 0:
      if(`supermovetime == 0) ret true;
    cond .pause > 0:
      if(`pausemovetime == 0) ret true;
    }
    ret false;
  }
  public void tick()
  {
    if(`timemiss < 0){
      `timemiss = !`timemiss;
      branch{
      cond `misstime <= 0 && `hitpause == 0:
        `hits = 0;
      else:
        `hits--;
      }
      `hit.air_juggle = 0;
    }
    if(`hits <= 0) `hit.attr = -1;
    if(`paused()) ret;
    branch{
    cond `pctime > 0:
      `pctime++;
    cond `pctime < 0:
      `pctime *= -1;
    }
    if(`hitpause <= 0){
      if(`removetime > 0) `removetime--;
      if(`timemiss > 0) `timemiss--;
    }
  }
  public void anime(bool oVer)
  {
    if(
      .com.tickFrame() && #`ani > 0
      && !`paused() && (`hitpause == 0 || `anim < 0))
    {
      `ani~ani.updateSprite();
    }
    if(.com.clsndraw && #`ani > 0){
      ^&.act.Frame frm = `ani~ani.drawFrame();
      if(#frm == 0) break;
      ^&.act.Rect clsn = frm~clsn1;
      if(#clsn > 0){
        .drawc1.new[-1].set(clsn, `x, `y, (float)`facing*`scalex, `scaley);
      }
      clsn = frm~clsn2;
      if(#clsn > 0){
        .drawc2.new[-1].set(clsn, `x, `y, (float)`facing*`scalex, `scaley);
      }
    }
    if(.com.tickNextFrame()){
      if(#`ani > 0 && !`paused() && (`hitpause == 0 || `anim < 0)){
        `ani~ani.action();
      }
      if(`paused()) break;
      branch{
      cond `hitpause > 0:
        `hitpause--;
      else:
        if(`supermovetime > 0) `supermovetime--;
        if(`pausemovetime > 0) `pausemovetime--;
      }
    }
    .addAnimList(
      .anims=, `ani, `sprpriority, `x, `y, .com.scale,
      (float)`facing*`scalex, `scaley, 0.0, false, oVer, 1.0, 1.0, -1, 0,
      256 >> (int)(
        .super > 0 && .superdarken != 0 && `playerno != .superplayer),
      .consts.null!&.com.PalFX?(),
      `shadowr<<16 | (`shadowg&255)<<8 | (`shadowb&255), 256, 0.0);
  }
}
public &Char
{
  public void dummy(){}
  type stateMethod_t = method dummy.signature;
  public &State
  {
    public .Char::stateMethod_t state = .Char::dummy;
  }
  public ^/char def, name, displayname, author;
  public ^/char sprite;
  public ^/char anim;
  public ^/char sound;
  public ^^/char pal;
  public ^index palkeymap;
  public ^&.sff.Sff sf;
  public ^&.snd.Snd sn;
  public ^&.com.PalFX palfx;
  public %&.act.Action actionList;
  public ^&.act.Action ani;
  public ^int ivar, sysivar;
  public ^float fvar, sysfvar;
  public ^&.cmd.CommandList cmd;
  public &.StateVal stVal;
  public &.AfterImage aimg;
  public int key;
  public int id, helperindex, helperid, parentindex;
  public %int children;
  public %int targets;
  public byte playerno;
  public byte facing;
  public bool keyctrl;
  public bool player;
  public bool inguarddist;
  public byte palno, drawpalno, p1facing, animpno;
  public bool destmp, cs1tmp, angleset;
  public bool ctrl, standby;
  public byte hittmp, acttmp;
  public int atktmp;
  public int minus;
  public int sprpriority;
  public int animno;
  public int getcombo;
  public float frontw, backw, fedge, bedge;
  public float attackmul, defencemul, attackdist;
  public float offsetx, offsety;
  public float veloff;
  public float ticOldX, drawX, ticOldY, drawY;
  public %&.RdCacheInfo enemyn;
  public ^&.act.Frame curFrame;
  public %&.snd.Sound sounds;
  public short mver0 = 0, mver1 = 0;
  public index cpucmd = -1;
  public method$void() state = dummy, state_1 = dummy,
    state_2 = dummy, state_3 = dummy, state_i1 = dummy;
  type action_t = &.act.Action;
  &.sff.AirFileMethods!self? airFileMethods;
  new()
  {
    `ivar.new(60);
    `sysivar.new(60);
    `fvar.new(40);
    `sysfvar.new(80);
    `clearVal();
  }
  void copyParent(`self c=)
  {
    %char buf;
    `name = (buf .= c.name .= "'s helper");
    `displayname = c.displayname;
    `author = c.author;
    `sf = c.sf;
    `sn = c.sn;
    `actionList = c.actionList;
    `key = c.key;
    `palno = c.palno;
    `drawpalno = c.drawpalno;
    `state_1 = c.state_1;
    `state_2 = c.state_2;
    `state_3 = c.state_3;
    `state_i1 = c.state_i1;
    .s.copy!int?(`sysivar[10..-1], c.sysivar[10..-1]);
    .s.copy!float?(`sysfvar[10..-1], c.sysfvar[10..-1]);
    `sysivar[.iLIFE] = `sysivar[.iLIFEMAX];
    `sysivar[.iPOWER] = 0;
    `mver0 = c.mver0;
    `mver1 = c.mver1;
    `clearSpSysVar();
  }
  public void clearSpSysVar()
  {
    `rangeSetSysIVar(0, 4, 0);
    `rangeSetSysFVar(0, 4, 0.0);
    `sysivar[.iAIRJUMP_CNT] = 0;
    `sysivar[.iHITCOUNT] = 0;
    `sysivar[.iUNIQHITCOUNT] = 0;
    `sysivar[.iPAUSEMOVETIME] = 0;
    `sysivar[.iSUPERMOVETIME] = 0;
    `sysivar[.iBINDTIME] = 0;
    `sysivar[.iBINDTOID] = -1;
    `sysivar[.iHITPAUSETIME] = 0;
    `sysfvar[.fANGLE] = 0.0;
    `sysfvar[.fANGLESCALEX] = 1.0;
    `sysfvar[.fANGLESCALEY] = 1.0;
    `sysivar[.iALPHAS] = 255;
    `sysivar[.iALPHAD] = 0;
    `sysivar[.iRECOVERTIME] = 0;
    `sysivar[.iSYSFLAG] = 0;
    `ctrl = false;
    `standby = false;
    `sprpriority = 0;
    `getcombo = 0;
    `veloff = 0.0;
    `ticOldX = `drawX = `sysfvar[.fX];
    `ticOldY = `drawY = `sysfvar[.fY];
    `palfx.new(0);
    `aimg.timegap = -1;
    `frontw = `defFW();
    `backw = `defBW();
    `fedge = `bedge = 0.0;
    `attackmul = (float)`sysivar[.iATTACK] / 100.0;
    `enemyn.new(0);
    `targets.new(0);
  }
  public void clearVal()
  {
    `ani.new(0);
    `cmd.new(0);
    `curFrame.new(0);
    `stVal.clear();
    `rangeSetSysIVar(0, #`sysivar-1, 0);
    `rangeSetSysFVar(0, #`sysfvar-1, 0.0);
    `rangeSetIVar(0, #`ivar-1, 0);
    `rangeSetFVar(0, #`fvar-1, 0.0);
    `key = -1; `id = .com.IERR; `playerno = -1; `helperindex = -1;
    `helperid = 0; `parentindex = .com.IERR;
    `facing = 1;
    `keyctrl = false;
    `player = false;
    `inguarddist = false;
    `palno = 0;
    `drawpalno = 0;
    `p1facing = 0;
    `animpno = -1;
    `animno = 0;
    `atktmp = -1;
    `hittmp = 0;
    `acttmp = 0;
    `destmp = false;
    `minus = 2;
    `cs1tmp = false;
    `angleset = false;
    `state = `dummy;
  }
  void clearHitDef()
  {
    `stVal.hit.clear();
  }
  void clearMoveHit()
  {
    `stVal.mctime = 0;
    if(`helperindex == 0) loop{
      index i = 0;
      *.projs<>.self pj = .projs[`playerno];
      while;
    do:
      branch{
      cond pj[i].id < 0:
        pj[i].id = .com.IERR;
      cond pj[i].hits <= 0:
        pj[i].pctime = 0;
      }
      i++;
    while i < #pj:
    }
  }
  void clearHitCount()
  {
    `sysivar[.iHITCOUNT] = 0;
    `sysivar[.iUNIQHITCOUNT] = 0;
  }
  public void rangeSetSysIVar(index start, index end, int n)
  {
    if(start < 0) ret;
    loop{index i = start; while; do:
      `sysivar[i] = n;
      i++;
    while i <= end && i < #`sysivar:
    }
  }
  public void rangeSetSysFVar(index start, index end, float n)
  {
    if(start < 0) ret;
    loop{index i = start; while; do:
      `sysfvar[i] = n;
      i++;
    while i <= end && i < #`sysfvar:
    }
  }
  public void rangeSetIVar(index start, index end, int n)
  {
    if(start < 0 || end >= #`ivar) ret;
    loop{index i = start; while; do:
      `ivar[i++] = n;
    while i <= end:}
  }
  public void rangeSetFVar(index start, index end, float n)
  {
    if(start < 0 || end >= #`fvar) ret;
    loop{index i = start; while; do:
      `fvar[i++] = n;
    while i <= end:}
  }
  public ^&.act.Action getAction(int no)
  {
    *`ani.self a;
    loop{index i = 0; while; do:
      if(`actionList[i].no == no){
        a.new(1);
        a~copy(`actionList[i]=);
        break, break;
      }
      i++;
    while i< #`actionList:
    }
    ret a;
  }
  public ^&.snd.Sound newChannel(int ch, bool lowpriority)
  {
    index c = .m.min!int?(255, ch);
    if(c >= 0) branch{
    cond lowpriority:
      if(#`sounds > c && #`sounds[c].sound > 0){
        ret .consts.null!&.snd.Sound?();
      }
    comm:
      `sounds.new[c];
      ret `sounds[c..c+1];
    }
    `sounds.new[255];
    loop{index i = 255; do:
      if(#`sounds[i].sound == 0) ret `sounds[i..i+1];
      i--;
    while i >= 0:
    }
    ret .consts.null!&.snd.Sound?();
  }
  public ^&.Explod newExplod(index idx=)
  {:<-
    ^&.Explod foo(index i)
    {
      .explods[`playerno][i].clear();
      .explods[`playerno][i].id = -1;
      .explods[`playerno][i].player = `id;
      ret .explods[`playerno][i..i+1];
    }
    loop{idx = 0; while; do:
      if(.explods[`playerno][idx].id == .com.IERR) ret foo(idx);
      idx++;
    while idx < #.explods[`playerno]:
      if(idx < .cfg.ExplodMax){
        .explods[`playerno].new[idx];
        ret foo(idx);
      }
    }
    idx = -1;
    ret .consts.null!&.Explod?();
  }
  public void insertExplod(index i)
  {
    if(#.explods[`playerno][i].ani == 0){
      .explods[`playerno][i].id = .com.IERR;
      ret;
    }
    .explods[`playerno][i].ani~ani.updateSprite();
    branch{
    cond .explods[`playerno][i].ontop != 0:
      loop{
        index ii = 0;
       while;
      do:
        if(.topexpdrawlist[`playerno][ii] < 0){
          .topexpdrawlist[`playerno][ii] = i;
          break, break;
        }
        ii++;
      while ii < #.topexpdrawlist[`playerno]:
        .topexpdrawlist[`playerno] .= i;
      }
    else:
      loop{
        index ii = 0;
        int p;
        while;
      do:
        p = .explods[`playerno][.expdrawlist[`playerno][ii]].player;
        if(p >= `id){
          .insIL(.expdrawlist[`playerno]=, ii, i);
          break, break;
        }
        ii++;
      while ii < #.expdrawlist[`playerno]:
        .expdrawlist[`playerno] .= i;
      }
    }
  }
  public ^&.Projectile newProj()
  {
    loop{index i = 0; while; do:
      if(.projs[`playerno][i].id < 0){
        .projs[`playerno][i].clear();
        .projs[`playerno][i].id = 0;
        ret .projs[`playerno][i..i+1];
      }
      i++;
    while i < #.projs[`playerno]:
      if(i < .cfg.PlayerProjectileMax){
        .projs[`playerno].new[i].id = 0;
        ret .projs[`playerno][i..i+1];
      }
    }
    ret .consts.null!&.Projectile?();
  }
  public void addTarget(int id)
  {
    loop{index i = 0; while; do:
      if(`targets[i] < 0 || `targets[i] == id){
        `targets[i] = id;
        break, break;
      }
      i++;
    while i < #`targets:
      `targets .= id;
    }
  }
  public bool isTarget(int id)
  {
    loop{index i = 0; while; do:
      if(`targets[i] == id) ret true;
      i++;
    while i < #`targets:
    }
    ret false;
  }
  public void removeTarget(int id)
  {
    loop{index i = 0; while; do:
      if(`targets[i] == id){
        `targets[i] = -1;
        break, break;
      }
      i++;
    while i < #`targets:
    }
  }
  public void byBindClear()
  {
    if(`stVal.hb.byidMatch(`sysivar[.iBINDTOID])) `setBindTime(0);
  }
  void enemyExplodsRemove(int enemy)
  {
    void enemyExpRemove(^%index drawlist=, bool delI, int id)
    {
      loop{
        index i = #drawlist[`enemy]-1, tmp;
        while;
      do:
        tmp = drawlist[`enemy][i];
        if(tmp < 0) continue;
        if(
          .explods[`enemy][tmp].bindtime != 0
          && .explods[`enemy][tmp].bindid == id)
        {
          .explods[`enemy][tmp].id = .com.IERR;
          branch{
          cond delI:
            .delIL(drawlist[`enemy]=, i);
          else:
            drawlist[`enemy][i] = -1;
          }
        }
      continue:
        i--;
      while i >= 0:
      }
    }
    enemyExpRemove(.expdrawlist=, true, `id);
    enemyExpRemove(.topexpdrawlist=, false, `id);
  }
  public void outTarget()
  {
    if(`hittmp >= 0){
      loop{
        index i = 0;
        ^`self c;
        while;
      do:
        c = .players.get(`stVal.hb.by[i].id);
        if(#c > 0){
          c~removeTarget(`id);
          `enemyExplodsRemove(c~playerno);
        }
        i++;
      while i < #`stVal.hb.by:
      }
      `byBindClear();
    }
    `stVal.hb.by.new(0);
  }
  void addChild(int hidx)
  {
    loop{index i = 0; while; do:
      if(`children[i] < 0){
        `children[i] = hidx;
        ret;
      }
      i++;
    while i < #`children:
    }
    `children .= hidx;
  }
  public ^&.com.PalFX getPalfx()
  {
    if(#`palfx > 0) ret `palfx;
    if(`parentindex < 0){
      `palfx.new(1);
      ret `palfx;
    }
    ret .chars[`playerno][`parentindex]~getPalfx();
  }
  public bool ls(int mask)
  {
    ret (`sysivar[.iSPECIALFLAG] & mask) == mask;
  }
  public ^/char load(^/char def)
  {:<-
    void info(&.com.Section sc=)
    {
      ^/char data;
      if(#(data = sc.getText("name")) > 0) `name = data;
      branch{
      cond #(data = sc.getText("displayname")) > 0:
        `displayname = data;
      else:
        `displayname = `name;
      }
      if(#(data = sc.getText("author")) > 0) `author = data;
    }
    void files(&.com.Section sc=, bool unicode)
    {
      bool oVer = `mver0 != 1;
      ^/char f(^/char str)
      {
        ^/char s = .com.readFileName(str, `unicode);
        if(`oVer) s = s[0...s.cFind(" "\t, s)];
        ret s;
      }
      ^/char data;
      if(#(data = sc.get("sprite")) > 0) `sprite = f(data);
      if(#(data = sc.get("anim")) > 0) `anim = f(data);
      if(#(data = sc.get("sound")) > 0) `sound = f(data);
      if(#(data = sc.get("pal1")) > 0) `pal[0] = f(data);
      if(#(data = sc.get("pal2")) > 0) `pal[1] = f(data);
      if(#(data = sc.get("pal3")) > 0) `pal[2] = f(data);
      if(#(data = sc.get("pal4")) > 0) `pal[3] = f(data);
      if(#(data = sc.get("pal5")) > 0) `pal[4] = f(data);
      if(#(data = sc.get("pal6")) > 0) `pal[5] = f(data);
      if(#(data = sc.get("pal7")) > 0) `pal[6] = f(data);
      if(#(data = sc.get("pal8")) > 0) `pal[7] = f(data);
      if(#(data = sc.get("pal9")) > 0) `pal[8] = f(data);
      if(#(data = sc.get("pal10")) > 0) `pal[9] = f(data);
      if(#(data = sc.get("pal11")) > 0) `pal[10] = f(data);
      if(#(data = sc.get("pal12")) > 0) `pal[11] = f(data);
    }
    void keymap(&.com.Section sc=)
    {:<-
      void foo(index k, ^/char p)
      {
        `palkeymap[k] = .com.atoi(p)-1;
        if(!.m.inRange!index?(0, .sff.NumCharPalletes-1, `palkeymap[k])){
          `palkeymap[k] = 0;
        }
      }
      ^/char data;
      if(#(data = sc.get("a")) > 0) foo(0, data);
      if(#(data = sc.get("b")) > 0) foo(1, data);
      if(#(data = sc.get("c")) > 0) foo(2, data);
      if(#(data = sc.get("x")) > 0) foo(3, data);
      if(#(data = sc.get("y")) > 0) foo(4, data);
      if(#(data = sc.get("z")) > 0) foo(5, data);
      if(#(data = sc.get("a2")) > 0) foo(6, data);
      if(#(data = sc.get("b2")) > 0) foo(7, data);
      if(#(data = sc.get("c2")) > 0) foo(8, data);
      if(#(data = sc.get("x2")) > 0) foo(9, data);
      if(#(data = sc.get("y2")) > 0) foo(10, data);
      if(#(data = sc.get("z2")) > 0) foo(11, data);
    }
    bool keymapflg = true;
    ~$void(^/char, &.com.Section=) palette = [palette.signature(sec, sc=){
      branch{
      cond .s.equ(.s.toLower(sec[0..6]), "keymap"):
        if(keymapflg) keymap(sc=);
        keymapflg = false;
      }
    }];
    bool unicode = false;
    bool infoflg = true, filesflg = true;
    ~$void(^^/char, index=) section = [void(^^/char lines, index i=){
      ^/char sec = lines[i];
      ^/char secname = .com.sectionName(sec=);
      if(#secname == 0) ret;
      i++;
      &.com.Section sc.parse(lines, i=);
      branch{
      cond .s.equ(secname, "info"):
        if(infoflg) info(sc=);
        infoflg = false;
      cond .s.equ(secname, "files"):
        if(filesflg) files(sc=, unicode);
        filesflg = false;
      cond .s.equ(secname, "palette "):
        palette(:sec, sc=:);
      }
    }];
    ^/char error;
    `def = def;
    ^char mainbuf = .com.loadText(def, unicode=);
    ^^/char lines = .com.splitLines(mainbuf);
    .s.each!^/char?([void(^/char l=){l=.s.trim(l);}], lines);
    .com.mugenversion(lines, `mver0=, `mver1=);
    `clearDef();
    loop{index i = 0; while; do:
      section(:lines, i=:);
      i++;
    while i < #lines:
    }
    `sf.new(1);
    if(
      #.com.loadFile(def, `sprite=)=>error <,
      [^/char(^/char f){ret `sf~loadFile(f, true);}] > 0)
    {
      ret def + ":"\r\n + error;
    }
    if(
      #.com.loadFile(def, `anim=)=>error <, [^/char(^/char f){
        ret
          #.com.loadText(f, unicode=)=>mainbuf > 0
          ? "" : .com.FileReadError;
      }] > 0) 
    {
      ret def + ":"\r\n + error;
    }
    lines = .com.splitLines(mainbuf);
    .s.each!^/char?([void(^/char l=){l=.s.trim(l);}], lines);
    `actionList.new(0);
    loop{index i = 0; while; do:
      `readAction(lines, i=);
      i++;
    while i < #lines:
    }
    loop{index i = 0; while; do:
      `actionList[i].ani.setup(`sf);
      i++;
    while i < #`actionList:
    }
    `sn.new(1);
    if(
      #`sound > 0 && #.com.loadFile(def, `sound=)=>error <,
      [^/char(^/char f){ret `sn~loadFile(f);}] > 0) ret def + ":"\r\n + error;
    ret "";
  }
  public bool loadPallet(^/char def, int no)
  {
    `sf~palList.resetRemap();
    index tmp = 0;
    if(`sf~head.ver0 == 0d1) loop{
      index i = 0;
      ubyte r, g, b;
      ^uint pl;
      while;
    do:
      pl = `sf~palList.get(i);
      branch{
        &.file.File f;
      cond
        #.com.loadFile(def, `pal[i]=)<, [^/char(^/char fn){
          f.open(fn, "rb"); ret f.read!ubyte?(r=) ? "" : "error";
        }] == 0
        :
        loop{
          index j = 255;
          continue;
        do:
          if(!f.read!ubyte?(r=)) ret false;
        continue:
          if(!f.read!ubyte?(g=)) ret false;
          if(!f.read!ubyte?(b=)) ret false;
          pl[j] = (uint)r<<0d16 | (uint)g<<0d8 | (uint)b;
          j--;
        while j >= 0:
        }
        if(tmp == 0) loop{index j = 0; while; do:
          .s.copy!uint?(`sf~palList.get(j), pl);
          j++;
        while j < i:
        }
        tmp = i+1;
      cond tmp > 0:
        .s.copy!uint?(pl, `sf~palList.get(i >= 6 ? i % 6 : i - 1));
      }
      i++;
    while i < .sff.NumCharPalletes:
      if(tmp == 0){
        ^&.sff.Sprite spr = `sf~getSprite(9000, 0);
        if(#spr > 0){
          index i = spr~palidx;
          spr = `sf~getSprite(0, 0);
          if(#spr > 0) `sf~palList.remap(spr~palidx, i);
        }
      }
    }
    `palno = `palkeymap[no-1]+1;
    `drawpalno = `palno;
    if(`sf~head.ver0 == 0d1 && tmp == 0) ret false;
    loop{
      index i = `palno-1;
    do:
      loop{index j = 0; while; do:
        if(
          j != `playerno && #.chars[j] > 0 && .s.equ(.chars[j][0]~def, `def)
          && .chars[j][0]~drawpalno == i+1) break;
        j++;
      while j < #.chars:
        `drawpalno = i+1;
        break, break;
      }
      i++;
      if(i >= .sff.NumCharPalletes) i = 0;
    while i != `palno-1:
    }
    `trRemapPal(1, 1, 1, `drawpalno);
    ret true;
  }
  public void clearDef()
  {
    `name = "";
    `displayname = "";
    `author = "";
    `sprite = "";
    `anim = "";
    `sound = "";
    `pal.new(.sff.NumCharPalletes);
    `palkeymap.new(.sff.NumCharPalletes);
    loop{index i = 0; while; do:
      `palkeymap[i] = i;
      i++;
    while i < #`palkeymap:
    }
  }
  public int gethitAnimtype()
  {
    ret
      `stVal.hb.fallf != 0 ? (int)`stVal.hb.fall.animtype : (
        `stVal.typ == .StTy::A
        ? `stVal.hb.airanimtype : `stVal.hb.groundanimtype);
  }
  public void setEnemyWinty()
  {
    if(`helperindex != 0) ret;
    branch{
    cond
      (`stVal.hb.attr&((int).AtTy::HA|(int).AtTy::HT|(int).AtTy::HP))
      != 0
      :
      .winty[(`playerno+1)&1] = .fgt.WinTy::H;
    cond
      (`stVal.hb.attr&((int).AtTy::SA|(int).AtTy::ST|(int).AtTy::SP))
      != 0
      :
      .winty[(`playerno+1)&1] = .fgt.WinTy::S;
    cond
      (`stVal.hb.attr&((int).AtTy::NT|(int).AtTy::ST|(int).AtTy::HT))
      != 0
      :
      .winty[(`playerno+1)&1] = .fgt.WinTy::Throw;
    else:
      .winty[(`playerno+1)&1] = .fgt.WinTy::N;
    }
  }
  public bool attrCheck(&.Hitdef hit=, int cid, |.StTy styp)
  {
    if(
      .super > 0 && .superunhittable != 0
      && `playerno == .superplayer) ret false;
    if(hit.chainid >= 0 && `stVal.hb.hitid != hit.chainid) ret false;
    if(#`stVal.hb.by > 0 && `stVal.hb.by[-1].id == cid){
      if(
        hit.nochainid1 >= 0 && `stVal.hb.hitid == hit.nochainid1) ret false;
      if(
        hit.nochainid2 >= 0 && `stVal.hb.hitid == hit.nochainid2) ret false;
    }
    if(hit.reversal_attr > 0){
      ret
        `atktmp >= 0 && `stVal.hit.attr > 0
        && (`stVal.hit.attr & hit.reversal_attr & 63) != 0
        && (`stVal.hit.attr & hit.reversal_attr & !63) != 0;
    }
    if(hit.attr <= 0) ret false;
    if((hit.hitflag & (int)`stVal.typ) == 0) ret false;
    if((hit.hitflag & (int).StTy::N) == 0 && `hittmp >= 2) ret false;
    if((hit.hitflag & (int).MovTy::I) != 0 && `hittmp > 0) ret false;
    if((hit.hitflag & (int).MovTy::H) != 0 && `hittmp <= 0) ret false;
    if(hit.chainid < 0){
      if(
        `stVal.hb.hitt1 != 0 && (
          (`stVal.hb.hitf1 & (
              styp == .StTy::N ? hit.attr & 63 : (int)styp)) == 0
          || (`stVal.hb.hitf1 & hit.attr & !63) == 0)) ret false;
      if(
        `stVal.hb.hitt2 != 0 && (
          (`stVal.hb.hitf2 & (
              styp == .StTy::N ? hit.attr & 63 : (int)styp)) == 0
          || (`stVal.hb.hitf2 & hit.attr & !63) == 0)) ret false;
    }
    ret true;
  }
  public bool hittable(
    &.Hitdef hit=, int cid, |.StTy styp, ~$bool(&.Hitdef=) countercheck)
  {
    if(
      `atktmp >= 0 && (`stVal.hit.attr != 0 || `stVal.hit.reversal_attr > 0)
      && hit.reversal_attr <= 0)
    {
      if(
        (
          `stVal.hit.reversal_attr > 0 || (
            hit.priority <= `stVal.hit.priority && (
              hit.priority < `stVal.hit.priority
              || `stVal.hit.bothhittype == .PriTy::Dodge
              || hit.bothhittype != .PriTy::Hit)))
        && countercheck(:`stVal.hit=:)) ret false;
    }
    ret `attrCheck(hit=, cid, styp);
  }
  public bool clsnCheck(`self atk=, bool c1atk, bool c1slf)
  {
    if(#atk.ani == 0 || #atk.curFrame == 0) ret false;
    if(#`ani == 0 || #`curFrame == 0) ret false;
    ^&.act.Rect clsn1 = c1atk ? atk.curFrame~clsn1 : atk.curFrame~clsn2;
    ^&.act.Rect clsn2 = c1slf ? `curFrame~clsn1 : `curFrame~clsn2;
    &.ClsnHantei ch.set(
      atk.sysfvar[.fCLSNXSCALE], atk.sysfvar[.fCLSNYSCALE],
      atk.sysfvar[.fX] + atk.offsetX(), atk.sysfvar[.fY] + atk.offsetY(),
      atk.facing > 0 ? .pLrSet : .mLrSet,
      `sysfvar[.fCLSNXSCALE], `sysfvar[.fCLSNYSCALE],
      `sysfvar[.fX] + `offsetX(), `sysfvar[.fY] + `offsetY(),
      `facing > 0 ? .pLrSet : .mLrSet);
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(ch.hantei(clsn1[i], clsn2[j])) ret true;
        j++;
      while j < #clsn2:}
      i++;
    while i < #clsn1:}
    ret false;
  }
  public bool hitCheck(`self atk=)
  {
    ret `clsnCheck(atk=, true, atk.stVal.hit.reversal_attr > 0);
  }
  public bool projHitCheck(&.Projectile pr=)
  {
    if(#pr.ani == 0 || #pr.ani~ani.frames == 0) ret false;
    if(#`ani == 0 || #`curFrame == 0) ret false;
    ^&.act.Frame frm;
    ^&.act.Rect clsn1 = pr.ani~ani.currentFrame()=>frm$frm~clsn1;
    ^&.act.Rect clsn2 = `curFrame~clsn2;
    &.ClsnHantei ch.set(
      pr.scalex, pr.scaley, pr.x, pr.y, pr.facing > 0 ? .pLrSet : .mLrSet,
      `sysfvar[.fCLSNXSCALE], `sysfvar[.fCLSNYSCALE],
      `sysfvar[.fX] + `offsetX(), `sysfvar[.fY] + `offsetY(),
      `facing > 0 ? .pLrSet : .mLrSet);
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(ch.hantei(clsn1[i], clsn2[j])) ret true;
        j++;
      while j < #clsn2:}
      i++;
    while i < #clsn1:}
    ret false;
  }
  public bool hitProjCheck(&.Projectile pr=)
  {
    if(#pr.ani == 0 || #pr.ani~ani.frames == 0) ret false;
    if(#`ani == 0 || #`curFrame == 0) ret false;
    ^&.act.Frame frm;
    ^&.act.Rect clsn1 = pr.ani~ani.currentFrame()=>frm$frm~clsn2;
    if(`stVal.hit.reversal_attr > 0) clsn1 = frm~clsn1;
    ^&.act.Rect clsn2 = `curFrame~clsn1;
    &.ClsnHantei ch.set(
      pr.scalex, pr.scaley, pr.x, pr.y, pr.facing > 0 ? .pLrSet : .mLrSet,
      `sysfvar[.fCLSNXSCALE], `sysfvar[.fCLSNYSCALE],
      `sysfvar[.fX] + `offsetX(), `sysfvar[.fY] + `offsetY(),
      `facing > 0 ? .pLrSet : .mLrSet);
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(ch.hantei(clsn1[i], clsn2[j])) ret true;
        j++;
      while j < #clsn2:}
      i++;
    while i < #clsn1:}
    ret false;
  }
  public void tickBind()
  {
    if(`sysivar[.iBINDTIME] > 0) `setBindTime(`sysivar[.iBINDTIME]-1);
  }
  public void tick()
  {
    if(`acttmp > 0){
      if(#`ani > 0) `ani~ani.action();
      `tickBind();
    }
    if(#`cmd == 0) `cmd = .chars[`playerno][0]~cmd;
    `enemyn.new(0);
    if(`stVal.hitdefContact != 0){
      `stVal.hit.invalidate();
      `stVal.hitdefContact = 0;
    }
    if(`stVal.mctime < 0){
      `stVal.mctime = 1;
      if(`stVal.mctyp == .MoveContact::Hit){
        `stVal.juggle = 0;
        `sysivar[.iHITCOUNT] += `stVal.hit.numhits;
      }
    }
    if(`ls(.lsGETHIT)){
      `sysivar[.iHITPAUSETIME] = 0;
      `p1facing = 0;
      ^`self c;
      if(#`stVal.hb.by > 0 && #(c = .players.get(`stVal.hb.by[-1].id)) > 0){
        if(`stVal.hb.p1getp2facing != 0){
          c~setFacing(`facing*`stVal.hb.p1getp2facing);
        }
        if(!.m.isnan(`stVal.hb.mindistx)) branch{
        cond c~facing < 0:
          `sysfvar[.fX] =
            .m.min!float?(`sysfvar[.fX])<,
            (c~sysfvar[.fX] - `stVal.hb.mindistx);
        else:
          `sysfvar[.fX] =
            .m.max!float?(`sysfvar[.fX])<,
            (c~sysfvar[.fX] + `stVal.hb.mindistx);
        }
        if(!.m.isnan(`stVal.hb.maxdistx)) branch{
        cond c~facing < 0:
          `sysfvar[.fX] =
            .m.max!float?(`sysfvar[.fX])<,
            (c~sysfvar[.fX] - `stVal.hb.maxdistx);
        else:
          `sysfvar[.fX] =
            .m.min!float?(`sysfvar[.fX])<,
            (c~sysfvar[.fX] + `stVal.hb.maxdistx);
        }
        if(`stVal.hb.guarded == 0 || `stVal.typ == .StTy::A){
          if(!.m.isnan(`stVal.hb.mindisty)){
            `sysfvar[.fY] =
              .m.max!float?(`sysfvar[.fY])<,
              (c~sysfvar[.fY] + `stVal.hb.mindisty);
          }
          if(!.m.isnan(`stVal.hb.maxdisty)){
            `sysfvar[.fY] =
              .m.min!float?(`sysfvar[.fY])<,
              (c~sysfvar[.fY] + `stVal.hb.maxdisty);
          }
        }
        if(`stVal.hb.snapt != 0){
          `setBindToId(c<>=);
          `setBindTime(`stVal.hb.snapt);
          `sysivar[.iBINDFACING] = 0;
          `sysfvar[.fBINDPOSX] = `stVal.hb.snapx;
          `sysfvar[.fBINDPOSY] =
            `stVal.hb.guarded == 0 || `stVal.typ == .StTy::A
            ? `stVal.hb.snapy : 0.0/0.0;
        }
      }
      if(!`cs1tmp) branch{
      cond `stVal.typ == .StTy::L:
        `trSelfState(5080, -1, 0);
      cond
        `stVal.hb.guarded != 0
        && (`stVal.hb.damage < `sysivar[.iLIFE] || .gs(.gsNOKO))
        :
        switch(`stVal.typ){
        case .StTy::S:
          `trSelfState(150, -1, 0);
        case .StTy::C:
          `trSelfState(152, -1, 0);
        case .StTy::A:
          `trSelfState(154, -1, 0);
        }
      cond `stVal.hb.typ == 3:
        `trSelfState(5070, -1, 0);
      else:
        switch(`stVal.typ){
        case .StTy::S:
          `trSelfState(5000, -1, 0);
        case .StTy::C:
          `trSelfState(5010, -1, 0);
        case .StTy::A:
          `trSelfState(5020, -1, 0);
        }
      }
    }
    if(!`isPaused()) branch{
    cond `sysivar[.iHITPAUSETIME] > 0:
      `sysivar[.iHITPAUSETIME]--;
    else:
      if(`stVal.mctime > 0) `stVal.mctime++;
    comm:
      if(`sysivar[.iHITPAUSETIME] <= 0){
        if(
          `stVal.typ == .StTy::L && `sysivar[.iRECOVERTIME] > 0
          && `stVal.playerno == `playerno
          && (
            `cmd~buffer~Bb == 1 || `cmd~buffer~Db == 1
            || `cmd~buffer~Fb == 1 || `cmd~buffer~Ub == 1
            || `cmd~buffer~ab == 1 || `cmd~buffer~bb == 1
            || `cmd~buffer~cb == 1 || `cmd~buffer~xb == 1
            || `cmd~buffer~yb == 1 || `cmd~buffer~zb == 1
            || `cmd~buffer~sb == 1))
        {
          `sysivar[.iRECOVERTIME] -=
            .m.randI(1, (`sysivar[.iRECOVERTIME]+1)/2);
        }
      }
    }
    `minus = 11;
    `state_i1(::);
  }
  public void drawAnim()
  {
    if(`helperindex < 0 || `id < 0) ret;
    if(.com.clsndraw && #`curFrame > 0){
      float x = `sysfvar[.fX]+`offsetX();
      float y = `sysfvar[.fY]+`offsetY();
      float xs = (float)`facing * `sysfvar[.fCLSNXSCALE];
      float ys = `sysfvar[.fCLSNYSCALE];
      ^&.act.Frame frm = `curFrame;
      ^&.act.Rect clsn = frm~clsn1;
      if(#clsn > 0 && `atktmp >= 0) .drawc1.new[-1].set(clsn, x, y, xs, ys);
      clsn = frm~clsn2;
      if(#clsn > 0) branch{
      cond `stVal.hb.hitt1 != 0 || `stVal.hb.hitt2 != 0:
        .drawc2sp.new[-1].set(clsn, x, y, xs, ys);
      else:
        .drawc2.new[-1].set(clsn, x, y, xs, ys);
      }
      if(`ls(.lsPLAYERPUSH)){
        clsn.new(1);
        clsn~l = (short)-`backw;
        clsn~t = (short)-`getHeight() + 1;
        clsn~r = (short)`frontw - 1;
        clsn~b = 0;
        .drawwh.new[-1].set(
          clsn, x-`offsetX(), y-`offsetY(), (float)`facing, 1.0);
      }
    }
    float x = `drawX+`offsetX();
    float y = `drawY+`offsetY();
    float xs = (float)`facing * `sysfvar[.fXSCALE];
    float ys = `sysfvar[.fYSCALE];
    if(#`ani > 0) branch{
      int sp = `sprpriority;
      int br = 256 >> (int)(
        .super > 0 && .superdarken != 0 && `playerno != .superplayer);
      float an;
      branch{
      cond `ls(.lsANGLEDRAW):
        an = `sysfvar[.fANGLE] == 0.0 ? 360.0 : `sysfvar[.fANGLE];
        `angleset |= `sysfvar[.fANGLE] != 0.0;
      else:
        an = 0.0;
        `angleset = false;
      }
    cond !`ls(.lsINVISIBLE):
      if(`ls(.lsANGLEDRAW) && !`ls(.lsTRANS)){
        `sysivar[.iSPECIALFLAG] |= .lsTRANS;
        `sysivar[.iALPHAS] = 255;
        `sysivar[.iALPHAD] = 0;
      }
      .addAnimList(
        .anims=, `ani, sp,
        x - (float)(
          (int)(`stVal.hb.hitshaketime > 0 && (`stVal.time&1) != 0) * `facing),
        y, .com.scale, xs, ys, an, `angleset, `mver0 != 1,
        `sysfvar[.fANGLESCALEX], `sysfvar[.fANGLESCALEY],
        `ls(.lsTRANS) ? `sysivar[.iALPHAS] : -1,
        `sysivar[.iALPHAD], br, `getPalfx(),
        `ls(.lsNOSHADOW) ? 0 : -1,
        `ls(.lsTRANS) ? `sysivar[.iALPHAS] : 256,
        (float)`sysivar[.iSHADOWOFFSET]);
      `aimg.recAndAddAL(
        `ani<>=, sp, x, y, xs, ys, an, `angleset, `mver0 != 1,
        `sysfvar[.fANGLESCALEX], `sysfvar[.fANGLESCALEY],
        .com.tickNextFrame() && `acttmp > 0, br);
    cond .com.tickNextFrame() && `acttmp > 0:
      `aimg.recAfterImg(
        `ani<>=, x, y, xs, ys, an, `angleset, `mver0 != 1,
        `sysfvar[.fANGLESCALEX], `sysfvar[.fANGLESCALEY]);
    }
    if(.com.tickNextFrame()){
      if(`roundState() == 4) `outTarget();
      if(.supertime < 0){
        if((`playerno&1) != (.superplayer&1) && `stVal.mov == .MovTy::H){
          `defencemul *= .superp2defmul;
        }
      }
      `minus = 2;
    }
  }
  public int roundState()
  {
    ret
      .com.intro > .fight~ro.ctrl_time+1 ? 0
      : .fight~ro.cur == 0 ? 1
      : !.roundEnd() ? 2
      : (
        .com.intro < -(.fight~ro.over_hittime + .fight~ro.over_waittime) && (
          (.chars[`playerno]<>~sysivar[.iSYSFLAG] & .sfOVER) != 0
          || !.chars[`playerno]<>~isAlive())
        ? 4 : 3);
  }
  public bool isKO()
  {
    ret (`sysivar[.iSYSFLAG] & .sfKO) != 0;
  }
  public bool isAlive()
  {
    ret !`isKO() && !.chars[`playerno][0]~isKO();
  }
  public bool isPaused()
  {
    ret `acttmp <= -2;
  }
  public bool isHitPaused()
  {
    ret `sysivar[.iHITPAUSETIME] > 0;
  }
  public bool isActive()
  {
    ret !`isPaused() && !`isHitPaused();
  }
  public bool isBound()
  {
    loop{
      index i = 0;
      ^`self by;
      while;
    do:
      if(`sysivar[.iBINDTOID] == `stVal.hb.by[i].id) ret true;
      i++;
    while i < #`stVal.hb.by:
    }
    ret false;
  }
  public bool isFall()
  {
    ret `stVal.hb.fallf != 0;
  }
  public float getHeight()
  {
    ret (float)`sysivar[.iHEIGHT];
  }
  public float getEdge(float base)
  {
    ret
      base + (
        `mver0 == 1 ? 0.0
        : `stVal.typ == .StTy::A ? 1.0
        : `stVal.typ == .StTy::L ? 2.0
        : 0.0);
  }
  public float defFW()
  {
    ret
      (float)(
        `stVal.typ == .StTy::A
        ? `sysivar[.iAIR_FRONT] : `sysivar[.iGROUND_FRONT]);
  }
  public float defBW()
  {
    ret
      (float)(
        `stVal.typ == .StTy::A
        ? `sysivar[.iAIR_BACK] : `sysivar[.iGROUND_BACK]);
  }
  public float offsetX()
  {
    ret (float)`sysivar[.iDRAW_OFFSETX]*(float)`facing + `offsetx;
  }
  public float offsetY()
  {
    ret (float)`sysivar[.iDRAW_OFFSETY] + `offsety;
  }
  public bool landCondition()
  {
    ret
      `stVal.phy == .StTy::A && `isActive() && `sysfvar[.fVY] > 0.0
      && `sysfvar[.fY] >= 0.0 && `stVal.no != 105 && `stVal.no != 52;
  }
  public void action()
  {:<-
    bool isSuperPaused()
    {
      ret .super > 0 && (!`isAlive() || `sysivar[.iSUPERMOVETIME] == 0);
    }
    bool isNormalPaused()
    {
      ret
        .super <= 0 && .pause > 0
        && (!`isAlive() || `sysivar[.iPAUSEMOVETIME] == 0);
    }
    if(`minus != 2) ret;
    `minus = 3;
    if(`parentindex >= 0) .chars[`playerno][`parentindex]~action();
    loop{
      index i = 0;
      ^`self by;
      while;
    do:
      if(#(by = .players.get(`stVal.hb.by[i].id)) > 0) by~action();
      i++;
    while i < #`stVal.hb.by:
    }
    if(#`palfx > 0 && !`isPaused()) `palfx~step();
    bool p = isSuperPaused() || isNormalPaused();
    if(#`cmd == 0){
      `changeState2();
      p = false;
    }
    `acttmp = -(int)p * 2;
    if(!p){
      bool lc = !`ls(.lsGETHIT) && `landCondition();
      if(!`isHitPaused()){
        `setFacing(`p1facing);
        `p1facing = 0;
      }
      if(`isBound()) `bind();
      `changeState2();
      if(!`isHitPaused()){
        if(
          (`sysivar[.iSYSFLAG] & .sfOVER) == 0
          && `ctrl && `helperindex == 0
          && `stVal.typ != .StTy::A  && !`ls(.lsNOAUTOTURN))
        {
          ^`self e = .players.enemyNear(`=, 0);
          if((int)`facing*(int)(e~sysfvar[.fX] - `sysfvar[.fX]) >= 0) break;
          if(`stVal.typ != .StTy::L){
            `trChangeAnim(`stVal.typ == .StTy::S ? 5 : 6);
          }
          `setFacing(-`facing);
        }
        if(`keyctrl && #`cmd > 0) branch{
          branch{
          cond `stVal.typ == .StTy::A:
            if(`cmd~buffer~U < 0) `sysivar[.iSYSFLAG] |= .sfAIRJUMP;
          else:
            `sysivar[.iAIRJUMP_CNT] = 0;
            `sysivar[.iSYSFLAG] &= !.sfAIRJUMP;
          }
        cond `canCtrl() && (`key >= 0 || `helperindex == 0):
          branch{
          cond `stVal.typ == .StTy::S && `cmd~buffer~D > 0:
            if(`stVal.no != 10) `trSelfState(10, -1, -1);
          cond `stVal.typ == .StTy::C && `cmd~buffer~D < 0:
            if(`stVal.no != 12) `trSelfState(12, -1, -1);
          cond !.roundEnd() && `stVal.typ != .StTy::A && `cmd~buffer~U > 0:
            if(`stVal.no != 40) `trSelfState(40, -1, -1);
          cond
            `stVal.typ == .StTy::A && (`sysivar[.iSYSFLAG]&.sfAIRJUMP) != 0
            && `sysfvar[.fY] <= (float)`sysivar[.iAIRJUMP_HEIGHT]
            && `sysivar[.iAIRJUMP_CNT] < `sysivar[.iAIRJUMP_NUM]
            && `cmd~buffer~U > 0
            :
            if(`stVal.no != 45){
              `sysivar[.iAIRJUMP_CNT]++;
              `sysivar[.iSYSFLAG] &= !.sfAIRJUMP;
              `trSelfState(45, -1, -1);
            }
          cond
            !`ls(.lsNOWALK) && `stVal.typ == .StTy::S && (
              `cmd~buffer~F > 0 || (
                (!`inguarddist || `ls(.lsNOSTANDGUARD)) && `cmd~buffer~B > 0))
            :
            if(`stVal.no != 20) `trSelfState(20, -1, -1);
          cond `stVal.no == 20 && (`cmd~buffer~F < 0 && `cmd~buffer~B < 0):
            `trSelfState(0, -1, -1);
          }
          if(
            `inguarddist && (`stVal.no < 120 || `stVal.no >= 160) && (
              (`stVal.typ == .StTy::S && !`ls(.lsNOSTANDGUARD))
              || (`stVal.typ == .StTy::C && !`ls(.lsNOCROUCHGUARD))
              || (`stVal.typ == .StTy::A && !`ls(.lsNOAIRGUARD)))
            && `cmd~buffer~B > 0)
          {
            `trSelfState(120, -1, -1);
          }
        cond `ctrl:
          switch(`stVal.no){
          case 11:
            `trSelfState(12, -1, 1);
          case 20:
            `trSelfState(0, -1, 1);
          }
        }
        if(!.roundEnd()){
          if(!`isKO() && `sysivar[.iLIFE] > 0){
            `sysivar[.iSYSFLAG] &= !.sfOVER;
          }
          if((`sysivar[.iSYSFLAG] & .sfOVER) != 0){
            `sysivar[.iSYSFLAG] |= .sfKO_ROUND_MIDDLE;
          }
        }
        `sysivar[.iSPECIALFLAG] =
          `player ? (
            (!`isKO() || (`sysivar[.iSYSFLAG] & .sfOVER) == 0)
            ? (
              .lsSCREENBOUND | .lsMOVECAMERAX | .lsMOVECAMERAY
              | (`roundState() > 0 ? .lsPLAYERPUSH : 0))
            : (
              (`sysivar[.iSYSFLAG] & .sfKO_ROUND_MIDDLE) == 0
              ? .lsSCREENBOUND | .lsMOVECAMERAX | .lsMOVECAMERAY : 0))
          : 0;
        `sysfvar[.fANGLESCALEX] = `sysfvar[.fANGLESCALEY] = 1.0;
        `attackdist = (float)`sysivar[.iATTACK_DIST];
        `offsetx = 0.0;
        `offsety = 0.0;
        if(`stVal.hb.hitt1 > 0) `stVal.hb.hitt1--;
        if(`stVal.hb.hitt2 > 0) `stVal.hb.hitt2--;
        loop{index i = 0; while; do:
          if(`stVal.ho[i].time > 0) `stVal.ho[i].time--;
          i++;
        while i < #`stVal.ho:}
        branch{
        cond .super > 0 && `sysivar[.iSUPERMOVETIME] > 0:
          `sysivar[.iSUPERMOVETIME]--;
        cond .pause > 0 && `sysivar[.iPAUSEMOVETIME] > 0:
          `sysivar[.iPAUSEMOVETIME]--;
        }
      }
      if(`mver0 == 1){
        `sysivar[.iSPECIALFLAG] &= !.lasMask;
        `sysfvar[.fANGLESCALEX] = `sysfvar[.fANGLESCALEY] = 1.0;
        `offsetx = 0.0;
        `offsety = 0.0;
      }
      `minus = -3;
      if(`stVal.playerno == `playerno && `player) `state_3(::);
      `minus = -2;
      if(`player) `state_2(::);
      `minus = -1;
      if(`keyctrl && `stVal.playerno == `playerno) `state_1(::);
      `changeState2();
      if(!`cs1tmp){
        if(lc) `trSelfState(52, -1, -1);
        `minus = 0;
        `state(::);
        branch{
        cond `stVal.no == 5110:
          if(`sysivar[.iRECOVERTIME] <= 0 && !`isKO()){
            `trSelfState(5120, -1, -1);
          }
        cond
          `helperid == 0 && !`isKO() && `sysivar[.iLIFE] <= 0
          && `stVal.mov != .MovTy::H && `roundState() >= 2 && !.gs(.gsNOKO)
          :
          `trSelfState(5050, -1, -1);
        cond `stVal.no == 140:
          if(`trAnimTime()$.v.toI() == 0){
            `trSelfState(
              (int)(`stVal.typ == .StTy::C)*11
              + (int)(`stVal.typ == .StTy::A)*51, -1, -1);
          }
        }
        if(!`isBound()) `bind();
        if(!`isHitPaused()){
          `stVal.time++;
          `posUpdate();
        }
      }
    }
    `xScreenBound();
    `minus = 1;
    `acttmp += (int)`isActive() - (int)`isHitPaused();
    if(`acttmp > 0) branch{
    cond #`ani > 0:
      `curFrame = `ani~ani.currentFrame();
    else:
      `curFrame.new(0);
    }
    if(!`isHitPaused()){
      if(!`ls(.lsFRONTWCHANGE)) `frontw = `defFW();
      if(!`ls(.lsBACKWCHANGE)) `backw = `defBW();
      if(!`ls(.lsFEDGECHANGE)) `fedge = 0.0;
      if(!`ls(.lsBEDGECHANGE)) `bedge = 0.0;
    }
  }
  public void posUpdate()
  {
    bool nobindx = `sysivar[.iBINDTIME] == 0 || .m.isnan(`sysfvar[.fBINDPOSX]);
    bool nobindy = `sysivar[.iBINDTIME] == 0 || .m.isnan(`sysfvar[.fBINDPOSY]);
    if(nobindx) `ticOldX = `drawX = `sysfvar[.fX];
    if(nobindy) `ticOldY = `drawY = `sysfvar[.fY];
    if(!`ls(.lsPOSFREEZEX)){
      if(nobindx){
        `sysfvar[.fX] = `ticOldX + `sysfvar[.fVX]*(float)`facing + `veloff;
      }
      `veloff *= `sysfvar[.fSTAND_FRICTION]**2.0;
      if(#`veloff < 1.0) `veloff = 0.0;
      switch(`stVal.phy){
      case .StTy::S:
        `sysfvar[.fVX] *= `sysfvar[.fSTAND_FRICTION];
        if(#`sysfvar[.fVX] < 1.0) `sysfvar[.fVX] = 0.0;
      case .StTy::C:
        `sysfvar[.fVX] *= `sysfvar[.fCROUCH_FRICTION];
      }
    }
    if(!`ls(.lsPOSFREEZEY)){
      if(nobindy) `sysfvar[.fY] = `ticOldY + `sysfvar[.fVY];
      if(`stVal.phy == .StTy::A) `gravity();
    }
  }
  public void gravity()
  {
    if(!`ls(.lsPOSFREEZEY)) `sysfvar[.fVY] += `sysfvar[.fYACCEL];
  }
  public void bind()
  {
    if(`sysivar[.iBINDTIME] == 0) ret;
    ^`self c = .players.get(`sysivar[.iBINDTOID]);
    if(#c == 0 || `destmp){
      `setBindTime(0);
      ret;
    }
    if(!.m.isnan(`sysfvar[.fBINDPOSX])){
      float f =
        (float)(
          #`sysivar[.iBINDFACING] == 2 ? `sysivar[.iBINDFACING]/2 : c~facing);
      `setX(c~sysfvar[.fX] + f*`sysfvar[.fBINDPOSX]);
      `drawX += c~drawX - c~sysfvar[.fX];
      `ticOldX += c~ticOldX - c~sysfvar[.fX];
    }
    if(!.m.isnan(`sysfvar[.fBINDPOSY])){
      `setY(c~sysfvar[.fY] + `sysfvar[.fBINDPOSY]);
      `drawY += c~drawY - c~sysfvar[.fY];
      `ticOldY += c~ticOldY - c~sysfvar[.fY];
    }
    if(#`sysivar[.iBINDFACING] == 1) branch{
    cond `sysivar[.iBINDFACING] > 0: `facing = c~facing;
    cond `sysivar[.iBINDFACING] < 0: `facing = -c~facing;
    }
    if(c~isTarget(`id)){
      if(!.m.isnan(`sysfvar[.fBINDPOSX])){
        `setXV((float)(`facing*c~facing)*c~sysfvar[.fVX]);
      }
      if(!.m.isnan(`sysfvar[.fBINDPOSY])) `setYV(c~sysfvar[.fVY]);
    }
  }
  public void xScreenBound()
  {
    if(`ls(.lsSCREENBOUND)){
      float min, max;
      branch{
      cond `facing > 0:
        min = .com.xmin + `getEdge(`bedge);
        max = .com.xmax - `getEdge(`fedge);
      else:
        min = .com.xmin + `getEdge(`fedge);
        max = .com.xmax - `getEdge(`bedge);
      }
      .m.limRange!float?(`sysfvar[.fX]=, min, max);
    }
    .m.limRange!float?(
      `sysfvar[.fX]=, (float).stg~leftbound, (float).stg~rightbound);
  }
  public void update(
    float cvmin=, float cvmax=,
    float highest=, float lowest=, float leftest=, float rightest=)
  {
    if(.com.tickFrame()){
      if(`destmp){
        loop{
          index i = 0;
          ^`self c;
          while;
        do:
          c = .players.get(`targets[i]);
          if(
            #c > 0 && c~stVal.playerno != c~playerno
            && c~sysivar[.iBINDTOID] == `id)
          {
            c~trSelfState(5050, -1, -1);
          }
          i++;
        while i < #`targets:
        }
        `destroySelf();
        ret;
      }
      if(
        (`acttmp > 0 && `stVal.mov != .MovTy::H) || (
          `roundState() == 2 && `isKO()
          && (`sysivar[.iSYSFLAG] & .sfOVER) != 0))
      {
        `outTarget();
      }
      if(`acttmp > 0 && #`ani > 0) `ani~ani.updateSprite();
      `atktmp =
        (
          (`stVal.typ != .StTy::L && `stVal.mov != .MovTy::I)
          || `stVal.hit.reversal_attr > 0)
        && `isActive() ? `stVal.no : -1;
      if(`stVal.mov == .MovTy::H){
        if(.super <= 0 && .pause <= 0){
          `sysivar[.iPAUSEMOVETIME] = 0;
          `sysivar[.iSUPERMOVETIME] = 0;
        }
        `hittmp = (int)`isFall() + 1;
        if(
          `isActive()
          && (`stVal.no == 5100 || `stVal.no == 5070) && `stVal.time == 1)
        {
          `defencemul *= `sysfvar[.fFALL_DEFENCE_MUL];
          `stVal.hb.fallcount++;
        }
        if(`stVal.hb.damage != 0) branch{
        cond `stVal.hb.guarded != 0:
          `getcombo = 0;
          if(
            `addLife(-`stVal.hb.damage, true, true)
            && `helperindex == 0) branch
          {
            ^`self by;
            if(#`stVal.hb.by == 0) else;
            by = .players.get(`stVal.hb.by[-1].id);
            if(#by == 0) else;
          cond by~playerno == `playerno:
            .winty[(`playerno+1)&1] = .fgt.WinTy::Suicide;
          cond (by~playerno&1) == (`playerno&1):
            .winty[(`playerno+1)&1] = .fgt.WinTy::Teammate;
          else:
            .winty[(`playerno+1)&1] = .fgt.WinTy::C;
          }
        else:
          if(
            `addLife(-`stVal.hb.damage, true, true)
            && `helperindex == 0) branch
          {
            ^`self by;
            if(#`stVal.hb.by == 0) else;
            by = .players.get(`stVal.hb.by[-1].id);
            if(#by == 0) else;
          cond (by~playerno&1) == (`playerno&1):
            branch{
            cond by~playerno == `playerno:
              .winty[(`playerno+1)&1] = .fgt.WinTy::Suicide;
            else:
              .winty[(`playerno+1)&1] = .fgt.WinTy::Teammate;
            }
          else:
            `setEnemyWinty();
          }
        }
        `stVal.hb.damage = 0;
      }
      if(
        !`isKO() && (
          .m.inRange!int?(120, 159, `stVal.no) || (
            `isActive() && `canCtrl() && #`cmd > 0 && `cmd~buffer~B > 0 && (
              (`stVal.typ == .StTy::S && !`ls(.lsNOSTANDGUARD))
              || (`stVal.typ == .StTy::C && !`ls(.lsNOCROUCHGUARD))
              || (`stVal.typ == .StTy::A && !`ls(.lsNOAIRGUARD))))))
      {
        `sysivar[.iSPECIALFLAG] |= .lsGUARD;
      }
      if(`isActive()){
        if(`stVal.mov != .MovTy::H){
          if(`hittmp > 0) `hittmp = 0;
          `defencemul = (float)`sysivar[.iDEFENCE] / 100.0;
          `stVal.hb.damage = 0;
          `stVal.hb.hittime = -1;
          `stVal.hb.hitshaketime = 0;
          `stVal.hb.fallf = 0;
          `stVal.hb.fallcount = 0;
          `getcombo = 0;
        }
        if(`stVal.hb.hitshaketime > 0) `stVal.hb.hitshaketime--;
        if(`stVal.hb.hitshaketime <= 0 && `stVal.hb.hittime >= 0){
          `stVal.hb.hittime--;
        }
        if(`stVal.hb.fallf != 0) `stVal.fallTime++;
        if(
          (`stVal.mov == .MovTy::H || `stVal.no == 52) && `sysfvar[.fY] == 0.0
          && #(`sysfvar[.fX]-`ticOldX) >= 1.0 && `stVal.time % 3 == 0)
        {
          `makeDust(0.0, 0.0);
        }
      }
    }
    if(`acttmp > 0){
      float sp = .com.tickInterpola();
      if(!`ls(.lsPOSFREEZEX)){
        `drawX = `sysfvar[.fX] - (`sysfvar[.fX] - `ticOldX) * (1.0 - sp);
      }
      if(!`ls(.lsPOSFREEZEY)){
        `drawY = `sysfvar[.fY] - (`sysfvar[.fY] - `ticOldY) * (1.0 - sp);
      }
    }
    if(`ls(.lsMOVECAMERAX)){
      leftest = .m.max!float?(.com.xmin)<, .m.min!float?(
        `drawX-`getEdge(`facing > 0 ? `bedge : `fedge), leftest);
      rightest = .m.min!float?(.com.xmax)<, .m.max!float?(
        `drawX+`getEdge(`facing > 0 ? `fedge : `bedge), rightest);
      if(
        `isActive() && !`ls(.lsPOSFREEZEX)
        && (`sysivar[.iBINDTIME] == 0 || .m.isnan(`sysfvar[.fBINDPOSX])))
      {
        cvmin = .m.min!float?(cvmin, `sysfvar[.fVX]*(float)`facing);
        cvmax = .m.max!float?(cvmax, `sysfvar[.fVX]*(float)`facing);
      }
    }
    if(`ls(.lsMOVECAMERAY)){
      highest = .m.min!float?(`drawY, highest);
      lowest = .m.min!float?(0.0)<, .m.max!float?(`drawY, lowest);
    }
  }
  public void posReset(float p1x, float p2x)
  {
    `facing = (`playerno&1) == 0 ? 1 : -1;
    `setX(
      ((`playerno&1) == 0 ? p1x : p2x)
      + (float)(`playerno*-`facing / 2) * .com.P1P3Dist);
    `setY(0.0);
    `setXV(0.0);
    `setYV(0.0);
  }
  void nikou<if_t, ff_t>(&.Var rtn=, &.Var var1, &.Var var2)
  {
    &.Var v1 = var1, v2 = var2;
    if(v1.isSF()) v1.setB(false);
    if(v2.isSF()) v2.setB(false);
    branch{
    cond v1.typ == v2.typ:
      branch{
      cond v1.typ == .VarTy::Int:
        if_t(rtn=, v1.i, v2.i);
      else:
        ff_t(rtn=, v1.f, v2.f);
      }
    else:
      branch{
      cond v1.typ == .VarTy::Int:
        ff_t(rtn=, (float)v1.i, v2.f);
      else:
        ff_t(rtn=, v1.f, (float)v2.i);
      }
    }
  }
  public void setLife(int l)
  {
    `sysivar[.iLIFE] = .m.max!int?(0)<, .m.min!int?(`sysivar[.iLIFEMAX])<, l;
  }
  public int getDamage(int damage, bool kill, bool absolute, float atkmul)
  {
    if(damage == 0 || (!absolute && atkmul == 0.0)) ret 0;
    type _t = double;
    ret
      (int).m.min!_t?((*_t)(.m.max!int?(0, `sysivar[.iLIFE]-(int)!kill)))<,
      .m.max!_t?((*_t)(`sysivar[.iLIFE]-`sysivar[.iLIFEMAX]))<,
      .m.ceil((*_t)damage*(absolute ? 1.0 : atkmul/`defencemul));
  }
  public bool addLife(int l, bool kill, bool absolute)
  {
    if(l == 0 || `roundState() == 3) ret false;
    bool foo = `sysivar[.iLIFE] > 0;
    `sysivar[.iLIFE] +=
      (int).m.max!double?((double)-`sysivar[.iLIFE])<,
      .m.min!double?((double)(`sysivar[.iLIFEMAX]-`sysivar[.iLIFE]))<,
      .m.floor((double)l / (absolute ? 1.0 : `defencemul));
    if(!kill && foo && `sysivar[.iLIFE] <= 0) `sysivar[.iLIFE] = 1;
    if(`helperindex == 0 && `sysivar[.iLIFE] == 0){
      if(!foo) break;
      branch{
      cond `stVal.mov == .MovTy::H || `stVal.playerno != `playerno:
        `setEnemyWinty();
      else:
        if(`helperindex == 0) .winty[(`playerno+1)&1] = .fgt.WinTy::Suicide;
      }
      ret true;
    }
    ret false;
  }
  public void setPower(int p)
  {
    if(.roundEnd()) ret;
    `sysivar[.iPOWER] = .m.max!int?(0)<, .m.min!int?(`sysivar[.iPOWERMAX])<, p;
  }
  public int getSharePower()
  {
    ret .chars[`playerno & (.com.powershare?1:-1)][0]~sysivar[.iPOWER];
  }
  public void addPower(int p)
  {
    .chars[`playerno&(.com.powershare?1:-1)][0]~setPower(`getSharePower() + p);
  }
  public void setFacing(int f)
  {
    if(f == 0) ret;
    if((`facing < 0) != (f < 0)){
      `facing *= -1;
      `sysfvar[.fVX] *= -1.0;
      `stVal.hb.xvel *= -1.0;
    }
  }
  void setFWidth(float f)
  {
    `frontw = `defFW() + f;
    `sysivar[.iSPECIALFLAG] |= .lsFRONTWCHANGE;
  }
  void setBWidth(float b)
  {
    `backw = `defBW() + b;
    `sysivar[.iSPECIALFLAG] |= .lsBACKWCHANGE;
  }
  void setFEdge(float f)
  {
    `fedge = f;
    `sysivar[.iSPECIALFLAG] |= .lsFEDGECHANGE;
  }
  void setBEdge(float b)
  {
    `bedge = b;
    `sysivar[.iSPECIALFLAG] |= .lsBEDGECHANGE;
  }
  void setPauseTime(int pausetime, int movetime)
  {
    if(
      !pausetime < .pausetime || `playerno != `stVal.playerno
      || .pauseplayer == `playerno)
    {
      .pausetime = !pausetime;
      .pauseplayer = `playerno;
    }
    `sysivar[.iPAUSEMOVETIME] = .m.max!int?(0, movetime);
    branch{
    cond `sysivar[.iPAUSEMOVETIME] > pausetime:
      `sysivar[.iPAUSEMOVETIME] = 0;
    cond .pause > 0 && `sysivar[.iPAUSEMOVETIME] > 0:
      `sysivar[.iPAUSEMOVETIME]--;
    }
  }
  void setSuperPauseTime(int pausetime, int movetime)
  {
    if(
      !pausetime < .supertime || `playerno != `stVal.playerno
      || .superplayer == `playerno)
    {
      .supertime = !pausetime;
      .superplayer = `playerno;
    }
    `sysivar[.iSUPERMOVETIME] = .m.max!int?(0, movetime);
    branch{
    cond `sysivar[.iSUPERMOVETIME] > pausetime:
      `sysivar[.iSUPERMOVETIME] = 0;
    cond .super > 0 && `sysivar[.iSUPERMOVETIME] > 0:
      `sysivar[.iSUPERMOVETIME]--;
    }
  }
  void setHitdefDefault(&.Hitdef h=, bool proj)
  {
    if((h.attr & 63) == 0 || (h.attr & !63) == 0) h.attr = 0;
    if(!proj && h.guard_dist < 0) h.guard_dist = `sysivar[.iATTACK_DIST];
    if(h.guard_pausetime < 0) h.guard_pausetime = h.pausetime;
    if(h.guard_shaketime < 0) h.guard_shaketime = h.shaketime;
    if(
      h.hitonce < 0
      || (h.attr&((int).AtTy::NT|(int).AtTy::ST|(int).AtTy::HT)) != 0)
    {
      h.hitonce = 1;
    }
    if(h.guard_hittime < 0) h.guard_hittime = h.ground_hittime;
    if(h.guard_slidetime < 0) h.guard_slidetime = h.guard_hittime;
    if(h.guard_ctrltime < 0) h.guard_ctrltime = h.guard_slidetime;
    if(.m.isnan(h.ground_velocityx)) h.ground_velocityx = 0.0;
    if(.m.isnan(h.ground_velocityy)) h.ground_velocityy = 0.0;
    if(.m.isnan(h.air_velocityx)) h.air_velocityx = 0.0;
    if(.m.isnan(h.air_velocityy)) h.air_velocityy = 0.0;
    if(.m.isnan(h.guard_velocity)) h.guard_velocity = h.ground_velocityx;
    if(h.airguard_ctrltime < 0) h.airguard_ctrltime = h.guard_ctrltime;
    if(.m.isnan(h.airguard_velocityx)){
      h.airguard_velocityx = h.air_velocityx*1.5;
    }
    if(.m.isnan(h.airguard_velocityy)){
      h.airguard_velocityy = h.air_velocityy*0.5;
    }
    if(.m.isnan(h.down_velocityx)) h.down_velocityx = h.air_velocityx;
    if(h.air_fall == .com.IERR) h.air_fall = h.ground_fall;
    if(h.fall.animtype == .AnimTy::Unknown) branch{
    cond h.air_animtype != .AnimTy::Unknown:
      h.fall.animtype = h.air_animtype;
    cond (int)h.animtype < 3:
      h.fall.animtype = .AnimTy::Back;
    else:
      h.fall.animtype = h.animtype;
    }
    if(h.air_animtype == .AnimTy::Unknown) h.air_animtype = h.animtype;
    if(h.air_type == .ReactTy::Unknown) h.air_type = h.ground_type;
    if(h.forcestand == .com.IERR){
      h.forcestand = (int)(h.ground_velocityy != 0.0);
    }
    if(.m.isnan(h.ground_cornerpush_veloff)){
      h.ground_cornerpush_veloff =
        (h.attr & (int).StTy::A) != 0 ? 0.0 : h.guard_velocity*1.3;
    }
    if(.m.isnan(h.air_cornerpush_veloff)){
      h.air_cornerpush_veloff = h.ground_cornerpush_veloff;
    }
    if(.m.isnan(h.down_cornerpush_veloff)){
      h.down_cornerpush_veloff = h.ground_cornerpush_veloff;
    }
    if(.m.isnan(h.guard_cornerpush_veloff)){
      h.guard_cornerpush_veloff = h.ground_cornerpush_veloff;
    }
    if(.m.isnan(h.airguard_cornerpush_veloff)){
      h.airguard_cornerpush_veloff = h.ground_cornerpush_veloff;
    }
    if(h.hitgetpower == .com.IERR){
      h.hitgetpower = (int)(.cfg.Attack_LifeToPowerMul*(float)(h.hitdamage));
    }
    if(h.guardgetpower == .com.IERR){
      h.guardgetpower =
        (int)(.cfg.Attack_LifeToPowerMul*(float)(h.hitdamage)*0.5);
    }
    if(h.hitgivepower == .com.IERR){
      h.hitgivepower = (int)(.cfg.GetHit_LifeToPowerMul*(float)(h.hitdamage));
    }
    if(h.guardgivepower == .com.IERR){
      h.guardgivepower =
        (int)(.cfg.GetHit_LifeToPowerMul*(float)(h.hitdamage)*0.5);
    }
  }
  void playSound(
    bool f, bool lw, bool lp, int g, int s, int ch,
    int vo, float p, float fr, ^float x)
  {
    if(g < 0) ret;
    ^&.snd.Sound sou = `newChannel(ch, lw);
    if(#sou == 0) ret;
    branch{
    cond f:
      if(#.fight~fsn == 0) break;
      sou~sound = .fight~fsn~getSound(g, s);
    else:
      if(#`sn == 0) break;
      sou~sound = `sn~getSound(g, s);
    }
    sou~chrx = x;
    branch{
    cond `mver0 == 1:
      sou~setVol(!f ? `sysivar[.iVOLUME]*vo/100 : 256);
    else:
      sou~setVol(vo + (!f ? `sysivar[.iVOLUME] : 256));
    }
    sou~loop_ = lp;
    sou~lowpriority = lw;
    sou~setPan(p * (float)`facing);
    sou~freqmul = fr;
    sou~fidx = 0.0;
  }
  public bool ctrlOver()
  {
    ret
     .com.time == 0
     || .com.intro < -(.fight~ro.over_hittime + .fight~ro.over_waittime);
  }
  public bool canCtrl()
  {
    ret
      `ctrl && !`isKO()
      && (`helperindex != 0 || .com.intro <= 0) && !`ctrlOver();
  }
  public void setCtrl(bool c)
  {
    `ctrl = c;
  }
  public void destroySelf()
  {:<-
    if(`helperindex <= 0) ret;
    loop{
      index i = 0;
      ^`self c;
      while;
    do:
      c = .players.get(`targets[i]);
      if(#c > 0){
        c~byBindClear();
        c~stVal.hb.dropByid(`id);
      }
      i++;
    while i < #`targets:
    }
    if(`parentindex >= 0) loop{index i = 0; while; do:
      if(.chars[`playerno][`parentindex]~children[i] == `helperindex){
        .chars[`playerno][`parentindex]~children[i] = -1;
        break, break;
      }
      i++;
    while i < #.chars[`playerno][`parentindex]~children:
    break:
      `parentindex *= -1;
    }
    loop{index i = 0; while; do:
      if(`children[i] >= 0){
        .chars[`playerno][`children[i]]~parentindex *= -1;
        `children[i] = -1;
      }
      i++;
    while i < #`children:
    }
    ^&.com.PalFX fx = `getPalfx();
    if(fx~player == `id) fx~time = 0;
    .players.destroy(`id);
    `helperindex = -1;
  }
  public void setX(float x)
  {
    `sysfvar[.fX] = `ticOldX = `drawX = x;
    `enemyn.new(0);
    if(`player) loop{index i = (`playerno+1) & 1; while; do:
      loop{index j = 0; while; do:
        .chars[i][j]~enemyn.new(0);
        j++;
      while j < #.chars[i]:
      }
      i += 2;
    while i < #.chars:
    }
  }
  public void setY(float y)
  {
    `sysfvar[.fY] = `ticOldY = `drawY = y;
  }
  public void setXV(float xv)
  {
    `sysfvar[.fVX] = xv;
  }
  public void setYV(float yv)
  {
    `sysfvar[.fVY] = yv;
  }
  public void setAngle(float a)
  {
    `sysfvar[.fANGLE] = a;
    `angleset |= a != 0.0;
  }
  public void setPos<_t>(_t o=, int pt, float x, float y, int facing)
  {
    branch{
    cond facing < 0:
      o.facing = -1;
    else:
      o.facing = 1;
    }
    switch(pt){
    case 0://p1
      if(!.m.isnan(x)) o.setX(`sysfvar[.fX] + (float)`facing*x);
      if(!.m.isnan(y)) o.setY(`sysfvar[.fY] + y);
      o.facing *= `facing;
    case 1://p2
      {
        ^`self c = .players.enemyNear(`=, 0);
        if(#c == 0) break;
        if(!.m.isnan(x)) o.setX(c~sysfvar[.fX] + (float)c~facing*x);
        if(!.m.isnan(y)) o.setY(c~sysfvar[.fY] + y);
        o.facing *= c~facing;
      }
    case 2, 3://front, back
      if(!.m.isnan(x)) branch{
      cond (`facing > 0 && pt == 2) || (`facing < 0 && pt == 3):
        o.setX(
          .com.screenx
          + ((float).com.GameWidth - x*(pt == 2 ? -1.0 : 1.0))/.com.scale);
      else:
        o.setX(.com.screenx + x*(pt == 2 ? -1.0 : 1.0)/.com.scale);
      }
      if(!.m.isnan(y)) o.setY(.com.screeny + y/.com.scale);
      o.facing *= `facing;
    case 4://left
      if(!.m.isnan(x)) o.setX(.com.screenx + x/.com.scale);
      if(!.m.isnan(y)) o.setY(.com.screeny + y/.com.scale);
    case 5://right
      if(!.m.isnan(x)){
        o.setX(.com.screenx + ((float).com.GameWidth + x)/.com.scale);
      }
      if(!.m.isnan(y)) o.setY(.com.screeny + y/.com.scale);
    }
  }
  public void setAlpha(int trans, int salpha=, int dalpha=)
  {
    switch(trans){
    case 0://default
      salpha = .com.IERR;
      dalpha = .com.IERR;
    case 1://none
      salpha = 255;
      dalpha = 0;
    case 2://add
      salpha = 255;
      dalpha = 255;
    case 3://addalpha
      if(salpha != .com.IERR){
        salpha = .m.max!int?(0)<, .m.min!int?(255)<, salpha;
      }
      if(dalpha != .com.IERR){
        dalpha = .m.max!int?(0)<, .m.min!int?(255)<, dalpha;
      }
      if(salpha == 1 && dalpha == 255) salpha = 0;
    case 4://add1
      salpha = 255;
      dalpha = 128;
    case 5://sub
      salpha = 1;
      dalpha = 255;
    }
  }
  public void setBindTime(int time)
  {
    `sysivar[.iBINDTIME] = time;
    if(time == 0) `sysivar[.iBINDTOID] = -1;
  }
  public void setBindToId(`self to=)
  {
    `sysivar[.iBINDTOID] = to.id;
    if(to.sysivar[.iBINDTOID] == `id) to.setBindTime(0);
    `sysivar[.iBINDFACING] = to.facing*2;
  }
  public void makeDust(float x, float y)
  {
    index i;
    ^&.Explod e = `newExplod(i=);
    if(#e==0)ret;
    e~ani = .fight~getAction(120);
    e~ontop = 0;
    e~sprpriority = .consts.int_t::MAX;
    e~ownpal = 1;
    e~offsetx = x;
    e~offsety = y;
    e~setPos(`=);
    `insertExplod(i);
  }
  public void trPlayerID()
  {
    .c = .players.get(.v.toI());
  }
  public void trEnemy()
  {
    .c = .players.enemy(`playerno, .v.toI());
  }
  public void trEnemyNear()
  {
    .c = .players.enemyNear(`=, .v.toI());
  }
  public void trRoot()
  {
    if(`helperindex == 0){
      .c.new(0);
      ret;
    }
    .c = .chars[`playerno][0];
  }
  public void trParent()
  {
    branch{
    cond `parentindex == .com.IERR:
      .c.new(0);
    else:
      .c = .chars[`playerno][#`parentindex];
    }
  }
  public void trPartner()
  {
    if(.v.toI() > 0){
      .c.new(0);
      ret;
    }
    .c =
      #.chars[`playerno+2 & 3] > 0
      ? .chars[`playerno+2 & 3][0] : .consts.null!`self?();
  }
  public void trHelper()
  {
    int id = .v.toI();
    loop{index i = 1; while; do:
      if(
        .chars[`playerno][i]~helperindex > 0 && !.chars[`playerno][i]~destmp
        && (id <= 0 || id == .chars[`playerno][i]~helperid))
      {
        .c = .chars[`playerno][i];
        ret;
      }
      i++;
    while i < #.chars[`playerno]:
    }
    .c = .consts.null!`self?();
  }
  public void trTarget()
  {
    int id = .v.toI();
    loop{index i = 0; while; do:
      .c = .players.get(`targets[i]);
      if(#.c > 0 && (id < 0 || .c~stVal.hb.hitid == id)) ret;
      i++;
    while i < #`targets:
    }
    .c = .consts.null!`self?();
  }
  public void trRange(
    &.Var v, bool not, bool minequ, &.Var min, &.Var max, bool maxequ)
  {
    bool b1 = (minequ ? `trGrE(v, min) : `trGr(v, min))$.v.isT();
    bool b2 = (maxequ ? `trLsE(v, max) : `trLs(v, max))$.v.isT();
    .v.setB((b1&b2) ^ not);
  }
  public void trEqu(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 == i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 == f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trNEqu(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 != i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 != f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trGr(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 > i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 > f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trGrE(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 >= i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 >= f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trLs(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 < i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 < f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trLsE(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setB(i1 <= i2);}
    void f(&.Var r=, float f1, float f2){r.setB(f1 <= f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trAnd(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(r.i = i1 & i2);}
    void f(&.Var r=, float f1, float f2){r.setI((int)f1 & (int)f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trXor(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(i1 ^ i2);}
    void f(&.Var r=, float f1, float f2){r.setI((int)f1 ^ (int)f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trOr(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(i1 | i2);}
    void f(&.Var r=, float f1, float f2){r.setI((int)f1 | (int)f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trNot()
  {
    if(.v.isSF()) ret;
    .v.setI(!.v.toI());
  }
  public void trBoolAnd(&.Var v1, &.Var v2)
  {
    .v.setB(v1.isT() && v2.isT());
  }
  public void trBoolOr(&.Var v1, &.Var v2)
  {
    .v.setB(v1.isT() || v2.isT());
  }
  public void trIfelse(&.Var b, &.Var v1, &.Var v2)
  {
    .v = b.isT() ? v1 : v2;
  }
  public void trBoolNot()
  {
    .v.setB(!.v.isT());
  }
  public void trMinus()
  {
    .v.i *= -1;
    .v.f *= -1.0;
  }
  public void trAbs()
  {
    .v.i = #.v.i;
    .v.f = #.v.f;
  }
  public void trFloor()
  {
    if(.v.typ != .VarTy::Float) ret;
    .v.setF(.m.floor(.v.f));
    if(!.v.isSF()) .v.setI(.v.toI());
  }
  public void trCeil()
  {
    if(.v.typ != .VarTy::Float) ret;
    .v.setF(.m.ceil(.v.f));
    if(!.v.isSF()) .v.setI(.v.toI());
  }
  public void trSin()
  {
    .v.setF(.m.sin(.v.toF()));
  }
  public void trCos()
  {
    if(!.v.isSF()) .v.setF(.m.cos(.v.toF()));
  }
  public void trTan()
  {
    if(!.v.isSF()) .v.setF(.m.tan(.v.toF()));
  }
  public void trAsin()
  {
    if(.v.isSF()) ret;
    double x = .v.toF();
    if(!.m.inRange!double?(-1.0, 1.0, x)){
      .v.setSF();
      ret;
    }
    .v.setF(.m.asin(x));
  }
  public void trAcos()
  {
    if(.v.isSF()) ret;
    double x = .v.toF();
    if(!.m.inRange!double?(-1.0, 1.0, x)){
      .v.setSF();
      ret;
    }
    .v.setF(.m.acos(x));
  }
  public void trAtan()
  {
    if(!.v.isSF()) .v.setF(.m.atan(.v.toF()));
  }
  public void trLog(&.Var v1, &.Var v2)
  {
    if(.v.isSF()) ret;
    double x = v1.toF(), y = v2.toF();
    if(x < 0.0 || y < 0.0){
      .v.setSF();
      ret;
    }
    .v.setF(.m.log(x, y));
  }
  public void trLn()
  {
    if(.v.isSF()) ret;
    double x = .v.toF();
    if(x < 0.0){
      .v.setSF();
      ret;
    }
    .v.setF(.m.ln(x));
  }
  public void trExp()
  {
    if(!.v.isSF()) .v.setF(.m.exp(.v.toF()));
  }
  public void trMul(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(i1 * i2);}
    void f(&.Var r=, float f1, float f2){r.setF(f1 * f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trDiv(&.Var v1, &.Var v2)
  {:<-
    public void i(&.Var r=, int   i1, int   i2)
    {
      branch{
      cond i2 == 0:
        r.setSF();
      else:
        r.setI(i1 / i2);
      }
    }
    void f(&.Var r=, float f1, float f2){r.setF(f1 / f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trMod(&.Var v1, &.Var v2)
  {:<-
    public void i(&.Var r=, int   i1, int   i2)
    {
      branch{
      cond i2 == 0:
        r.setSF();
      else:
        r.setI(i1 % i2);
      }
    }
    void f(&.Var r=, float f1, float f2){
      `trMod:<-i(r=, (int)f1, (int)f2);
    }
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trAdd(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(i1 + i2);}
    void f(&.Var r=, float f1, float f2){r.setF(f1 + f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trSub(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int   i1, int   i2){r.setI(i1 - i2);}
    void f(&.Var r=, float f1, float f2){r.setF(f1 - f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public void trPow(&.Var v1, &.Var v2)
  {:<-
    void i(&.Var r=, int i1, int i2)
    {//winmugenのバグの再現
      r.typ = .VarTy::Int;
      branch{
      cond i2 < 0:
        branch{
          float f = (float)i1**(float)i2;
        cond .chars[`stVal.playerno]<>~mver0 == 1:
          r.setF(f);
        else:
          .mes.veryUnsafeCopy!int, float?(r.i=, f=);
          r.i = r.i << 29;
        }
      else:
        {
          int hb = -1;
          int tmp = i1;
          loop{while; do: hb++; while (uint)i2>>(uint)(hb+1) != 0x0:}
          r.i = 1;
          loop{int bit = 0; while; do:
            if(
              (
                i2 & (int)1<<(
                  bit == hb || .chars[`stVal.playerno]<>~mver0 == 1
                  ? bit : (hb-1)-bit))
              != 0)
            {
              r.i *= tmp;
            }
            tmp *= tmp;
            bit++;
          while bit <= hb:}
        }
      }
    }
    void f(&.Var r=, float f1, float f2){r.setF(f1**f2);}
    `nikou!i, f?(.v=, v1, v2);
  }
  public int trId()
  {
    ret `id < 0 ? !`id : `id;
  }
  public void trSetX()
  {
    `setX(.v.toF());
  }
  public void trSetY()
  {
    `setY(.v.toF());
  }
  public void trAddX()
  {
    `setX(`sysfvar[.fX] + (float)`facing*.v.toF());
  }
  public void trAddY()
  {
    `setY(`sysfvar[.fY] + .v.toF());
  }
  public void trVelSetX()
  {
    `setXV(.v.toF());
  }
  public void trVelSetY()
  {
    `setYV(.v.toF());
  }
  public void trVelAddX()
  {
    `sysfvar[.fVX] += .v.toF();
  }
  public void trVelAddY()
  {
    `sysfvar[.fVY] += .v.toF();
  }
  public void trVelMulX()
  {
    `sysfvar[.fVX] *= .v.toF();
  }
  public void trVelMulY()
  {
    `sysfvar[.fVY] *= .v.toF();
  }
  public void trAngleSet()
  {
    `setAngle(.v.toF());
  }
  public void trAnim()
  {
    .v.setI(`animno);
  }
  public void trAnimTime()
  {
    branch{
    cond `animpno < 0 || #`ani == 0 || #`ani~ani.frames == 0:
      .v.setI(0);
    else:
      .v.setI(`ani~ani.animTime());
    }
  }
  public void trAnimElemTime()
  {
    int e = .v.toI();
    if(e < 1 || #`ani == 0 || e > #`ani~ani.frames){
      .v.setSF();
      ret;
    }
    .v.setI(`ani~ani.animElemTime(e));
  }
  public void trAnimElemNo()
  {
    int tim = .v.toI();
    if(#`ani == 0 || tim < -`ani~ani.sumtime){
      .v.setSF();
      ret;
    }
    .v.setI(`ani~ani.animElemNo(tim));
  }
  public void trChangeAnim(int no)
  {
    *`ani.self tmp = `getAction(no);
    if(#tmp == 0) ret;
    `ani = tmp;
    `animno = no;
    `animpno = `playerno;
    `sysfvar[.fCLSNXSCALE] = `sysfvar[.fXSCALE];
    `sysfvar[.fCLSNYSCALE] = `sysfvar[.fYSCALE];
    `ani~ani.updateSprite();
  }
  public void trChangeAnim2(int no)
  {
    *`ani.self tmp = .chars[`stVal.playerno][0]~getAction(no);
    if(#tmp == 0) ret;
    `ani = tmp;
    `animno = no;
    `animpno = `stVal.playerno;
    `sysfvar[.fCLSNXSCALE] = .chars[`stVal.playerno][0]~sysfvar[.fXSCALE];
    `sysfvar[.fCLSNYSCALE] = .chars[`stVal.playerno][0]~sysfvar[.fYSCALE];
    `ani~ani.sff = `sf;
    `ani~ani.updateSprite();
  }
  public void trAnimExist(int pid)
  {
    if(.v.isSF()) ret;
    .v.setB(
      #.chars[`id == pid ? `stVal.playerno : `playerno][0]~getAction(.v.toI())
      > 0);
  }
  public void trSelfAnimExist()
  {
    if(.v.isSF()) ret;
    .v.setB(#`getAction(.v.toI()) > 0);
  }
  public void trPlayerIDExist()
  {
    if(.v.isSF()) ret;
    .v.setB(#.players.get(.v.toI()) > 0);
  }
  public void trSysIVar()
  {
    int i = .v.toI();
    if(.v.isSF() || i < 0 || (`minus != 11 && i >= 5)){
      .v.setSF();
      ret;
    }
    .v.setI(`sysivar[i]);
  }
  public void trSetSysIVar(&.Var idx, &.Var v)
  {
    int i = idx.toI();
    if(.v.isSF() || i < 0 || (`minus != 11 && i >= 5)){
      .v.setI(v.toI());
      ret;
    }
    .v.setI(`sysivar[i] = v.toI());
  }
  public void trSysFVar()
  {
    int i = .v.toI();
    if(.v.isSF() || i < 0 || (`minus != 11 && i >= 5)){
      .v.setSF();
      ret;
    }
    .v.setF(`sysfvar[i]);
  }
  public void trSetSysFVar(&.Var idx, &.Var v)
  {
    int i = idx.toI();
    if(.v.isSF() || i < 0 || (`minus != 11 && i >= 5)){
      .v.setF(v.toF());
      ret;
    }
    .v.setF(`sysfvar[i] = v.toF());
  }
  public void trIVar()
  {
    int i = .v.toI();
    if(.v.isSF() || i < 0 || i >= 60){
      .v.setSF();
      ret;
    }
    .v.setI(`ivar[i]);
  }
  public void trSetIVar(&.Var idx, &.Var v)
  {
    int i = idx.toI();
    if(.v.isSF() || i < 0 || i >= 60){
      .v.setI(v.toI());
      ret;
    }
    .v.setI(`ivar[i] = v.toI());
  }
  public void trFVar()
  {
    int i = .v.toI();
    if(.v.isSF() || i < 0 || i >= 40){
      .v.setSF();
      ret;
    }
    .v.setF(`fvar[i]);
  }
  public void trSetFVar(&.Var idx, &.Var v)
  {
    int i = idx.toI();
    if(.v.isSF() || i < 0 || i >= 40){
      .v.setF(v.toF());
      ret;
    }
    .v.setF(`fvar[i] = v.toF());
  }
  public bool changeState1(int p, int n)
  {:<-
    if(.changeStateNest >= 2500){
      %char buf .=
        "2500 loops: " .= `name .= ", " .= .s.iToS(`stVal.prevno) .= " -> "
        .= .s.iToS(`stVal.no) .= " -> " .= .s.iToS(n);
      .al.alert!self?(buf);
      ret false;
    }
    if(n < 0) ret false;
    if(!`cs1tmp) `stVal.prevno = `stVal.no;
    if(`stVal.playerno != `playerno && p != `stVal.playerno){
      `enemyExplodsRemove(`stVal.playerno);
    }
    `stVal.no = n;
    `stVal.playerno = p;
    `stVal.time = 0;
    if((n >= 170 && n < 190) || (n >= 5150 && n < 5160)){
      `sysivar[.iSYSFLAG] |= .sfOVER;
    }
    `cs1tmp = true;
    ret true;
  }
  public bool changeState1kai(int p, int no)
  {
    ret `changeState1(p, .m.max!int?(0, no));
  }
  public void changeState2()
  {
    if(`cs1tmp && (!`isHitPaused() || `mver0 == 1)){
      ^&`State st = .states[`stVal.playerno].get(`stVal.no);
      branch{
      cond #st > 0:
        `state = st~state;
      else:
        `trDestroySelf();
        `state = `dummy;
      }
      `state(::);
      `cs1tmp = false;
    }
  }
  public void trChangeState2(int n, int p, int anim, int ctrl)
  {
    if(anim >= 0) `trChangeAnim(anim);
    if(ctrl >= 0) `setCtrl(ctrl != 0);
    if(`changeState1kai(p, n)){
      if(`minus <= 0) `changeState2();
      if(`minus == 0 && `id >= 0 && !`cs1tmp){
        .changeStateNest++;
        `state(::);
        .changeStateNest--;
      }
    }
  }
  public void trChangeState(int no, int anim, int ctrl)
  {
    `trChangeState2(no, `stVal.playerno, anim, ctrl);
  }
  public void trSelfState(int no, int anim, int ctrl)
  {
    `trChangeState2(no, `playerno, anim, ctrl);
  }
  bool commandSub(int pno, int i)
  {
    ^&.cmd.Command cl = `cmd[pno].at(i);
    if(#cl > 0 && `key < 0){
      ^/char name = cl~name;
      if(
        `helperindex == 0 && (#name == 1 || .s.equ(name[0..4], "hold"))) break;
      ret i >= 0 && i == `cpucmd;
    }
    loop{index i = 0; while; do:
      if(cl[i].curbuftime > 0) ret true;
      i++;
    while i < #cl:}
    ret false;
  }
  public bool commandByName(^/char name)
  {
    if(!`keyctrl || #`cmd == 0) ret false;
    ^index ci = `cmd[`stVal.playerno].cTable~get(name);
    if(#ci == 0) ret false;
    ret `commandSub(`stVal.playerno, ci<>);
  }
  public void trCommand(int pno, int i)
  {
    if(!`keyctrl || #`cmd == 0){
      .v.setI(0);
      ret;
    }
    .v.setI((int)`commandSub(pno, i));
  }
  public void trP2Life()
  {
    ^`self e = .players.enemyNear(`=, 0);
    .v.setI(e~sysivar[.iLIFE]);
  }
  public void trTurn()
  {
    `setFacing(-`facing);
  }
  public void trP2DistX()
  {
    ^`self e = .players.enemyNear(`=, 0);
    if(!e~isAlive() && (e~sysivar[.iSYSFLAG] & .sfOVER) != 0){
      .v.setF(0.0);
      ret;
    }
    .v.setF((float)((int)`facing*(int)(e~sysfvar[.fX] - `sysfvar[.fX])));
  }
  public void trP2DistY()
  {
    ^`self e = .players.enemyNear(`=, 0);
    .v.setF(e~sysfvar[.fY] - `sysfvar[.fY]);
  }
  public void trP2BodyDistX()
  {
    ^`self e = .players.enemyNear(`=, 0);
    if(!e~isAlive() && (e~sysivar[.iSYSFLAG] & .sfOVER) != 0){
      .v.setF(0.0);
      ret;
    }
    float dist = e~sysfvar[.fX] - `sysfvar[.fX];
    bool bar = dist == 0.0 || (dist < 0.0) ^ (e~facing < 0);
    .v.setF()<, (float)(
      (int)(
        (float)`facing*(dist + (float)e~facing * (bar ? e~frontw : -e~backw))
        - `frontw));
  }
  public void trRootDistX()
  {
    if(`helperindex == 0){
      .v.setSF();
      ret;
    }
    .v.setF()<, (float)(
      (int)`facing*(int)(.chars[`playerno][0]~sysfvar[.fX] - `sysfvar[.fX]));
  }
  public void trRootDistY()
  {
    if(`helperindex == 0){
      .v.setSF();
      ret;
    }
    .v.setF(
      (.chars[`playerno][0]~sysfvar[.fY] - .chars[`playerno][0]~getHeight())
      - (`sysfvar[.fY] - `getHeight()));
  }
  public void trParentDistX()
  {
    `trParent();
    if(#.c == 0){
      .v.setSF();
      ret;
    }
    .v.setF()<, (float)((int)`facing*(int)(.c~sysfvar[.fX] - `sysfvar[.fX]));
  }
  public void trParentDistY()
  {
    `trParent();
    if(#.c == 0){
      .v.setSF();
      ret;
    }
    .v.setF(
      (.c~sysfvar[.fY] - .c~getHeight()) - (`sysfvar[.fY] - `getHeight()));
  }
  public void trStateType(|.StTy st)
  {
    .v.typ = .VarTy::Int;
    .v.i = (int)(st == `stVal.typ);
  }
  public void trP2StateType(|.StTy st)
  {
    ^`self e = .players.enemyNear(`=, 0);
    if(#e == 0){
      .v.setSF();
      ret;
    }
    .v.setB(st == e~stVal.typ);
  }
  public void trP2StateNo()
  {
    ^`self e = .players.enemyNear(`=, 0);
    if(#e == 0){
      .v.setSF();
      ret;
    }
    .v.setI(e~stVal.no);
  }
  public void trMoveType(|.MovTy mt)
  {
    .v.setB(mt == `stVal.mov);
  }
  public void trP2MoveType(|.MovTy mt)
  {
    ^`self e = .players.enemyNear(`=, 0);
    .v.setB(mt == e~stVal.mov);
  }
  public void trPName(int no, ^/char name)
  {
    if(no <= 0 || #.chars < no){
      .v.typ = .VarTy::Int;
      .v.i = 0;
      ret;
    }
    int foo;
    branch{
    cond (no & 1) == 1 && no - 1 <= `playerno:
      branch{
      cond no == 1:
        foo = `playerno;
      else:
        foo = ((no - 1) - 2) + (`playerno & 1);
      }
    else:
      foo = (no - 1) ^ (`playerno & 1);
    }
    .v.setI(
      (int)(
        #.chars[foo] > 0 && .s.equ(
          .s.toLower(name), .s.toLower(.chars[foo][0]~name))));
  }
  public void trFrontEdgeDist()
  {
    .v.setI(
      (int)(
        `facing > 0 ? .com.xmax - `sysfvar[.fX] : `sysfvar[.fX] - .com.xmin));
  }
  public void trFrontEdgeBodyDist()
  {
    .v.setI(
      (int)(
        (`facing > 0 ? .com.xmax - `sysfvar[.fX] : `sysfvar[.fX] - .com.xmin)
        - `getEdge(`fedge)));
  }
  public void trBackEdgeDist()
  {
    .v.setI(
      (int)(
        `facing < 0 ? .com.xmax - `sysfvar[.fX] : `sysfvar[.fX] - .com.xmin));
  }
  public void trBackEdgeBodyDist()
  {
    .v.setI(
      (int)(
        (`facing < 0 ? .com.xmax - `sysfvar[.fX] : `sysfvar[.fX] - .com.xmin)
        - `getEdge(`bedge)));
  }
  public void trIsHelper()
  {
    if(.v.isSF()) ret;
    int id = .v.toI();
    .v.setB(`helperindex != 0 && (id <= 0 || `helperid == id));
  }
  public void trActive()
  {
    .v.setB(`isActive());
  }
  public void trTeamMode(|.com.TeamMode tm)
  {
    .v.setB(.com.tmode[`playerno&1] == (int)tm);
  }
  public void trNewHelper(^`self c=)
  {
    c = .create(`playerno);
    if(#c == 0) ret;
    c~id ^= -1;
    c~helperid = 0;
    c~copyParent(`=);
    `addChild(c~helperindex);
    c~parentindex = `helperindex;
  }
  void helproSetPos<_t>(_t obj=, int pt, float x, float y, int facing)
  {
    switch(pt){
    case 2, 3://front, back
      if(facing < 0) obj.facing *= -1;
      branch{
      cond (`facing > 0 && pt == 2) || (`facing < 0 && pt == 3):
        obj.setX(
          .com.screenx + (float).com.GameWidth/.com.scale
          - x*(pt == 2 ? -1.0 : 1.0));
      else:
        obj.setX(.com.screenx + x*(pt == 2 ? -1.0 : 1.0));
      }
      obj.setY(y);
      obj.facing *= `facing;
    case 4://left
      if(facing < 0) obj.facing *= -1;
      obj.setX(.com.screenx + x);
      obj.setY(y);
    case 5://right
      if(facing < 0) obj.facing *= -1;
      obj.setX(.com.screenx + (float).com.GameWidth/.com.scale + x);
      obj.setY(y);
    default:
      `setPos!_t?(obj=, pt, x, y, facing);
    }
  }
  public void trHelperInit(
    `self h=, int st, int pt, float x, float y, int facing, int ownpal)
  {
    `helproSetPos!h.self?(h=, pt, x, y, facing);
    h.sysfvar[.fVX] = 0.0;
    h.sysfvar[.fVY] = 0.0;
    if(ownpal != 0) h.palfx.new(1);
    h.trChangeState2(st, `minus == -2 ? `playerno : `stVal.playerno, 0, 1);
  }
  public void trProjInit(&.Projectile p=, int pt, float x, float y)
  {
    `helproSetPos!p.self?(p=, pt, x, y, 1);
    p.ani = `getAction(p.anim);
    if(#p.ani == 0 && #`ani > 0){
      p.ani.new(1);
      p.ani~copy(`ani<>=);
      p.ani~ani.setAnimElem(1);
      p.anim = p.ani~no;
    }
    if(#p.ani > 0) p.ani~ani.updateSprite();
    if(`sysivar[.iPROJ_DOSCALE] != 0){
      p.scalex *= `sysfvar[.fXSCALE];
      p.scaley *= `sysfvar[.fYSCALE];
    }
    p.playerno = `playerno;
    if(p.velocityx < 0.0){
      p.facing *= -1;
      p.velocityx *= -1.0;
      p.accelx *= -1.0;
    }
  }
  public void trDestroySelf()
  {
    if(`helperindex <= 0) ret;
    `destmp = true;
  }
  public %int getTarget(int id)
  {
    if(id < 0) ret `targets;
    %int tar;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0 && (id < 0 || c~stVal.hb.hitid == id)) tar .= `targets[i];
      i++;
    while i < #`targets:
    }
    ret tar;
  }
  public void trTargetBind(^/int tar, int time, float x, float y)
  {
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(tar[i]);
      if(#c > 0){
        c~setBindToId(`=);
        c~setBindTime(time);
        c~sysivar[.iBINDFACING] = 0;
        c~sysfvar[.fBINDPOSX] = x;
        c~sysfvar[.fBINDPOSY] = y;
      }
      i++;
    while i < #tar:
    }
  }
  public void trBindToTarget(^/int tar, int time, float x, float y, int hmf)
  {
    if(#tar == 0) ret;
    ^`self c = .players.get(tar<>);
    if(#c == 0) ret;
    float bx = x, by = y;
    switch(hmf){
    case 1:
      bx += (float)c~sysivar[.iMID_POSX];
      by += (float)c~sysivar[.iMID_POSY];
    case 2:
      bx += (float)c~sysivar[.iHEAD_POSX];
      by += (float)c~sysivar[.iHEAD_POSY];
    }
    if(!.m.isnan(bx)) `setX(c~sysfvar[.fX] + (float)c~facing*bx);
    if(!.m.isnan(by)) `setY(c~sysfvar[.fY] + by);
    `trTargetBind(
      tar[0..1], time, (float)`facing*(c~sysfvar[.fX] - `sysfvar[.fX]),
      c~sysfvar[.fY] - `sysfvar[.fY]);
  }
  public void setBindFacing(int f)
  {
    if(f== 0) ret;
    `sysivar[.iBINDFACING] = f < 0 ? -1 : 1;
  }
  public void trTargetDrop(int id, bool keepone)
  {
    %int tmp;
    ^`self c;
    loop{
      if(id < 0){
        tmp = `targets;
        break, break;
      }
      index i = 0;
      while;
    do:
      c = .players.get(`targets[i]);
      if(#c > 0) branch{
      cond c~stVal.hb.hitid == id:
        tmp .= `targets[i];
      else:
        c~byBindClear();
        c~stVal.hb.dropByid(`id);
      }
      i++;
    while i < #`targets:
    }
    branch{
    cond (keepone || id < 0) && #tmp > 0:
      `targets.new(0);
      loop{
        index i = 0, r = keepone && id >= 0 ? .m.rand(0, #tmp-1) : -1;
        while;
      do:
        branch{
        cond  i == r:
          `targets .= tmp[i];
        else:
          c = .players.get(tmp[i]);
          if(#c > 0){
            c~byBindClear();
            c~stVal.hb.dropByid(`id);
          }
        }
        i++;
      while i < #tmp:
      }
    else:
      `targets = tmp;
    }
  }
  public void trTargetFacing(^/int tar, int fasing)
  {
    if(fasing == 0) ret;
    int f = `facing;
    if(fasing < 0) f *= -1;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(tar[i]);
      if(#c > 0) c~setFacing(f);
      i++;
    while i < #tar:
    }
  }
  public void trTargetState(^/int tar, int state)
  {
    if(state < 0) ret;
    ^`self c;
    int pno = `minus == -2 ? `playerno : `stVal.playerno;
    loop{index i = 0; while; do:
      c = .players.get(tar[i]);
      if(#c > 0){
        c~setCtrl(false);
        c~changeState1kai(pno, state);
      }
      i++;
    while i < #tar:
    }
  }
  public void trTargetVelSetX(^/int tar, float vx)
  {
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(tar[i]);
      if(#c > 0) c~setXV(vx);
      i++;
    while i < #tar:
    }
  }
  public void trTargetVelSetY(^/int tar, float vy)
  {
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(tar[i]);
      if(#c > 0) c~setYV(vy);
      i++;
    while i < #tar:
    }
  }
  public void trTargetVelAddX(^/int tar, float vx)
  {
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(tar[i]);
      if(#c > 0) c~sysfvar[.fVX] += vx;
      i++;
    while i < #tar:
    }
  }
  public void trTargetVelAddY(^/int tar, float vy)
  {
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(tar[i]);
      if(#c > 0) c~sysfvar[.fVY] += vy;
      i++;
    while i < #tar:
    }
  }
  public void trTargetLifeAdd(^/int tar, int va, bool kill, bool absolute)
  {
    ^`self c;
    loop{index i = 0; while; do:
      if(#(c = .players.get(tar[i])) > 0){
        if(
          c~addLife(
            -c~getDamage(-va, kill, absolute, `attackmul), true, true)) branch
        {
        cond (`playerno&1) == (c~playerno&1):
          if(c~helperindex == 0) branch{
          cond `playerno == c~playerno:
            .winty[(c~playerno+1)&1] = .fgt.WinTy::Suicide;
          else:
            .winty[(c~playerno+1)&1] = .fgt.WinTy::Teammate;
          }
        else:
          c~setEnemyWinty();
        }
      }
      i++;
    while i < #tar:
    }
  }
  public void trTargetPowerAdd(^/int tar, int pw)
  {
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(tar[i]);
      if(#c > 0) c~addPower(pw);
      i++;
    while i < #tar:
    }
  }
  public void trHitAdd(int h)
  {
    `sysivar[.iHITCOUNT] += h;
    ^`self c;
    loop{index i = 0; while; do:
      c = .players.get(`targets[i]);
      if(#c > 0) c~getcombo += h;
      i++;
    while i < #`targets:
    }
  }
  public void trNumEnemy()
  {
    .v.setI(.players.numEnemy(`playerno));
  }
  public void trNumPartner()
  {
    .v.setI(#.chars[`playerno+2 & 3]);
  }
  public void trHitXvel()
  {
    .v.setF(`stVal.hb.xvel * (float)`facing);
  }
  public void trFallXvel()
  {
    if(.m.isnan(`stVal.hb.fall.xvelocity)){
      .v.setF(-32760.0);
      ret;
    }
    .v.setF(`stVal.hb.fall.xvelocity);
  }
  public void trHitFallSet(int f, float vx, float vy)
  {
    if(`stVal.mov != .MovTy::H) ret;
    if(f >= 0) `stVal.hb.fallf = (int)(f != 0);
    if(!.m.isnan(vx)) `stVal.hb.fall.xvelocity = vx;
    if(!.m.isnan(vy)) `stVal.hb.fall.yvelocity = vy;
  }
  public void trHitFallVel()
  {
    if(`stVal.mov != .MovTy::H) ret;
    if(!.m.isnan(`stVal.hb.fall.xvelocity)) `setXV(`stVal.hb.fall.xvelocity);
    `setYV(`stVal.hb.fall.yvelocity);
  }
  public void trHitFall()
  {
    .v.typ = .VarTy::Int;
    .v.i = (int)(`stVal.hb.fallf != 0);
  }
  public void trHitFallDamage()
  {
    if(`stVal.mov != .MovTy::H) ret;
    if(`addLife(-`stVal.hb.fall.damage, `stVal.hb.fall.kill != 0, false)){
      `setEnemyWinty();
    }
  }
  public void trHitVelSetX()
  {
    if(`stVal.mov != .MovTy::H) ret;
    `setXV(`stVal.hb.xvel);
  }
  public void trHitVelSetY()
  {
    if(`stVal.mov != .MovTy::H) ret;
    `setYV(`stVal.hb.yvel);
  }
  public void trHitVelX()
  {
    .v.setF(`stVal.mov != .MovTy::H ? -`stVal.hb.xvel : 0.0);
  }
  public void trHitVelY()
  {
    .v.setF(`stVal.mov != .MovTy::H ? -`stVal.hb.yvel : 0.0);
  }
  public void trProjTime(|.ProjContact pct)
  {
    if(.v.isSF()) ret;
    int id = .v.toI();
    .v.typ = .VarTy::Int;
    branch{
    cond id < 0:
      .v.i = 0;
    else:
      .v.i = -1;
      loop{index i = 0; while; do:
        if(
          .projs[`playerno][i].id != .com.IERR
          && (
            id == 0 
            || .projs[`playerno][i].id == id || !.projs[`playerno][i].id == id)
          && .projs[`playerno][i].pctyp == pct
          && .projs[`playerno][i].pctime != 0
          && (.v.i <= 0 || .v.i > #.projs[`playerno][i].pctime))
        {
          .v.i = #.projs[`playerno][i].pctime;
        }
        i++;
      while i < #.projs[`playerno]:
      }
    }
  }
  public void trProjContactTime()
  {
    if(.v.isSF()) ret;
    int id = .v.toI();
    .v.typ = .VarTy::Int;
    branch{
    cond id < 0:
      .v.i = 0;
    else:
      .v.i = -1;
      loop{index i = 0; while; do:
        if(
          .projs[`playerno][i].id != .com.IERR
          && (
            id == 0
            || .projs[`playerno][i].id == id || !.projs[`playerno][i].id == id)
          && .projs[`playerno][i].pctime != 0
          && (.v.i <= 0 || .v.i > #.projs[`playerno][i].pctime))
        {
          .v.i = #.projs[`playerno][i].pctime;
        }
        i++;
      while i < #.projs[`playerno]:
      }
    }
  }
  public void trHitDefAttr(int flg)
  {
    const int mask = (int).AtTy::NA - 1;
    int attr = `stVal.hit.attr & (int)0x7fffffff;
    .v.setI(
      (int)(
        `stVal.mov == .MovTy::A
        && (mask & attr & flg) != 0  && (!mask & attr & flg) != 0));
  }
  public void trNumHelper()
  {
    if(.v.isSF()) ret;
    int id = .v.toI();
    .v.typ = .VarTy::Int;
    .v.i = 0;
    loop{index i = 1; while; do:
      if(
        .chars[`playerno][i]~helperindex > 0 && !.chars[`playerno][i]~destmp
        && (id <= 0 || id == .chars[`playerno][i]~helperid)) .v.i++;
      i++;
    while i < #.chars[`playerno]:
    }
  }
  public bool matchExplodId(index i, int id)
  {
    ret
      .explods[`playerno][i].id >= 0 && (
        .explods[`playerno][i].player == `id
        && (id <= 0 || .explods[`playerno][i].id == id));
  }
  public void trExplodBindTime(int id, int bt)
  {
    loop{index i = 0; while; do:
      if(`matchExplodId(i, id)){
        .explods[`playerno][i].bindtime = bt + (bt > 0 ? 1 : 0);
      }
      i++;
    while i < #.explods[`playerno]:
    }
  }
  public void trRemoveExplod(int id)
  {:<-
    void expRemove(int id, ^%index drawlist=, bool delI)
    {
      loop{index i = #drawlist[`playerno]-1; while; do:
        if(drawlist[`playerno][i] < 0) continue;
        if(`matchExplodId(drawlist[`playerno][i], id)){
          .explods[`playerno][drawlist[`playerno][i]].id = .com.IERR;
          branch{
          cond delI:
            .delIL(drawlist[`playerno]=, i);
          else:
            drawlist[`playerno][i] = -1;
          }
        }
      continue:
        i--;
      while i >= 0:
      }
    }
    expRemove(id, .expdrawlist=, true);
    expRemove(id, .topexpdrawlist=, false);
  }
  public void trNumExplod()
  {
    if(.v.isSF()) ret;
    int id = .v.toI();
    .v.typ = .VarTy::Int;
    .v.i = 0;
    loop{index i = 0; while; do:
      if(`matchExplodId(i, id)) .v.i++;
      i++;
    while i < #.explods[`playerno]:
    }
  }
  public void trNumTarget()
  {
    if(.v.isSF()) ret;
    int id = .v.toI();
    .v.typ = .VarTy::Int;
    .v.i = 0;
    loop{index i = 0; while; do:
      if(`targets[i] >= 0) branch{
      cond id < 0:
        .v.i++;
      else:
        {
          ^`self t = .players.get(`targets[i]);
          if(#t > 0 && t~stVal.hb.hitid == id) .v.i++;
        } 
      }
      i++;
    while i < #`targets:
    }
  }
  public void trNumProjID()
  {
    if(.v.isSF()) ret;
    int id = .v.toI();
    if(`helperindex != 0){
      .v.setI(0);
      ret;
    }
    int d = .m.max!int?(0, id);
    .v.typ = .VarTy::Int;
    .v.i = 0;
    loop{index i = 0; while; do:
      if(.projs[`playerno][i].id == d && .projs[`playerno][i].hits > 0) .v.i++;
      i++;
    while i < #.projs[`playerno]:
    }
  }
  public void trNumProj()
  {
    .v.typ = .VarTy::Int;
    .v.i = 0;
    loop{index i = 0; while; do:
      if(.projs[`playerno][i].id >= 0 && .projs[`playerno][i].hits > 0) .v.i++;
      i++;
    while i < #.projs[`playerno]:
    }
  }
  public void trHitPauseTime()
  {
    .v.setI(.m.max!int?(0, `sysivar[.iHITPAUSETIME]));
  }
  public void trInGuardDist()
  {
    .v.setB(`inguarddist);
  }
  public void trHitOver()
  {
    .v.setB(`stVal.hb.hittime < 0);
  }
  public void trHitShakeOver()
  {
    .v.setI((int)(`stVal.hb.hitshaketime <= 0));
  }
  public void trCanRecover()
  {
    .v.setI(
      (int)(
        `stVal.hb.fall.recover != 0
        && `stVal.fallTime >= `stVal.hb.fall.recovertime));
  }
  public void trMoveContact()
  {
    .v.typ = .VarTy::Int;
    .v.i = `stVal.mctyp != .MoveContact::Reversed ? #`stVal.mctime : 0;
  }
  public void trMoveReversed()
  {
    .v.typ = .VarTy::Int;
    .v.i = `stVal.mctyp == .MoveContact::Reversed ? #`stVal.mctime : 0;
  }
  public void trMoveHit()
  {
    .v.typ = .VarTy::Int;
    .v.i = `stVal.mctyp == .MoveContact::Hit ? #`stVal.mctime : 0;
  }
  public void trMoveGuarded()
  {
    .v.typ = .VarTy::Int;
    .v.i = `stVal.mctyp == .MoveContact::Guarded ? #`stVal.mctime : 0;
  }
  public void trPalNo()
  {
    .v.setI(`palno);
  }
  public void trMatchOver()
  {
    .v.setB(.com.p1wins >= .com.p1mw || .com.p2wins >= .com.p2mw);
  }
  public void trMatchNo()
  {////////////////////////////////////////////////////////////////////////////
    .v.setI(1);
  }
  public void trRoundNo()
  {
    .v.setI(.com.round);
  }
  public void trRoundState()
  {
    .v.setI(`roundState());
  }
  public void trRoundsExisted()
  {
    .v.setI(.com.rexisted[`playerno&1]);
  }
  public bool isWin()
  {
    ret .com.win >= 0 && (`playerno&1) == .com.win;
  }
  public bool isLose()
  {
    ret .com.win >= 0 && (`playerno+1&1) == .com.win;
  }
  public bool isOver()
  {
    ret
      (`sysivar[.iSYSFLAG] & .sfOVER) != 0 || (
        `ctrlOver() && `ctrl
        && `stVal.typ != .StTy::A && `stVal.phy != .StTy::A);
  }
  public void trWin()
  {
    .v.setB(`isWin());
  }
  public void trWinKO()
  {
    .v.setB(`isWin() && .ko == .fgt.KOTy::KO);
  }
  public void trWinTime()
  {
    .v.setB(`isWin() && .ko == .fgt.KOTy::TO);
  }
  public void trWinPerfect()
  {
    .v.setI((int)(`isWin() && .winty[`playerno&1] >= .fgt.WinTy::PN));
  }
  public void trLose()
  {
    .v.setB(`isLose());
  }
  public void trLoseKO()
  {
    .v.setB(`isLose() && .ko == .fgt.KOTy::KO);
  }
  public void trLoseTime()
  {
    .v.setB(`isLose() && .ko == .fgt.KOTy::TO);
  }
  public void trDrawGame()
  {
    .v.setB(`roundState() >= 3 && .com.win < 0);
  }
  public void trRemapPal(int sg, int sn, int dg, int dn)
  {
    if(sg < 0 || sn < 0 || dg < 0 || dn < 0) ret;
    ^index si = `sf~palList.palTable.get((uint)sg << 0d16 | (ushort)sn);
    ^index di = `sf~palList.palTable.get((uint)dg << 0d16 | (ushort)dn);
    if(#si == 0) ret;
    if(#di == 0) di = si;
    `sf~palList.remap(si<>, di<>);
    if(sg == 1 && sn == 1 && `sf~head.ver0 == 0d1){
      ^&.sff.Sprite spr = `sf~getSprite(0, 0);
      if(#spr > 0) `sf~palList.remap(spr~palidx, di<>);
      spr = `sf~getSprite(9000, 0);
      if(#spr > 0) `sf~palList.remap(spr~palidx, di<>);
    }
  }
}

public void Explod::update(bool oVer)
{
  if(`id == .com.IERR) ret;
  ^&.Char c;
  bool p = false;
  branch{
  cond .super > 0:
    p = `supermovetime >= 0 && `time >= `supermovetime;
  cond .pause > 0:
    p = `pausemovetime >= 0 && `time >= `pausemovetime;
  }
  bool act = !p && `ignorehitpause != 0;
  if(!p && !act){
    if(#c == 0) c = .players.get(`player);
    act = #c == 0 || c~acttmp%2 != -1;
  }
  if(.com.tickFrame()){
    if(`removeongethit != 0){
      if(#c == 0) c = .players.get(`player);
      if(#c == 0 || c~stVal.mov == .MovTy::H){
        `id = .com.IERR;
        ret;
      }
    }
    if(
      (`removetime >= 0 && `time >= `removetime) || #`ani == 0
      || (act && `removetime <= -2 && `ani~ani.loopend))
    {
      `id = .com.IERR;
      ret;
    }
  }
  float scl = 1.0, cscl = .com.scale, xofs = 0.0, yofs = 0.0;
  if(`bindtime != 0) branch{
  cond `postype >= 4:
    cscl = 1.0;
    `x =
      .com.camerax + `offsetx + (
        `postype == 4
        ? -(float).com.GameWidth/2.0 : (float).com.GameWidth/2.0);
    xofs = -.com.xoffset;
    `y = .com.cameray + `offsety - .com.zoffset;
    yofs = -.com.yoffset;
  else:
    {
      ^&.Char bc = .players.get(`bindid);
      if(#bc == 0){
        `bindtime = 0;
        break, break;
      }
      if(!.m.isnan(`offsetx)) `setX(bc~drawX+bc~offsetX() + `offsetx);
      if(!.m.isnan(`offsety)) `setY(bc~drawY+bc~offsetY() + `offsety);
    }
  }
  if(.com.tickFrame()){
    if(act && #`ani > 0) `ani~ani.updateSprite();
    if(act && `bindtime == 0){
      `ticOldX = `x;
      `ticNewX = `x + `velocityx*(float)(`facing*`relativef);
      `ticOldY = `y;
      `ticNewY = `y + `velocityy;
    }
  }
  if(act && `bindtime == 0){
    float sp = .com.tickInterpola();
    `x = `ticNewX - (`ticNewX - `ticOldX) * (1.0 - sp);
    `y = `ticNewY - (`ticNewY - `ticOldY) * (1.0 - sp);
  }
  if(.com.tickNextFrame()){
    if(`bindtime > 0){
      `bindtime--;
      if(act && `bindtime == 0){
        `x += `velocityx*(float)(`facing*`relativef);
        `y += `velocityy;
      }
    }
    if(!act) break;
    if(`bindtime == 0){
      `velocityx += `accelx;
      `velocityy += `accely;
    }
    if(#`ani > 0) `ani~ani.action();
    `time++;
  }
  branch{
    type _t = $void(.anims.self=);
    ~_t aal = [_t(a=){
      if(`ownpal == 0 && #c == 0){
        if(#(c = .players.get(`player)) == 0) ret;
      }
      .addAnimList(
        a=, `ani, `sprpriority, `x+xofs, `y+yofs, cscl,
        (float)`facing*`scalex*scl, (float)`vfacing*`scaley*scl,
        0.0, false, oVer, 1.0, 1.0, `alphas < 0 ? -1 : `alphas,
        `alphad, 256 >> (int)(
          .super > 0 && .superdarken != 0
          && (#c > 0 || #(c = .players.get(`player)) > 0)
          && c~playerno != .superplayer),
        `ownpal == 0 ? c~getPalfx() : .consts.null!&.com.PalFX?(),
        `shadowr<<16 | (`shadowg&255)<<8 | (`shadowb&255),
        `alphas < 0 ? 256 : `alphas, 0.0);
    }];
  cond `ontop != 0:
    aal(:.topanims=:);
  else:
    aal(:.anims=:);
  }
}
public void Explod::setPos(&.Char c=)
{
  switch(`postype){
  case 0:
    `bindid = c.id;
    `facing = c.facing*`relativef;
    `offsetx *= (float)c.facing;
    if(!.m.isnan(`offsetx)) `setX(c.sysfvar[.fX]+c.offsetX() + `offsetx);
    if(!.m.isnan(`offsety)) `setY(c.sysfvar[.fY]+c.offsetY() + `offsety);
    if(`bindtime == 0) `bindtime = 1;
  case 1:
    {
      ^&.Char bc = .players.enemyNear(c=, 0);
      if(#bc == 0) break;
      `bindid = bc~id;
      `facing *= bc~facing*`relativef;
      `offsetx *= (float)bc~facing;
      if(!.m.isnan(`offsetx)) `setX(bc~sysfvar[.fX]+bc~offsetX() + `offsetx);
      if(!.m.isnan(`offsety)) `setY(bc~sysfvar[.fY]+bc~offsetY() + `offsety);
      if(`bindtime == 0) `bindtime = 1;
    }
  case 2, 3:
    branch{
    cond (c.facing > 0 && `postype == 2) || (c.facing < 0 && `postype == 3):
      `postype = 5;
      `offsetx *= -1.0;
    else:
      if(`postype == 2){
        `postype = 4;
        `relativef *= c.facing;
        c.setPos!`self?(`=, `postype, `offsetx, `offsety, c.facing);
        break, break;
      }
      `postype = 4;
    comm:
      c.setPos!`self?(`=, `postype, `offsetx, `offsety, `relativef*c.facing);
    }
  default:
    c.setPos!`self?(`=, `postype, `offsetx, `offsety, `relativef);
  }
}
public void Explod::modify(&.Char c=, &.ModifyExplod mod=, index i)
{
  if(!c.matchExplodId(i, mod.id)) ret;
  if(mod.bindtime != .com.IERR) `bindtime = mod.bindtime;
  if(!.m.isnan(mod.scalex)) `scalex = mod.scalex;
  if(!.m.isnan(mod.scaley)) `scaley = mod.scaley;
  if(mod.removeongethit != .com.IERR) `removeongethit = mod.removeongethit;
  if(mod.removetime != .com.IERR) `removetime = mod.removetime;
  if(!.m.isnan(mod.velocityx)) `velocityx = mod.velocityx;
  if(!.m.isnan(mod.velocityy)) `velocityy = mod.velocityy;
  if(!.m.isnan(mod.accelx)) `accelx = mod.accelx;
  if(!.m.isnan(mod.accely)) `accely = mod.accely;
  if(mod.sprpriority != .com.IERR) `sprpriority = mod.sprpriority;
  if(mod.postype != .com.IERR) `postype = mod.postype;
  if(!.m.isnan(mod.offsetx)) `offsetx = mod.offsetx;
  if(!.m.isnan(mod.offsety)) `offsety = mod.offsety;
  if(mod.relativef != .com.IERR) `relativef = mod.relativef;
  if(!.m.isnan(mod.x)) `x = mod.x;
  if(!.m.isnan(mod.y)) `y = mod.y;
  if(mod.facing != .com.IERR) `setFacing(mod.facing);
  if(mod.vfacing != .com.IERR) `vfacing = mod.vfacing;
  if(mod.shadowr != .com.IERR) `shadowr = mod.shadowr;
  if(mod.shadowg != .com.IERR) `shadowg = mod.shadowg;
  if(mod.shadowb != .com.IERR) `shadowb = mod.shadowb;
  if(mod.ontop != .com.IERR) `ontop = mod.ontop;
  if(mod.alphas != .com.IERR) `alphas = mod.alphas;
  if(mod.alphad != .com.IERR) `alphad = mod.alphad;
  if(mod.supermovetime != .com.IERR) `supermovetime = mod.supermovetime;
  if(mod.pausemovetime != .com.IERR) `pausemovetime = mod.pausemovetime;
  if(mod.postype >= 0 || !.m.isnan(mod.offsetx) || !.m.isnan(mod.offsety)){
    `setPos(c=);
  }
  if(`ontop != 0) `sprpriority = 0;
}



public ^&Char PlayerList!&Char?::get(int id)
{
  if(id < 0) ret .consts.null!`_t?();
  loop{index i = 0; while; do:
    if(.playerid[i].n == id) ret .chars[.playerid[i].pn][.playerid[i].hi];
    i++;
  while i < #.playerid:
  }
  loop{
    *`top.self p = `top;
    while;
  do:
    if(p~c~id == id || !p~c~id == id){
      .playerid.new[-1].n = id;
      .playerid[-1].pn = p~c~playerno;
      .playerid[-1].hi = p~c~helperindex;
      ret p~c;
    }
    p = p~next;
  while #p > 0:
  }
  ret .consts.null!`_t?();
}
public ^&Char PlayerList!&Char?::enemy(int pno, int n)
{
  int cnt = 0;
  loop{
    *`top.self p = `top;
    while;
  do:
    if((p~c~playerno&1) != (pno&1) && p~c~player && n == cnt++) ret p~c;
    p = p~next;
  while #p > 0:
  }
  ret .consts.null!`_t?();
}
public ^&Char PlayerList!&Char?::enemyNear(&.Char pyr=, int n)
{
  if(n < 0) ret .consts.null!pyr.self?();
  loop{index i = 0; while; do:
    if(pyr.enemyn[i].n == n) ret .chars[pyr.enemyn[i].pn][pyr.enemyn[i].hi];
    i++;
  while i < #pyr.enemyn:
  }
  ^^pyr.self en.new(n+1);
  void add(^`pyr.self e, index rng)
  {
    bool foo<_t>(_t a, _t b, int id1, int id2)
    {
      ret a <= b && (a < b || id1 < id2);
    }
    loop{index i = rng; while; do:
      if(#`en[i] == 0){
        `en[i] = e;
        ret;
      }
      if(
        (!e~isKO() && `en[i]~isKO()) || (
          !e~isKO() ? foo!float?(
            #(e~sysfvar[.fX] - `pyr.sysfvar[.fX]),
            #(`en[i]~sysfvar[.fX] - `pyr.sysfvar[.fX]), e~id, `en[i]~id)
          : `en[i]~isKO() && foo!int?(
            -(`en[i]~sysivar[.iSYSFLAG] & .sfKO_ROUND_MIDDLE),
            -(e~sysivar[.iSYSFLAG] & .sfKO_ROUND_MIDDLE), e~id, `en[i]~id)))
      {
        self(`en[i], i+1);
        `en[i] = e;
        ret;
      }
      i++;
    while i < #`en:
    }
  }
  loop{
    *`top.self p = `top;
    while;
  do:
    if((p~c~playerno&1) != (pyr.playerno&1) && p~c~player) add(p~c, 0);
    p = p~next;
  while #p > 0:
  }
  if(#en[-1] == 0) ret .consts.null!&.Char?();
  pyr.enemyn.new[-1].n = n;
  pyr.enemyn[-1].pn = en[-1]~playerno;
  pyr.enemyn[-1].hi = en[-1]~helperindex;
  ret en[-1];
}
public int PlayerList!&Char?::numEnemy(int pno)
{
  if(.numenemy[pno] >= 0) ret .numenemy[pno];
  int cnt = 0;
  loop{
    *`top.self p = `top;
    while;
  do:
    if((p~c~playerno&1) != (pno&1) && p~c~player) cnt++;
    p = p~next;
  while #p > 0:
  }
  ret .numenemy[pno] = cnt;
}
public void PlayerList!&Char?::add(^&.Char c)
{
  .playerid.new(0);
  .resetNumenemy();
  if(#`top == 0){
    `top.new(1);
    `top~c = c;
    `end = `top;
    ret;
  }
  `end~next.new(1);
  `end = `end~next;
  `end~c = c;
}
public void PlayerList!&Char?::destroy(int id)
{
  if(#`top == 0) ret;
  .playerid.new(0);
  .resetNumenemy();
  if(`top~c~id == id){
    `top = `top~next;
    if(#`top == 0) `end.new(0);
    ret;
  }
  *`top.self p = `top;
  loop{while; do:
    if(p~next~c~id == id){
      p~next = p~next~next;
      if(#p~next == 0) `end = p;
      break, break;
    }
    p = p~next;
  while #p~next > 0:
  }
}
public void PlayerList!&Char?::action(
  float x, float cvmin=, float cvmax=,
  float highest=, float lowest=, float leftest=, float rightest=)
{
  .commandUpdate();
  loop{
    *`top.self p = `top;
    while;
  do:
    if(p~c~id < 0) p~c~id ^= -1;
    p~c~action();
    p = p~next;
  while #p > 0:
  }
  .update(cvmin=, cvmax=, highest=, lowest=, leftest=, rightest=);
  .com.gametime++;
  .rootAction();
}
public void PlayerList!&Char?::update(
  float cvmin=, float cvmax=,
  float highest=, float lowest=, float leftest=, float rightest=)
{
  loop{
    *`top.self p = `top;
    while;
  do:
    if(p~c~id < 0) continue;
    p~c~update(cvmin=, cvmax=, highest=, lowest=, leftest=, rightest=);
  continue:
    p = p~next;
  while #p > 0:
  }
}
public void PlayerList!&Char?::clsn(&.Char pyr=)
{
  float pxmi, pxma;
  branch{
  cond pyr.facing > 0:
    pxmi = .com.xmin + pyr.getEdge(pyr.bedge);
    pxma = .com.xmax - pyr.getEdge(pyr.fedge);
  else:
    pxmi = .com.xmin + pyr.getEdge(pyr.fedge);
    pxma = .com.xmax - pyr.getEdge(pyr.bedge);
  }
  bool foo(
    int hitting=, `pyr.self by=, &.Hitdef hit=,
    float x, float y, int pro, int hits)
  {
    void expreset(&.Char p1=, &.Char p2=, float y, ^&.act.Action ani)
    {
      float x =
        (float)p1.facing * (
         `pro != 0 ? `x
          : p2.sysfvar[.fX] - p1.sysfvar[.fX] + (float)p2.facing * (
            (p1.facing < 0) ^ (p2.facing < 0) ? p2.frontw : -p2.backw));
      index tmp;
      ^&.Explod e = `by.newExplod(tmp=);
      if(#e == 0) ret;
      e~ani = ani;
      e~postype = 0;
      e~offsetx =
        x - `hit.sparkx * (`pro != 0 ? -(float)(`pro*p1.facing) : 1.0);
      e~offsety =
        y + `hit.sparky + (`by.id == p1.id ? 0.0 : p1.stVal.hit.sparky);
      e~relativef = 1;
      e~player = `by.id;
      e~scalex = e~scaley = 1.0;
      e~ontop = 1;
      e~sprpriority = .consts.int_t::MIN;
      e~ownpal = 1;
      e~supermovetime = e~pausemovetime = -1;
      p1.setPos!e<>.self?(e<>=, e~postype, e~offsetx, e~offsety, e~relativef);
      `by.insertExplod(tmp);
    }
    bool guard =
      (pro != 0 || !by.ls(.lsUNGUARDABLE)) && `pyr.ls(.lsGUARD);
    hitting = `pyr.stVal.hitCheck(hit=, guard);
    bool ho = false,  p2s = false;
    if(
      !`pyr.cs1tmp || `pyr.stVal.playerno == by.playerno
      || `pyr.stVal.playerno == `pyr.playerno || !`pyr.ls(.lsGETHIT))
    {
      loop{index i = 0; while; do:
        if(
          `pyr.stVal.ho[i].time != 0
          && (
            `pyr.stVal.ho[i].attr & (
              pro != 0 ? hit.attr & 63 : (int)by.stVal.typ)) != 0
          && (`pyr.stVal.ho[i].attr & hit.attr & !63) != 0)
        {
          if(
            pro == 0 && #hitting == 1 && (
              (hit.p2stateno >= 0 && hit.p2getp1state != 0)
              || hit.p1stateno >= 0))
          {
            ret false;
          }
          branch{
          cond
            `pyr.changeState1(
              `pyr.stVal.ho[i].player, `pyr.stVal.ho[i].stateno)
            :
            if(`pyr.stVal.ho[i].forceair != 0) `pyr.stVal.typ = .StTy::A;
            `pyr.setCtrl(false);
            ho = true;
            break, break, break, break;
          }
        }
        i++;
      while i < #`pyr.stVal.ho:
      }
      if(#hitting == 1 && hit.p2stateno >= 0 && hit.p2getp1state != 0){
        if(`pyr.changeState1(hit.player, hit.p2stateno)){
          `pyr.setCtrl(false);
          p2s = true;
        }
      }
    }
    if(pro == 0) by.sprpriority = hit.p1sprpriority;
    `pyr.sprpriority = hit.p2sprpriority;
    `pyr.stVal.hb.hitid = hit.id;
    if(hitting > 0){
      `pyr.stVal.setHb(
        hit=, guard, `pyr.stVal.mov == .MovTy::H || `pyr.ls(.lsGETHIT));
      branch{
      cond .super > 0:
        `pyr.sysivar[.iSUPERMOVETIME] =
          .m.max!int?(
            `pyr.sysivar[.iSUPERMOVETIME], `pyr.stVal.hb.hitshaketime);
      cond .pause > 0:
        `pyr.sysivar[.iPAUSEMOVETIME] =
          .m.max!int?(
            `pyr.sysivar[.iPAUSEMOVETIME], `pyr.stVal.hb.hitshaketime);
      }
      if(!ho && !p2s && !`pyr.ls(.lsGETHIT)) `pyr.cs1tmp = false;
      `pyr.sysivar[.iSPECIALFLAG] |= .lsGETHIT;
      if(`pyr.sysivar[.iBINDTOID] == by.id) `pyr.setBindTime(0);
      if(hit.forcestand != 0 && `pyr.stVal.typ == .StTy::C){
        `pyr.stVal.typ = .StTy::S;
      }
      bool live = `pyr.sysivar[.iLIFE] > 0;
      bool kill = #hitting == 1 ? hit.kill != 0 : hit.guard_kill != 0;
      `pyr.stVal.hb.damage +=
        `pyr.getDamage(
          `pyr.stVal.hb.absdamage*hits, kill, false, by.attackmul);
      if(`pyr.stVal.hb.damage >= `pyr.sysivar[.iLIFE]) branch{
      cond kill || !live:
        if(!.gs(.gsNOKO)){
          `pyr.stVal.hb.fallf = 1;
          if((int)`pyr.stVal.hb.fall.animtype < (int).AnimTy::Back){
            `pyr.stVal.hb.fall.animtype = .AnimTy::Back;
          }
          branch{
          cond `pyr.stVal.typ == .StTy::A:
            if(`pyr.stVal.hb.xvel < 0.0) `pyr.stVal.hb.xvel -= 2.0;
            if(`pyr.stVal.hb.yvel <= 0.0){
              `pyr.stVal.hb.yvel -= 2.0;
              if(`pyr.stVal.hb.yvel > -3.0) `pyr.stVal.hb.yvel = -3.0;
            }
          else:
            if(`pyr.stVal.hb.yvel == 0.0) `pyr.stVal.hb.xvel *= 0.66;
            if(`pyr.stVal.hb.xvel < 0.0) `pyr.stVal.hb.xvel -= 2.5;
            if(`pyr.stVal.hb.yvel <= 0.0){
              `pyr.stVal.hb.yvel -= 2.0;
              if(`pyr.stVal.hb.yvel > -6.0) `pyr.stVal.hb.yvel = -6.0;
            }
          }
        }
        `pyr.stVal.hb.damage = `pyr.sysivar[.iLIFE];
      else:
        `pyr.stVal.hb.damage = `pyr.sysivar[.iLIFE] - 1;
      }
      if(ho || p2s) branch{
      cond `pyr.stVal.typ == .StTy::L:
        `pyr.stVal.prevno = 5080;
      cond
        `pyr.stVal.hb.guarded != 0
        && (`pyr.stVal.hb.damage < `pyr.sysivar[.iLIFE] || .gs(.gsNOKO))
        :
        switch(`pyr.stVal.typ){
        case .StTy::S:
          `pyr.stVal.prevno = 150;
        case .StTy::C:
          `pyr.stVal.prevno = 152;
        case .StTy::A:
          `pyr.stVal.prevno = 154;
        }
      cond `pyr.stVal.hb.typ == 3:
        `pyr.stVal.prevno = 5070;
      else:
        switch(`pyr.stVal.typ){
        case .StTy::S:
          `pyr.stVal.prevno = 5000;
        case .StTy::C:
          `pyr.stVal.prevno = 5010;
        case .StTy::A:
          `pyr.stVal.prevno = 5020;
        }
      }
      if(
        (`pyr.facing < 0)
        == ((pro != 0 ? pro : by.facing*(hit.p1facing < 0 ? -1 : 1)) < 0))
      {
        `pyr.stVal.hb.xvel *= -1.0;
      }
    }
    branch{
      ^&.snd.Sound sou;
    cond<hit> #hitting == 1:
      branch{
        if(hit.sparkno == .com.IERR) break;
        ^&.act.Action ani;
      cond hit.sparkno < 0:
        ani = .fight~getAction(!hit.sparkno);
      else:
        ani = by.getAction(hit.sparkno);
      comm:
        branch{
        cond hit.reversal_attr > 0:
          expreset(`pyr=, by=, y, ani);
        else:
          expreset(by=, `pyr=, y, ani);
        }
      }
      branch{
        if(hit.hitsoundg == .com.IERR) break;
        sou = by.newChannel(-1, false);
        if(#sou == 0) break;
      cond hit.hitsoundg < 0:
        if(#.fight~fsn > 0){
          sou~sound = .fight~fsn~getSound(!hit.hitsoundg, hit.hitsoundn);
        }
      else:
        if(#by.sn > 0){
          sou~sound = by.sn~getSound(hit.hitsoundg, hit.hitsoundn);
        }
      comm:
        sou~chrx = `pyr.sysfvar[.fX...fX+1];
        sou~setDefaultParameter();
        if(hit.hitsoundg >= 0) sou~setVol(by.sysivar[.iVOLUME]);
      }
      if(hitting > 0){
        by.addPower(hit.hitgetpower);
        `pyr.addPower(hit.hitgivepower);
      }
    else:
      branch{
        if(hit.guard_sparkno == .com.IERR) break;
        ^&.act.Action ani;
      cond hit.guard_sparkno < 0:
        ani = .fight~getAction(!hit.guard_sparkno);
      else:
        ani = by.getAction(hit.guard_sparkno);
      comm:
        branch{
        cond hit.reversal_attr > 0:
          expreset(`pyr=, by=, y, ani);
        else:
          expreset(by=, `pyr=, y, ani);
        }
      }
      branch{
        if(hit.guardsoundg == .com.IERR) break;
        sou = by.newChannel(-1, false);
        if(#sou == 0) break;
      cond hit.guardsoundg < 0:
        if(#.fight~fsn > 0){
          sou~sound = .fight~fsn~getSound(!hit.guardsoundg, hit.guardsoundn);
        }
      else:
        if(#by.sn > 0){
          sou~sound = by.sn~getSound(hit.guardsoundg, hit.guardsoundn);
        }
      comm:
        sou~chrx = `pyr.sysfvar[.fX...fX+1];
        sou~setDefaultParameter();
        if(hit.guardsoundg >= 0) sou~setVol(by.sysivar[.iVOLUME]);
      }
      if(hitting > 0){
        by.addPower(hit.guardgetpower);
        `pyr.addPower(hit.guardgivepower);
      }
    comm:
      if(ho) break;
      branch{
        int byf;
      cond pro == 0:
        byf = by.facing;
        if(hit.p1facing != 0){
          byf *= hit.p1facing < 0 ? -1 : 1;
          by.p1facing = byf;
        }
      else:
        byf = pro;
      comm:
        `pyr.setFacing(byf * -hit.p2facing);
      }
      if(
        #hitting == 1 && hit.p1stateno >= 0 && !by.ls(.lsGETHIT)
        && by.changeState1(hit.player, hit.p1stateno))
      {
        by.setCtrl(false);
      }
      by.addTarget(`pyr.id);
      `pyr.stVal.hb.addByid(by.id, by.sysivar[.iAIRJUGGLE]);
      if(`pyr.hittmp < 2){
        `pyr.stVal.hb.by[-1].juggle = by.sysivar[.iAIRJUGGLE];
      }
      if(`pyr.isFall() && #hitting == 1 && !by.ls(.lsNOJUGGLECHECK)){
        `pyr.stVal.hb.by[-1].juggle -=
          pro != 0 ? hit.air_juggle : by.stVal.juggle;
      }
    diff<hit>:
      if(hit.palfx_time > 0){
        ^&.com.PalFX fx = `pyr.getPalfx();
        fx~clear2(1);
        fx~player = `pyr.id;
        fx~time = hit.palfx_time;
        fx~mulr = hit.palfx_mulr;
        fx~mulg = hit.palfx_mulg;
        fx~mulb = hit.palfx_mulb;
        fx~addr = hit.palfx_addr;
        fx~addg = hit.palfx_addg;
        fx~addb = hit.palfx_addb;
        fx~amplr = hit.palfx_amplr;
        fx~amplg = hit.palfx_amplg;
        fx~amplb = hit.palfx_amplb;
        if(hit.palfx_cycletime > 0) fx~cycletime = hit.palfx_cycletime;
        fx~color =
          .m.max!float?(0.0)<, .m.min!float?(1.0)<,
          ((float)hit.palfx_color / 256.0);
        fx~invertall = hit.palfx_invertall;
      }
      if(hit.envshake_time > 0){
        .stage.envShake.time = hit.envshake_time;
        .stage.envShake.freq = (hit.envshake_freq / 180.0) * .m.PI;
        .stage.envShake.ampl = hit.envshake_ampl;
        .stage.envShake.phase = hit.envshake_phase;
        .stage.envShake.setDefPhase();
      }
      `pyr.getcombo += hit.numhits*hits;
      if(
        hitting > 0 && pro == 0 && !by.cs1tmp && `pyr.ls(.lsSCREENBOUND) && (
          (by.facing < 0 && `pyr.sysfvar[.fX] <= `pxmi)
          || (by.facing > 0 && `pyr.sysfvar[.fX] >= `pxma))
        ) switch(`pyr.stVal.typ)
      {
      case .StTy::S, .StTy::C:
        by.veloff = hit.ground_cornerpush_veloff * (float)by.facing;
      case .StTy::A:
        by.veloff = hit.air_cornerpush_veloff * (float)by.facing;
      case .StTy::L:
        by.veloff = hit.down_cornerpush_veloff * (float)by.facing;
      }
    else:
      if(
        hitting > 0 && pro == 0 && !by.cs1tmp && `pyr.ls(.lsSCREENBOUND) && (
          (by.facing < 0 && `pyr.sysfvar[.fX] <= `pxmi)
          || (by.facing > 0 && `pyr.sysfvar[.fX] >= `pxma))
        ) switch(`pyr.stVal.typ)
      {
      case .StTy::S, .StTy::C:
        by.veloff = hit.guard_cornerpush_veloff * (float)by.facing;
      case .StTy::A:
        by.veloff = hit.airguard_cornerpush_veloff * (float)by.facing;
      }
    }
    ret true;
  }
  bool juggcheck(int h, int a)
  {
    ret a <= h;
  }
  pyr.inguarddist = false;
  pyr.sysivar[.iSPECIALFLAG] &= !.lsGETHIT;
  loop{
    *`top.self p = `top;
    float pl, pr;
    int contact = 0;
    branch{
    cond pyr.facing > 0:
      pl = pyr.sysfvar[.fX] - pyr.backw;
      pr = pyr.sysfvar[.fX] + pyr.frontw;
    else:
      pl = pyr.sysfvar[.fX] - pyr.frontw;
      pr = pyr.sysfvar[.fX] + pyr.backw;
    }
    while;
  do:
    if(p~c~id < 0) continue;
    contact = 0;
    if(
      p~c~atktmp < 0 || p~c~id == pyr.id || (
        p~c~stVal.hit.affectteam != 0
        && ((pyr.playerno&1) != (p~c~playerno&1))
        != (p~c~stVal.hit.affectteam > 0))) continue;
    if(
      p~c~stVal.mov == .MovTy::A && .m.inRange!float?(
        0.0, p~c~attackdist,
        (pyr.sysfvar[.fX] - p~c~sysfvar[.fX])*(float)p~c~facing))
    {
      pyr.inguarddist = true;
    }
    if(
      p~c~stVal.hit.hitonce >= 0
      && (
        pyr.hittmp < 2
        || p~c~ls(.lsNOJUGGLECHECK)
        || juggcheck(
          pyr.stVal.hb.getJuggle(p~c~id, p~c~sysivar[.iAIRJUGGLE]),
          p~c~stVal.juggle))
      && pyr.hittable(
        p~c~stVal.hit=, p~c~id, p~c~stVal.typ, [bool(&.Hitdef h=){
          ret p~c~attrCheck(h=, pyr.id, pyr.stVal.typ)&&p~c~hitCheck(pyr=);}]))
    {
      if(
        .m.inRange!float?(
          0.0, (float)p~c~stVal.hit.guard_dist,
          (pyr.sysfvar[.fX] - p~c~sysfvar[.fX])*(float)p~c~facing))
      {
        pyr.inguarddist = true;
      }
      if(p~c~stVal.hit.reversal_attr <= 0) contact = -1;
      if(pyr.hitCheck(p~c<>=)){
        if(contact < 0) contact = 1;
        branch{
          int h;
          if(!foo(h=, p~c<>=, p~c~stVal.hit=, 0.0, 0.0, 0, 1)) break;
        cond #h == 1:
          p~c~stVal.mctyp = .MoveContact::Hit;
          if(p~c~stVal.hit.reversal_attr > 0){
            pyr.stVal.mctyp = .MoveContact::Reversed;
            pyr.stVal.mctime = -1;
            if(pyr.hittmp == 0) pyr.hittmp = -1;
            if(!pyr.ls(.lsGETHIT)){
              pyr.sysivar[.iHITPAUSETIME] =
                .m.max!int?(
                  1, p~c~stVal.hit.shaketime + (int)(p~c~mver0 == 1));
            }
          }
          if(!p~c~ls(.lsGETHIT)){
            p~c~sysivar[.iHITPAUSETIME] =
              .m.max!int?(1, p~c~stVal.hit.pausetime + (int)(p~c~mver0 == 1));
          }
          p~c~sysivar[.iUNIQHITCOUNT]++;
        else:
          p~c~stVal.mctyp = .MoveContact::Guarded;
          if(!p~c~ls(.lsGETHIT)){
            p~c~sysivar[.iHITPAUSETIME] =
              .m.max!int?(
                1, p~c~stVal.hit.guard_pausetime + (int)(p~c~mver0 == 1));
          }
        comm:
          if(p~c~stVal.hit.hitonce > 0) p~c~stVal.hit.hitonce = -1;
          if(h > 0 || p~c~stVal.hit.reversal_attr > 0) p~c~stVal.mctime = -1;
          p~c~stVal.hitdefContact = 1;
        }
      }
    }
  continue:
    if(
      p~c~id >= 0 && (pyr.playerno&1) != (p~c~playerno&1)
      && pyr.ls(.lsPLAYERPUSH) && p~c~ls(.lsPLAYERPUSH) && (
        (
          pyr.stVal.typ == .StTy::A
          || pyr.sysfvar[.fY] - p~c~sysfvar[.fY] < pyr.getHeight())
        && (
          p~c~stVal.typ == .StTy::A
          || p~c~sysfvar[.fY] - pyr.sysfvar[.fY] < p~c~getHeight())))
    {
      float el, er;
      branch{
      cond p~c~facing > 0:
        el = p~c~sysfvar[.fX] - p~c~backw;
        er = p~c~sysfvar[.fX] + p~c~frontw;
      else:
        el = p~c~sysfvar[.fX] - p~c~frontw;
        er = p~c~sysfvar[.fX] + p~c~backw;
      }
      if(
        pl < er && el < pr
        && (contact > 0 || pyr.clsnCheck(p~c<>=, false, false)))
      {
        const float foo = 0.5;
        branch{
          float tmp = pyr.sysfvar[.fX] - p~c~sysfvar[.fX];
        cond tmp < 0.0:
          pyr.sysfvar[.fX] -= (pr - el) * foo;
          p~c~sysfvar[.fX] += (pr - el) * foo;
        cond tmp > 0.0:
          pyr.sysfvar[.fX] += (er - pl) * foo;
          p~c~sysfvar[.fX] -= (er - pl) * foo;
        cond pyr.sysfvar[.fY] > p~c~sysfvar[.fY]:
          branch{
          cond pyr.facing > 0:
            pyr.sysfvar[.fX] -= (pr - el) * foo;
            p~c~sysfvar[.fX] += (pr - el) * foo;
          else:
            pyr.sysfvar[.fX] += (er - pl) * foo;
            p~c~sysfvar[.fX] -= (er - pl) * foo;
          }
        else:
          branch{
          cond p~c~facing > 0:
            pyr.sysfvar[.fX] += (er - pl) * foo;
            p~c~sysfvar[.fX] -= (er - pl) * foo;
          else:
            pyr.sysfvar[.fX] -= (pr - el) * foo;
            p~c~sysfvar[.fX] += (pr - el) * foo;
          }
        }
        if(pyr.ls(.lsSCREENBOUND)){
          .m.limRange!float?(pyr.sysfvar[.fX]=, pxmi, pxma);
        }
        if(p~c~ls(.lsSCREENBOUND)){
          float l, r, x = p~c~sysfvar[.fX];
          branch{
          cond p~c~facing > 0:
            l = .com.xmin + p~c~getEdge(p~c~bedge);
            r = .com.xmax - p~c~getEdge(p~c~fedge);
          else:
            l = .com.xmin + p~c~getEdge(p~c~fedge);
            r = .com.xmax - p~c~getEdge(p~c~bedge);
          }
          .m.limRange!float?(p~c~sysfvar[.fX]=, l, r);
        }
        .m.limRange!float?(
          pyr.sysfvar[.fX]=, (float).stg~leftbound, (float).stg~rightbound);
        .m.limRange!float?(
          p~c~sysfvar[.fX]=, (float).stg~leftbound, (float).stg~rightbound);
        pyr.drawX = pyr.sysfvar[.fX];
        p~c~drawX = p~c~sysfvar[.fX];
      }
    }
    p = p~next;
  while #p > 0:
  }
  loop{
    index i = 0;
    while;
  do:
    loop{
      index j = 0;
      bool hoge;
      while;
    do:
      .projs[i][j].[void(proj=){
        if(
          pyr.playerno == i || proj.id < 0 || proj.hits <= 0 || (
            proj.hit.affectteam != 0 && ((pyr.playerno&1) != (i&1))
            != (proj.hit.affectteam > 0))) ret;
        if(
          .m.inRange!float?(
            0.0, (float).chars[i][0]~sysivar[.iPROJ_ATTACK_DIST],
            (pyr.sysfvar[.fX] - proj.x) * (float)proj.facing))
        {
          pyr.inguarddist = true;
        }
        hoge = true;
        if(
          proj.hit.hitonce >= 0
          && (
            .chars[i][0]~ls(.lsNOJUGGLECHECK)
            || juggcheck(
              pyr.stVal.hb.getJuggle(
                .chars[i][0]~id, .chars[i][0]~sysivar[.iAIRJUGGLE]),
              proj.hit.air_juggle))
          && proj.timemiss <= 0
          && proj.hitpause <= 0 && pyr.hittable(
            proj.hit=, .chars[i][0]~id, .StTy::N,
            [bool(&.Hitdef h=){
              ret (h.hitflag&(int).StTy::U) != 0 && pyr.hitProjCheck(proj=);
            }]))
        {
          int oldhittmp = pyr.hittmp;
          if(pyr.ls(.lsGETHIT)) pyr.hittmp = (int)pyr.isFall() + 1;
          hoge = false;
          if(
            .m.inRange!float?(
              0.0, (float)proj.hit.guard_dist,
              (pyr.sysfvar[.fX] - .chars[i][0]~sysfvar[.fX])
              * (float).chars[i][0]~facing))
          {
            pyr.inguarddist = true;
          }
          if(pyr.projHitCheck(proj=)){
            int hit;
            if(
              foo(
                hit=, .chars[i][0]<>=, proj.hit=,
                proj.x - .chars[i][0]~sysfvar[.fX],
                proj.y - .chars[i][0]~sysfvar[.fY],
                proj.facing, proj.misstime <= 0 && (
                  #hit == 1 ? proj.hit.pausetime
                  : proj.hit.guard_pausetime) <= 0
                ? proj.hits : 1))
            {
              proj.timemiss = !.m.max!int?(0, proj.misstime);
              branch{
              cond #hit == 1:
                proj.pctyp == .ProjContact::Hit;
                proj.pctime = -1;
                proj.hitpause = .m.max!int?(0, proj.hit.pausetime);
              else:
                proj.pctyp == .ProjContact::Guarded;
                proj.pctime = -1;
                proj.hitpause = .m.max!int?(0, proj.hit.guard_pausetime);
              }
              if(proj.hit.hitonce > 0) proj.hit.hitonce = -1;
            }
          }
        break:
          pyr.hittmp = oldhittmp;
        }
        if(
          proj.prioritypoint > 0 && pyr.atktmp >= 0
          && (
            pyr.stVal.hit.affectteam == 0 || (
            ((i&1) != (pyr.playerno&1)) == (pyr.stVal.hit.affectteam > 0)))
          && (pyr.stVal.hit.hitflag & (int).StTy::U) != 0
          && pyr.hitProjCheck(proj=) && (
            hoge || (
              pyr.stVal.hit.priority == proj.hit.priority
              && proj.hit.bothhittype != .PriTy::Dodge
              && pyr.stVal.hit.bothhittype == .PriTy::Hit)))
        {
          proj.hits = 0;
          proj.prioritypoint = 0;
          proj.pctyp == .ProjContact::Cancel;
          proj.pctime = -1;
        }
      }];
      j++;
    while j < #.projs[i]:
    }
    i++;
  while i < #.projs:
  }
}
public void PlayerList!&Char?::getHit()
{
  loop{
    *`top.self p = `top;
    while;
  do:
    if(p~c~id < 0) continue;
    .players.clsn(p~c<>=);
  continue:
    p = p~next;
  while #p > 0:
  }
}
public void PlayerList!&Char?::tick()
{
  loop{
    *`top.self p = `top;
    while;
  do:
    if(p~c~id < 0) continue;
    p~c~tick();
  continue:
    p = p~next;
  while #p > 0:
  }
}

void playSound()
{
  if(.sdl.setSndBuf(.snd.sndbuf)){
    .snd.sndbufClear();
    .snd.mixSounds();
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(#.chars[i][j] > 0) loop{index k = 0; while; do:
          .chars[i][j]~sounds[k].mix(
            .snd.sndbuf,
            .com.xmin - .com.screenleft, .com.xmax + .com.screenright);
          k++;
        while k < #.chars[i][j]~sounds:}
        j++;
      while j < #.chars[i]:}
      i++;
    while i < #.chars:}
  }
}
void stopAllSound()
{
  if(.sdl.setSndBuf(.snd.sndbuf)){
    .snd.sndbufClear();
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(#.chars[i][j] > 0) loop{index k = 0; while; do:
          .chars[i][j]~sounds[k].sound.new(0);
          k++;
        while k < #.chars[i][j]~sounds:}
        j++;
      while j < #.chars[i]:}
      i++;
    while i < #.chars:}
  }
}

public void charInit(&.Char c=, int no, int idx)
{
  c.clearVal();
  c.playerno = no;
  c.helperindex = idx;
  if(c.helperindex == 0){
    c.keyctrl = true;
    c.player = true;
  }
  c.key = .m.inRange!int?(0, #.com.com-1, no) && .com.com[no] == 0 ?  no : !no;
}

public ^&Char create(int no)
{
  index idx = 0;
  loop{while; do:
    if(.chars[no][idx]~helperindex < 0) break;
    idx++;
  while idx < #.chars[no]:
    if(idx >= .cfg.HelperMax) ret .consts.null!&.Char?();
    .chars[no].new[idx].new(1);
  }
  ^&.Char c = .chars[no][idx];
  .charInit(c<>=, no, idx);
  c~id = .id++;
  .players.add(c);
  ret c;
}
void gSetNormal(float scl, float x, float y)
{
  .com.scale = .stg~ztopscale*scl;
  .com.zoffset =
    (float)(.stg~zoffset + (.com.GameHeight - 240))*scl
    + (1.0 - scl)*(float).com.GameHeight;
  .com.yoffset = (.stg~bga.yoffset-.stage.envShake.getOffset())*scl;
  .com.xoffset = .stg~bga.xoffset*scl;
  .com.scrxmin =
    (float)(.stg~cam.boundleft - .stg~cam.startx)
    - ((float).com.GameWidth/2.0)/.stg~ztopscale;
  .com.scrxmax =
    (float)(.stg~cam.boundright - .stg~cam.startx)
    + ((float).com.GameWidth/2.0)/.stg~ztopscale;
  .com.screenx = x - ((float).com.GameWidth/2.0) / .com.scale;
  .com.screeny =
    y - (.com.zoffset - (float)(.com.GameHeight-240)*scl) / .com.scale;
  .com.camerax = x;
  .com.cameray = y + (float)(.com.GameHeight-240);
  .com.screenleft = (float).stg~screenleft;
  .com.screenright = (float).stg~screenright;
}

^&.fgt.LifePower getLifePower()
{
  %&.fgt.LifePower lpl;
  loop{index i = 0; while; do:
    branch{
    cond #.chars[i] > 0:
      lpl.new[-1].set(
        (float).chars[i][0]~sysivar[.iLIFE]
        / (float).chars[i][0]~sysivar[.iLIFEMAX],
        (float).chars[i][0]~getSharePower()
        / (float).chars[i][0]~sysivar[.iPOWERMAX],
        .chars[i][0]~getSharePower() / 1000);
    else:
      lpl.new[-1].set(0.0, 0.0, 0);
    }
    i++;
  while i < #.chars:
  }
  ret lpl;
}

void update(
  float cvmin=, float cvmax=,
  float highest=, float lowest=, float leftest=, float rightest=)
{
  .players.update(cvmin=, cvmax=, highest=, lowest=, leftest=, rightest=);
  loop{index i = 0; while; do:
    loop{index j = 0; while; do:
      if(.projs[i][j].id >= 0) .projs[i][j].update();
      j++;
    while j < #.projs[i]:}
    i++;
  while i < #.projs:}
}

void commandUpdate()
{
  loop{index i = 0; while; do:
    if(#.chars[i] == 0) continue;
    .chars[i].[void(p){
      if(p<>~cmd~input(p<>~key, p<>~facing)) loop{index i = 0; while; do:
        p<>~cmd[i].step(
          p<>~key, p<>~facing, p<>~key < 0, p<>~acttmp%2 == -1);
        i++;
      while i < #p<>~cmd:}
      if(p<>~key < 0) loop{
        index j = 0;
        index cc =
          p[j]~roundState() == 2 && #p[j]~keyctrl
          && .m.rand(0, .com.com[i]+16) > 16
          ? .m.rand(0, #p[j]~cmd[p[j]~stVal.playerno].commands-1) : -1;
        while;
      do:
        if(p[j]~helperindex >= 0) p[j]~cpucmd = cc;
        j++;
      while j < #p:
      }
    }];
  continue:
    i++;
  while i < #.chars:
  }
}

void rootAction()
{
  if(.com.tickNextFrame()){
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(.projs[i][j].id >= 0) .projs[i][j].projClsn();
        j++;
      while j < #.projs[i]:
      }
      i++;
    while i < #.projs:
    }
    .players.getHit();
    loop{index i = 0; while; do:
      loop{index j = 0; while; do:
        if(.projs[i][j].id != .com.IERR) .projs[i][j].tick();
        j++;
      while j < #.projs[i]:
      }
      i++;
    while i < #.projs:
    }
    .players.tick();
  }
}

void anim()
{
  loop{index i = 0; while; do:
    loop{index j = 0; while; do:
      if(.projs[i][j].id >= 0) .projs[i][j].anime(.chars[i]<>~mver0 != 1);
      j++;
    while j < #.projs[i]:
    }
    i++;
  while i < #.projs:
  }
  loop{index i = 0; while; do:
    loop{index j = 0; while; do:
      .chars[i][j]~drawAnim();
      j++;
    while j < #.chars[i]:
    }
    i++;
  while i < #.chars:
  }
}

public float action(
  float x=, float y=, float leftest=, float rightest=, float scl)
{
  .anims.new(0);
  .topanims.new(0);
  .shadows.new(0);
  .resetDrawnClsnList();
  .gSetNormal(scl, x, y);
  float cvmin = 0.0, cvmax = 0.0;
  float highest = 0.0, lowest = .com.screeny;
  rightest = leftest = x;
  int rs4t = -(.fight~ro.over_hittime + .fight~ro.over_waittime);
  bool zoomReset = false;
  branch{
  cond .com.tickFrame():
    .oldx = x;
    .com.xmin = .com.screenx + .com.screenleft;
    .com.xmax =
      .com.screenx + ((float).com.GameWidth / .com.scale) - .com.screenright;
    if(.com.xmin > .com.xmax){
      .com.xmin = .com.xmax = (.com.xmin + .com.xmax) * 0.5;
    }
    .sff.allPalFX~step();
    .stage.bgPalFX~step();
    .stage.envShake.next();
    if(.envcol_time > 0) .envcol_time--;
    branch{
    cond .super > 0:
      .super--;
    cond .pause > 0:
      .pause--;
    }
    if(.pausetime < 0){
      .pausetime = !.pausetime;
      .pause = .pausetime;
    }
    if(.supertime < 0){
      .supertime = !.supertime;
      .super = .supertime;
    }
    branch{
    cond .super <= 0 && .pause <= 0:
      .specialFlag = 0d0;
    else:
      .specialFlag &= !.gsROUNDNOTOVER;
    }
    if(#.superanim > 0) .superanim~ani.action();
    .players.action(x, cvmin=, cvmax=, highest=, lowest=, leftest=, rightest=);
  else:
    .update(cvmin=, cvmax=, highest=, lowest=, leftest=, rightest=);
    .rootAction();
  }
  %bool hbuf;
  loop{index i = 0; while; do:
    branch{
    cond #.chars[i] > 0:
      hbuf .=
        (.chars[i][0]~getcombo != 0 || .chars[i][0]~stVal.mov == .MovTy::H)
        && (.chars[i][0]~sysivar[.iSYSFLAG] & .sfOVER) == 0;
    else:
      hbuf .= false;
    }
    i++;
  while i < #.chars:
  }
  ^int cb;
  cb.new(2);
  cb[0] = cb[1] = 0;
  loop{index i = 0; while; do:
    loop{index j = 0; while; do:
      cb[!i&1] =
        .m.min!int?(999)<, .m.max!int?(cb[!i&1], .chars[i][j]~getcombo);
      j++;
    while j < #.chars[i]:
    }
    i++;
  while i < #.chars:
  }
  .fight~step(.com.tmode, .getLifePower(), hbuf, cb);
  void sprite()
  {
    if(#.superanim > 0){
      .addAnimList(
        .topanims=, .superanim, 5, .superposx, .superposy, .com.scale,
        (float).superfacing, 1.0, 0.0, false,
        .chars[.superplayer]<>~mver0 != 1, 1.0, 1.0, -1, 0, 256,
        .consts.null!&.com.PalFX?(), 0, 0, 0.0);
      if(.superanim~ani.loopend) .superanim.new(0);
    }
    .anim();
    void expUpdate(^%index drawlist=, bool delI)
    {
      loop{index i = 0; while; do:
        loop{index j = #drawlist[i]-1; while; do:
          if(drawlist[i][j] < 0) continue;
          .explods[i][drawlist[i][j]].update(.chars[i]<>~mver0 != 1);
          if(.explods[i][drawlist[i][j]].id == .com.IERR) branch{
          cond delI:
            .delIL(drawlist[i]=, j);
          else:
            drawlist[i][j] = -1;
          }
        continue:
          j--;
        while j >= 0:
        }
        i++;
      while i < #.explods:
      }
    }
    expUpdate(.expdrawlist=, true);
    expUpdate(.topexpdrawlist=, false);
  }
  leftest -= x;
  rightest -= x;
  branch{
    float tension =
      ((float).com.GameWidth/2.0 - (float).stg~cam.tension)/.com.scale;
    float tmp = (leftest + rightest) / 2.0;
    float cvx = cvmin + cvmax;
    if(cvx == 0.0 || (cvx < 0.0) == (tmp < 0.0)){
      float vel =
        .com.intro > .fight~ro.ctrl_time+1 ? (float).com.GameWidth/2.0
        : .super > 0 || .pause > 0 ? 2.0
        : 3.0;
      cvx += vel * (tmp < 0.0 ? -1.0 : 1.0);
    }
    cvx *= .m.min!float?(1.0, .com.turbo);
  cond cvx < 0.0:
    tmp = .m.max!float?(leftest + tension, tmp);
    if(cvx < tmp) cvx = .m.min!float?(0.0, tmp);
  else:
    tmp = .m.min!float?(rightest - tension, tmp);
    if(cvx > tmp) cvx = .m.max!float?(0.0, tmp);
  comm:
    x += cvx;
  }
  if(lowest >= highest) branch{
  cond highest < (float)-.stg~cam.floortension / .com.scale:
    y =
      (highest + (float).stg~cam.floortension / .com.scale)
      * .com.scale * .stg~cam.verticalfollow;
  else:
    y = 0.0;
  }
  void setWinType(bool p1, bool p2)
  {
    branch{
    cond
      .com.tmode[0] != (int).com.TeamMode::Turns
      && .com.tmode[1] != (int).com.TeamMode::Turns
      && .com.draws < .fight~ro.match_maxdrawgames && p1 && p2
      :
      .com.draws++;
    else:
      if(p2){
        loop{index i = 0; while; do:
          if(
            #.chars[i] > 0
            && .chars[i][0]~sysivar[.iLIFE]
            < .chars[i][0]~sysivar[.iLIFEMAX]) break;
          i += 2;
        while i < #.chars:
          .fgt.setPerfect(.winty[0]=);
        }
        .fight~wi[0].add(.winty[0]);
        .com.p1wins += 1;
      }
      if(p1){
        loop{index i = 1; while; do:
          if(
            #.chars[i] > 0
            && .chars[i][0]~sysivar[.iLIFE]
            < .chars[i][0]~sysivar[.iLIFEMAX]) break;
          i += 2;
        while i < #.chars:
          .fgt.setPerfect(.winty[1]=);
        }
        .fight~wi[1].add(.winty[1]);
        .com.p2wins += 1;
      }
    }
  }
  bool finish()
  {
    bool p1 = false, p2 = false;
    loop{index i = 0; while; do:
      if(#.chars[i] > 0 && !.chars[i][0]~isKO()) break;
      i += 2;
    while i < #.chars:
      p1 = true;
    }
    loop{index i = 1; while; do:
      if(#.chars[i] > 0 && !.chars[i][0]~isKO()) break;
      i += 2;
    while i < #.chars:
      p2 = true;
    }
    branch{
    cond .com.time == 0:
      .com.intro = -.fight~ro.over_hittime;
      if(p1 || p2) break;
      .winty[0] = .winty[1] = .fgt.WinTy::T;
    }
    if(.com.intro == -.fight~ro.over_hittime && (p1 || p2)){
      `setWinType(p1, p2);
      branch{
      cond p1 && p2:
        .ko = .fgt.KOTy::DKO;
        .com.win = -1;
      cond p1:
        .ko = .fgt.KOTy::KO;
        .com.win = 1;
      cond p2:
        .ko = .fgt.KOTy::KO;
        .com.win = 0;
      }
    }
    ret p1 || p2 || .com.time == 0;
  }
  void posreset()
  {
    loop{
      index i = 0;
      float ox = `x;
      while;
    do:
      if(#.chars[i] > 0){
        if(.gs(.gsINTRO)){
          .charClear(i);
          .chars[i][0]~trSelfState(0, -1, 1);
        }
        .chars[i][0]~posReset(
          (float)(.stg~p1.startx - .stg~cam.startx),
          (float)(.stg~p2.startx - .stg~cam.startx));
      }
      i++;
    while i < #.chars:
      if(.gs(.gsINTRO)){
        `x = 0.0;
        `leftest =
          .m.max!float?(
            (float).m.min!int?(.stg~p1.startx, .stg~p2.startx),
            -((float).com.GameWidth/2.0)/.stg~ztopscale + .com.screenleft)
          - ox;
        `rightest =
          .m.min!float?(
            (float).m.max!int?(.stg~p1.startx, .stg~p2.startx),
            ((float).com.GameWidth/2.0)/.stg~ztopscale - .com.screenright)
          - ox;
        `zoomReset = true;
      }
    }
  }
  int slowfade = .fight~ro.slow_time * 2 / 5;
  branch{
  cond .shuttertime > 0 ? .com.tickNextFrame() : .fight~ro.act(.ko):
    branch{
    cond .com.intro > .fight~ro.ctrl_time:
      .com.intro--;
      if(.gs(.gsINTRO) && .com.intro <= .fight~ro.ctrl_time){
        branch{
        cond .shuttertime > 0 || .cmd.anybutton():
          if(.shuttertime < 15) .shuttertime++;
          branch{
          cond .shuttertime == 15:
            posreset();
            .resetGblEffect();
          else:
            break, else;
          }
        else:
          .com.intro = .fight~ro.ctrl_time+1;
        }
      }
    else:
      if(.shuttertime == 0 && .com.intro >= 1){
        .com.intro--;
        if(.com.intro == 0) loop{index i = 0; while; do:
          if(#.chars[i] > 0) branch{
          cond .chars[i][0]~stVal.no == 0:
            .chars[i][0]~setCtrl(true);
          else:
            .chars[i][0]~trSelfState(0, -1, 1);
          }
          i++;
        while i < #.chars:}
      }
      if(.shuttertime > 0) .shuttertime--;
    }
    if(
      .com.intro == 0 && .com.time > 0 && !.gs(.gsTIMERFREEZE)
      && (.super <= 0 || .superpausebg == 0) 
      && (.pause <= 0 || .pausebg == 0)) .com.time--;
    branch{
    cond .roundEnd() || finish():
      if(
        .winskipped || !.gs(.gsROUNDNOTOVER)
        || .com.intro >= rs4t - .fight~ro.over_wintime)
      {
        if(.ko == .fgt.KOTy::NotYet && .com.intro == rs4t){
          bool p1 = false, p2 = false;
          float l1 = 0.0, l2 = 0.0;
          loop{index i = 0; while; do:
            if(#.chars[i] > 0){
              l1 +=
                (.com.tmode[0] == (int).com.TeamMode::Simul ? 0.5 : 1.0)
                * (float).chars[i][0]~sysivar[.iLIFE]
                / (float).chars[i][0]~sysivar[.iLIFEMAX];
            }
            i += 2;
          while i < #.chars:
          }
          loop{index i = 1; while; do:
            if(#.chars[i] > 0){
              l2 +=
                (.com.tmode[1] == (int).com.TeamMode::Simul ? 0.5 : 1.0)
                * (float).chars[i][0]~sysivar[.iLIFE]
                / (float).chars[i][0]~sysivar[.iLIFEMAX];
            }
            i += 2;
          while i < #.chars:
          }
          branch{
          cond l1 > l2:
            p2 = true;
          cond l2 > l1:
            p1 = true;
          else:
            p1 = p2 = true;
          }
          setWinType(p1, p2);
          branch{
          cond p1 && p2:
            .ko = .fgt.KOTy::TODraw;
            .com.win = -1;
          cond p1:
            .ko = .fgt.KOTy::TO;
            .com.win = 1;
          cond p2:
            .ko = .fgt.KOTy::TO;
            .com.win = 0;
          }
        }
        .com.intro--;
        if(.com.intro == rs4t-1) loop{
          if(.com.time == 0) .com.intro -= .fight~ro.over_wintime;
          if(.waitdown <= 0) break;
          index i = 0;
          while;
        do:
          if(#.chars[i] > 0 && !.chars[i][0]~isOver()) .com.intro = rs4t;
          i++;
        while i < #.chars:
        }
        if(.waitdown <= 0 || .com.intro < rs4t - .fight~ro.over_wintime) loop{
          index i = 0;
          while;
        do:
          if(#.chars[i] == 0) continue;
          .chars[i][0]~[void(c=){
            if(
              (c.sysivar[.iSYSFLAG] & .sfOVER) == 0
              && c.isActive() && !c.isKO() && (c.isOver() || .waitdown <= 0))
            {
              if(
                .com.time > 0 && c.isWin() && c.sysivar[.iLIFE] > 0
                && .com.p1wins < .com.p1mw && .com.p2wins < .com.p2mw
                && (
                  .com.tmode[0] == (int).com.TeamMode::Turns
                  || .com.tmode[1] == (int).com.TeamMode::Turns))
              {
                c.sysivar[.iLIFE] +=
                  (int)(
                    (float)c.sysivar[.iLIFEMAX]
                    * (float).com.time * (1.0/60.0) * .cfg.TurnsRecoveryRate);
                .m.limMax!int?(c.sysivar[.iLIFE]=, c.sysivar[.iLIFEMAX]);
              }
              c.trSelfState(c.isWin() ? 180 : (c.isLose() ? 170 : 175), -1, 1);
            }
          }];
        continue:
          i++;
        while i < #.chars:
        }
        .waitdown--;
      }
    else:
      if(.com.intro < 0) .com.intro = 0;
    }
    sprite();
  cond .fight~ro.cur == 1 && .com.tickNextFrame():
    sprite();
    posreset();
  else:
    sprite();
  }
  if(.com.turbo == 0.0 || .com.tickNextFrame()) branch{
    int slowt = -(.fight~ro.over_hittime+((.fight~ro.slow_time+3)>>2));
    float spd = .com.pause && !.com.step ? 0.0 : .com.Speed*.com.accel;
  cond
    !.gs(.gsNOKOSLOW) && .com.time != 0
    && .m.inRange!int?(slowt, -.fight~ro.over_hittime-1, .com.intro)
    :
    .com.turbo = spd * 0.25;
  cond
    !.gs(.gsNOKOSLOW) && .com.time != 0
    && .m.inRange!int?(slowt-slowfade, slowt-1, .com.intro)
    :
    .com.turbo =
      spd*(0.25 + 0.75 * (float)(-.com.intro + slowt)/(float)slowfade);
  else:
    .com.turbo = spd;
  }
  .sdl.pauseBGM(.gs(.gsNOMUSIC));
  .playSound();
  float foobar =
    .m.max!float?(220.0/.com.scale)<, .m.sqrt(
      (rightest - leftest)**2.0 + (lowest - highest)**2.0);
  const float barbaz = 12.0;
  float tmp =
    (foobar*.com.scale) / .m.max!float?(.com.scale)<, (
      (400.0 - 80.0*.m.max!float?(1.0, .com.scale)) * 2.0**(barbaz-2.0));
  branch{
  cond tmp >= 3.0/2.0**barbaz:
    tmp = .m.max!float?(15.0/16.0)<, (67.0/64.0 - tmp*2.0**(barbaz-6.0));
  else:
    tmp =
      .m.min!float?(129.0/128.0)<, ((2.0**barbaz+3.0)/2.0**barbaz - tmp)**64.0;
  }
  branch{
  cond zoomReset:
    tmp = 1.0 / scl;
  cond .super > 0 || .pause > 0:
    tmp = 1.0;
  cond tmp > 1.0:
    tmp = (tmp - 1.0)*.zoomdelay**8.0 + 1.0;
    if(foobar*tmp > .com.xmax - .com.xmin){
      tmp = (.com.xmax - .com.xmin) / foobar;
    }
    .zoomdelay = .m.min!float?(1.0, .zoomdelay + 1.0/32.0);
  else:
    .zoomdelay = 0.0;
  }
  leftest -= .com.screenleft;
  rightest += .com.screenright;
  leftest *= .stg~ztopscale;
  rightest *= .stg~ztopscale;
  ret tmp;
}
public void draw(float x, float y, float scl)
{
  ^&.fgt.LifePower lpl = .getLifePower();
  uint ecol =
    ((uint).envcol_b&0xff)
    | ((uint).envcol_g<<0d8&0xff00) | ((uint).envcol_r<<0d16&0xff0000);
  ^ubyte px;
  px.new(1);
  px<> = 0d0;
  %^/char winner;
  if(.com.win >= 0){
    winner.new[-1] = .chars[.com.win][0]~displayname;
    if(.com.tmode[.com.win] == (int).com.TeamMode::Simul){
      winner.new[-1] = .chars[.com.win+2][0]~displayname;
    }
  }
  ^^/char names.new(#.chars);
  ^^&.com.PalFX facefx.new(#.chars);
  loop{index i = 0; while; do:
    if(#.chars[i] > 0){
      names[i] = .chars[i][0]~displayname;
      facefx[i] = .chars[i][0]~getPalfx();
      .fight~fa[.com.tmode[i&1]][i].face_spr.[void(fs){
        if(#fs == 0) ret;
        fs~colorPallet.new(0);
        fs~colorPallet = fs~getPal(.chars[i][0]~sf~palList=);
      }];
    }
    i++;
  while i < #names:}
  int ob = .com.brightness;
  .com.brightness = 256 >> (int)(.super > 0 && .superdarken != 0);
  if(.envcol_time == 0) branch{
  cond .gs(.gsNOBG):
    .com.screenFill(0x00000000);
  else:
    if(.stg~debugbg) .com.screenFill(0x00ff00ff);
    .stg~bgDraw(false, x, y, scl);
  comm:
    if(!.gs(.gsGLOBALNOSHADOW)){
      if(.stg~reflection > 0) .drawReflection(x, y);
      .drawShadowList(x, y);
    }
    {
      float off = .stage.envShake.getOffset();
      float bh = 
        (
          .stg~cam.verticalfollow != 0.0
          ? (float).m.min!int?(0, .stg~cam.boundhigh) : 0.0)
        + ((float).com.GameHeight - 240.0);
      float yofs =
        (
          scl > 1.0 ? (float)(.stg~zoffset + (.com.GameHeight - 240))
          : (float).com.GameHeight)
        * (1.0/scl - 1.0);
      float yofs2 =
        scl > 1.0 ? (240.0 - (float).stg~zoffset)*(1.0 - 1.0/scl) : 0.0;
      *.com.scrrect.self rect = .com.scrrect;
      if(off - bh < yofs - y){
        rect.h =
          (
            (uint)(((yofs - y) - (off - bh))*scl + 0.5)*.com.scrrect.h
            + (uint)(.com.GameHeight-1))
          / (uint).com.GameHeight;
        fade(rect=, 255);
      }
      if(off > -y + yofs2){
        rect.h =
          (
            (uint)(((y - yofs2) + off)*scl + 0.5)*.com.scrrect.h
            + (uint)(.com.GameHeight-1))
          / (uint).com.GameHeight;
        rect.y = (int)(.com.scrrect.h - rect.h);
        fade(rect=, 255);
      }
      float bl =
        .m.min!float?(x, (float)(.stg~cam.boundleft - .stg~cam.startx));
      float br =
        .m.max!float?(x, (float)(.stg~cam.boundright - .stg~cam.startx));
      float xofs =
        ((float).com.GameWidth*(1.0/scl - 1.0) + (float)(.com.GameWidth-320))
        / 2.0;
      rect = .com.scrrect;
      if(x - xofs < bl){
        rect.w =
          (
            (uint)((bl - (x - xofs))*scl + 0.5)*.com.scrrect.w
            + (uint)(.com.GameWidth-1))
          / (uint).com.GameWidth;
        fade(rect=, 255);
      }
      if(x + xofs > br){
        rect.w =
          (
            (uint)(((x + xofs) - br)*scl + 0.5)*.com.scrrect.w
            + (uint)(.com.GameWidth-1))
          / (uint).com.GameWidth;
        rect.x = (int)(.com.scrrect.w - rect.w);
        fade(rect=, 255);
      }
    }
  }
  branch{
  cond .envcol_time != 0:
    if(.envcol_under != 0) .com.screenFill(ecol);
  else:
    .fight~draw(0, lpl, names, .gs(.gsNOBARDISPLAY), facefx, .superplayer);
    .fight~ro.draw(0, .ko, winner);
  }
  if(.envcol_time == 0 || .envcol_under != 0){
    .drawAnimList(.anims=, x, y);
  }
  if(.envcol_time == 0 && !.gs(.gsNOFG)) .stg~bgDraw(true, x, y, scl);
  if(.envcol_time != 0 && .envcol_under == 0){
    .com.screenFill(ecol);
  }
  .fight~draw(1, lpl, names, .gs(.gsNOBARDISPLAY), facefx, .superplayer);
  .fight~ro.draw(1, .ko, winner);
  .drawAnimList(.topanims=, x, y);
  .fight~draw(2, lpl, names, .gs(.gsNOBARDISPLAY), facefx, .superplayer);
  .fight~ro.draw(2, .ko, winner);
  void fade(.com.scrrect.self rect=, int alpha)
  {
    .com.rectFill(
      rect=, 0x000000, (alpha>>(int).com.clsndraw)+(int).com.clsndraw*128);
  }
  branch{
    int tmp =
      .fight~ro.over_hittime + .fight~ro.over_waittime
      + (.fight~ro.over_time - .fight~ro.start_waittime);
  cond .com.intro > .fight~ro.ctrl_time+1:
    fade(
      .com.scrrect=,
      256 * (.com.intro - (.fight~ro.ctrl_time+1)) / .fight~ro.start_waittime);
  cond .fight~ro.over_time >= .fight~ro.start_waittime && .com.intro < -tmp:
    fade(.com.scrrect=, 256 * (-tmp - .com.intro) / .fight~ro.start_waittime);
  cond .com.clsndraw:
    fade(.com.scrrect=, 0);
  }
  if(.shuttertime > 0){
    *.com.scrrect.self rect = .com.scrrect;
    rect.h = (uint).shuttertime * ((.com.scrrect.h+0d1)>>0d1) / 0d15;
    fade(rect=, 255);
    rect.y = (int)(.com.scrrect.h - rect.h);
    fade(rect=, 255);
  }
  .com.brightness = ob;
  if(.com.clsndraw) .drawClsn();
}

void resetGblEffect()
{
  .sff.allPalFX~clear();
  .stage.bgPalFX~clear();
  .stage.envShake.clear();
  .pause = 0;
  .pausetime = 0;
  .super = 0;
  .supertime = 0;
  .superanim.new(0);
  .envcol_time = 0;
  .specialFlag = 0d0;
}
void resetGbl()
{
  .resetGblEffect();
  .fight~reset();
  .ko = .fgt.KOTy::NotYet;
  .com.win = -1;
  .winty[0] = .winty[1] = .fgt.WinTy::N;
  .zoomdelay = 0.0;
  .playerid.new(0);
  .resetNumenemy();
  .waitdown = 900;
  .shuttertime = 0;
  .winskipped = false;
}

void charClear(int pn)
{
  .chars[pn].[void(cs){
    loop{index j = 1; while; do:
      cs[j]~destroySelf();
      cs[j]~sounds.new(0);
      j++;
    while j < #.chars[pn]:
    }
    .projs[pn].new(0);
    .explods[pn].new(0);
    .expdrawlist[pn].new(0);
    .topexpdrawlist[pn].new(0);
    cs[0]~children.new(0);
    cs[0]~targets.new(0);
    cs[0]~sounds.new(0);
  }];
}

public void nextRound()
{
  .resetGbl();
  .com.intro = .fight~ro.start_waittime + .fight~ro.ctrl_time+1;
  .com.time = .cfg.Time;
  .id = .cfg.HelperMax;
  if(.stg~resetbg) .stg~reset();
  .gSetNormal(1.0, 0.0, 0.0);
  loop{index i = 0; while; do:
    if(#.chars[i] == 0) continue;
    .chars[i][0]~[void(c=){
      .id = c.id + 1;
      .charClear(i);
      c.posReset(
        (float)(.stg~p1.startx - .stg~cam.startx),
        (float)(.stg~p2.startx - .stg~cam.startx));
      c.setCtrl(false);
      c.stVal.clear();
      c.clearSpSysVar();
      c.rangeSetIVar(0, c.sysivar[.iINTPERSISTINDEX]-1, 0);
      c.rangeSetFVar(0, c.sysivar[.iFLOATPERSISTINDEX]-1, 0.0);
      loop{index j = 0; while; do:
        c.cmd[j].bufReset(c.key);
        j++;
      while j < #.chars:}
    }];
  continue:
    i++;
  while i < #.chars:}
  loop{index i = 0; while; do:
    if(#.chars[i] > 0) .chars[i][0]~trSelfState(5900, 0, -1);
    i++;
  while i < #.chars:}
}


public bool roundOver()
{
  if(
    .com.intro < -(
      .fight~ro.over_hittime
      + .fight~ro.over_waittime + .fight~ro.over_wintime)
    && .cmd.anybutton())
  {
    .com.intro =
      .m.min!int?(
        .com.intro,
        -(
          .fight~ro.over_hittime + .fight~ro.over_waittime
          + (.fight~ro.over_time - .fight~ro.start_waittime)));
    .winskipped = true;
  }
  ret
    .com.intro < -(
      .fight~ro.over_hittime + .fight~ro.over_waittime + .fight~ro.over_time);
}

