
lib file = <file.ssz>;
lib s = <string.ssz>;
lib consts = <consts.ssz>;
lib mes = <alpha/mesdialog.ssz>;
lib tbl = <table.ssz>;
lib al = <alert.ssz>;
lib m = <math.ssz>;
lib chr = "char.ssz";
lib com = "common.ssz";
lib cfg = "config.ssz";

const ^/char kuuhaktokigou = " !=<>()|&+-*/%,[]^|:"\"\t\r\n;

void errmes(^/char fn, ^/char line, index ln, ^/char mess)
{
  %char buf;
  .al.alert!.self?(
    buf .= fn .= '(' .= .s.iToS(ln+1) .= ')' .= \r\n .= line .= \r\n .= mess);
}

|CtrlTy
{
  Unknown,
  ChangeState, SelfState, ChangeAnim, ChangeAnim2,
  PosSet, PosAdd, VelSet, VelAdd, VelMul, Turn,
  VarSet, VarAdd, VarRangeSet,
  VarRandom,
  CtrlSet, StateTypeSet, SprPriority,
  HitDef, Projectile, ReversalDef,
  AttackDist,
  HitOverride,
  Pause, SuperPause,
  LifeAdd, LifeSet, PowerAdd, PowerSet,
  TargetLifeAdd, TargetBind, TargetState,
  TargetVelSet, TargetVelAdd, TargetFacing,
  TargetPowerAdd, TargetDrop,
  HitBy, NotHitBy, AttackMulSet, DefenceMulSet,
  MoveHitReset,
  AssertSpecial, PosFreeze, PlayerPush, Gravity,
  BindToParent, BindToRoot, BindToTarget,
  Helper,
  DestroySelf,
  Explod, ModifyExplod, ExplodBindTime, RemoveExplod,
  AfterImage, AfterImageTime, GameMakeAnim, MakeDust,
  AngleDraw, AngleAdd, AngleMul, AngleSet,
  PalFX, AllPalFX, BGPalFX,
  Trans, Offset,
  HitVelSet, HitFallSet, HitFallVel, HitFallDamage, FallEnvShake,
  EnvColor, EnvShake,
  Width,
  ScreenBound,
  HitAdd,
  PlaySnd, StopSnd, SndPan,
  DisplayToClipboard, AppendToClipboard, ClearClipboard,
  ForceFeedback, Null
}
&StateCtrl
{
  public %%char trigger;
  public %char triggerall;
  public %char task;
  public |.CtrlTy typ = .CtrlTy::Unknown;
}

&State
{
  public %&.StateCtrl ctrlList;
  public %char deftask;
  public ^/char v, fv, value, ignorehitpause;
  public |.chr.StTy typ;
  public |.chr.StTy phy;
  public |.chr.MovTy mov;
  public int hitcountpersist;
  public int hitdefpersist;
  public int movehitpersist;
  public int juggle;
  public int flag;
  public ^/char persist;
  public int no;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `ctrlList.new(0);
    `deftask.new(0);
    `typ = .chr.StTy::S;
    `phy = .chr.StTy::N;
    `mov = .chr.MovTy::I;
    `hitcountpersist = 0;
    `hitdefpersist = 0;
    `movehitpersist = 0;
    `juggle = 0;
  }
  public void tmpreset()
  {
    `ignorehitpause = "";
    `v = "";
    `fv = "";
    `value = "";
    `flag = 0;
    `persist = "";
  }
}

&Data
{
  public int life;
  public int power;
  public int attack;
  public int defence;
  public float fall_defence_mul;
  public int liedown_time;
  public int airjuggle;
  public int sparkno;
  public int guard_sparkno;
  public int ko_echo;
  public int volume;
  public int intpersistindex;
  public int floatpersistindex;
  new()
  {
    `reset();
  }
  public void reset()
  {
    `life = 1000;
    `power = 3000;
    `attack = 100;
    `defence = 100;
    `fall_defence_mul = 3.0 / 2.0;
    `liedown_time = 60;
    `airjuggle = 15;
    `sparkno = 2;
    `guard_sparkno = 40;
    `ko_echo = 0;
    `volume = 0;
    `intpersistindex = 0;
    `floatpersistindex = 0;
  }
}
&Size
{
  public float xscale;
  public float yscale;
  public int ground_back;
  public int ground_front;
  public int air_back;
  public int air_front;
  public int height;
  public int attack_dist;
  public int proj_attack_dist;
  public int proj_doscale;
  public float proj_xscale;
  public float proj_yscale;
  public int head_posx;
  public int head_posy;
  public int mid_posx;
  public int mid_posy;
  public int shadowoffset;
  public int draw_offsetx;
  public int draw_offsety;
  new()
  {
    `reset();
  }
  public void reset()
  {
    `xscale = 1.0;
    `yscale = 1.0;
    `ground_back = 15;
    `ground_front = 16;
    `air_back = 12;
    `air_front = 12;
    `height = 60;
    `attack_dist = 160;
    `proj_attack_dist = 90;
    `proj_doscale = 0;
    `proj_xscale = 1.0;
    `proj_yscale = 1.0;
    `head_posx = -5;
    `head_posy = -90;
    `mid_posx = -5;
    `mid_posy = -60;
    `shadowoffset = 0;
    `draw_offsetx = 0;
    `draw_offsety = 0;
  }
}
&Velocity
{
  public float walk_fwd;
  public float walk_back;
  public float run_fwdx;
  public float run_fwdy;
  public float run_backx;
  public float run_backy;
  public float jump_neux;
  public float jump_neuy;
  public float jump_back;
  public float jump_fwd;
  public float runjump_backx;
  public float runjump_backy;
  public float runjump_fwdx;
  public float runjump_fwdy;
  public float airjump_neux;
  public float airjump_neuy;
  public float airjump_back;
  public float airjump_fwd;
  new()
  {
    `reset();
  }
  public void reset()
  {
    `walk_fwd = 2.4;
    `walk_back = -2.2;
    `run_fwdx = 4.6;
    `run_fwdy = 0.0;
    `run_backx = -4.5;
    `run_backy = -3.8;
    `jump_neux = 0.0;
    `jump_neuy = -8.4;
    `jump_back = -2.55;
    `jump_fwd = 2.5;
    `runjump_backx = -2.55;
    `runjump_backy = -8.1;
    `runjump_fwdx = 4.0;
    `runjump_fwdy = -8.1;
    `airjump_neux = 0.0;
    `airjump_neuy = -8.1;
    `airjump_back = -2.55;
    `airjump_fwd = 2.5;
  }
}
&Movement
{
  public int airjump_num;
  public int airjump_height;
  public float yaccel;
  public float stand_friction;
  public float crouch_friction;
  new()
  {
    `reset();
  }
  public void reset()
  {
    `airjump_num = 0;
    `airjump_height = 35;
    `yaccel = 0.44;
    `stand_friction = 0.85;
    `crouch_friction = 0.82;
  }
}
&Const
{
  public &.Data d;
  public &.Size s;
  public &.Velocity v;
  public &.Movement m;
  public void reset()
  {
    `d.reset();
    `s.reset();
    `v.reset();
    `m.reset();
  }
}

const ^/char sndstart =
  "bool f=false,lw=false,lp=false;int g=-1,s=0,ch=-1,vo=`sysivar[.iVOLUME];"
  "float p=0.0,fr=1.0;^float x=`sysfvar[.fX...fX+1];";
const ^/char sndend = "`playSound(f,lw,lp,g,s,ch,vo,p,fr,x);";
public &StateBuilder
{
  public ^/char cmd;
  public ^/char cns;
  public %^/char st;
  public ^/char stcommon;
  public %int stnoList;
  public &.State state;
  public ^/char lasterror;
  public &.Const c;
  public int playerno = 0;
  public int stconcnt = 0;
  *.s.ptn_t pt1, pt2, pt3;
  new()
  {
    `pt1.compile(".v.set%c:IF;(%cp:%g,-1:%c,'0','9':.;;;)$`trMinus()");
    `pt2.compile(".v.setI(%cp:%g,-1:%c,'0','9':.-;;;)$.v.toInt()");
    `pt3.compile(".v.set%c:IF;(%cp:%g,-1:%c,'0','9':.-;;;)$.v.toFloat()");
  }
  public ^/char okikae(^/char code)
  {
    type s_t = $^/char(^/^/char, index=);
    *.s.ptn_t pt;
    ^/char rep(.s.ptn_t pt=, ~`s_t dlg, ^/char text)
    {
      %char buf;
      loop{
        index i = 0, j = 0;
        ^/^/char cap;
        continue;
      do:
        buf .= text[j..j+i];
        cap = pt.getCap();
        j += i;
        buf .= dlg(:cap, j=:);
      continue:
        i = pt.search(text[j..-1]);
      while i >= 0:
        if(#buf == 0) ret text;
        buf .= text[j..-1];
      }
      ret buf;
    }
    ^/char tmp = code;
    tmp = rep(
      `pt1=,
      [s_t(c, j=){
        %char buf .=
          (tmp[j+6] == 'I' ? ".v.setI(" : ".v.setF(") .= '-' .= c[0] .= ')';
        j += 20 + #c[0];
        ret buf;
      }], tmp);
    tmp = rep(
      `pt2=,
      [s_t(c, j=){
        %char buf .= c[0];
        j += 20 + #c[0];
        ret buf;
      }], tmp);
    tmp = rep(
      `pt3=,
      [s_t(c, j=){
        %char buf;
        buf .= c[0];
        if(tmp[j+6] == 'I') buf .= ".0";
        j += 22 + #c[0];
        ret buf;
      }], tmp);
    ret  tmp;
  }
  bool existState(int no)
  {
    loop{index i = 0; while; do:
      if(`stnoList[i] == no) ret true;
      i++;
    while i< #`stnoList:
    }
    ret false;
  }
  ^/char tokenizer(^/char text=)
  {
    index i = 0;
    loop{while; do:
      if(!.s.cMatch!char?(.s.blank, text[i])) break;
      i++;
    while i < #text:
    }
    text = text[i..-1];
    if(#text == 0) ret "";
    switch(text<>){
    case '=':
      text = text[1..-1];
      ret "=";
    case ':':
      branch{
      cond #text >= 2 && text[1] == '=':
        text = text[2..-1];
        ret ":=";
      else:
        text = text[1..-1];
        ret ":";
      }
    case '!':
      branch{
      cond #text >= 2 && text[1] == '=':
        text = text[2..-1];
        ret "!=";
      else:
        text = text[1..-1];
        ret "!";
      }
    case '>':
      branch{
      cond #text >= 2 && text[1] == '=':
        text = text[2..-1];
        ret ">=";
      else:
        text = text[1..-1];
        ret ">";
      }
    case '<':
      branch{
      cond #text >= 2 && text[1] == '=':
        text = text[2..-1];
        ret "<=";
      else:
        text = text[1..-1];
        ret "<";
      }
    case '~':
      text = text[1..-1];
      ret "~";
    case '&':
      branch{
      cond #text >= 2 && text[1] == '&':
        text = text[2..-1];
        ret "&&";
      else:
        text = text[1..-1];
        ret "&";
      }
    case '^':
      branch{
      cond #text >= 2 && text[1] == '^':
        text = text[2..-1];
        ret "^^";
      else:
        text = text[1..-1];
        ret "^";
      }
    case '|':
      branch{
      cond #text >= 2 && text[1] == '|':
        text = text[2..-1];
        ret "||";
      else:
        text = text[1..-1];
        ret "|";
      }
    case '+':
      text = text[1..-1];
      ret "+";
    case '-':
      text = text[1..-1];
      ret "-";
    case '*':
      branch{
      cond #text >= 2 && text[1] == '*':
        text = text[2..-1];
        ret "**";
      else:
        text = text[1..-1];
        ret "*";
      }
    case '/':
      text = text[1..-1];
      ret "/";
    case '%':
      text = text[1..-1];
      ret "%";
    case ',':
      text = text[1..-1];
      ret ",";
    case '(':
      text = text[1..-1];
      ret "(";
    case ')':
      text = text[1..-1];
      ret ")";
    case '[':
      text = text[1..-1];
      ret "[";
    case ']':
      text = text[1..-1];
      ret "]";
    case '"':
      text = text[1..-1];
      ret \";
    }
    i = 1;
    loop{while; do:
      if(.s.cMatch!char?(.kuuhaktokigou, text[i])) break;
      i++;
    while i < #text:
    }
    ^/char tok = .s.toLower(text[0..i]);
    text = text[i..-1];
    ret tok;
  }
  ^/char fToS(float f)
  {
    ^char tmp;
    .mes.DoubleToStr(:tmp=, f:);
    if(.s.find(".", tmp) >= 0) ret tmp;
    %char buf;
    ret buf .= tmp .= ".0";
  }
  ^/char number(^/char token)
  {
    double d;
    if(!.s.sToNumber!d.self?(d=, token)) ret "";
    %char rtn;
    branch{
    cond .s.find(".", token) >= 0:
      rtn .= ".v.setF(" .= `fToS(d) .= ")";
    cond d < (double)-.consts.int_t::MAX:
      rtn .= ".v.setI(" .= .s.iToS(-.consts.int_t::MAX) .= ")";
    cond d > (double).consts.int_t::MAX:
      rtn .= ".v.setI(" .= .s.iToS(.consts.int_t::MAX) .= ")";
    else:
      rtn .= ".v.setI(" .= .s.iToS((int)d) .= ")";
    }
    ret rtn;
  }
  bool attr(int flg=, ^/char text)
  {
    flg = 0;
    ^^/char hit = .s.split(",", text);
    loop{index i = 0; while; do:
      switch(hit[0][i]){
      case 'S', 's':
        flg |= (int).chr.StTy::S;
      case 'C', 'c':
        flg |= (int).chr.StTy::C;
      case 'A', 'a':
        flg |= (int).chr.StTy::A;
      }
      i++;
    while i < #hit[0]:
    }
    loop{index i = 1; while; do:
      branch{
        ^char tmp = .s.toLower()<, .s.trim(hit[i]);
        tmp = tmp[0..2];
      cond .s.equ(tmp, "na"): flg |= (int).chr.AtTy::NA;
      cond .s.equ(tmp, "nt"): flg |= (int).chr.AtTy::NT;
      cond .s.equ(tmp, "np"): flg |= (int).chr.AtTy::NP;
      cond .s.equ(tmp, "sa"): flg |= (int).chr.AtTy::SA;
      cond .s.equ(tmp, "st"): flg |= (int).chr.AtTy::ST;
      cond .s.equ(tmp, "sp"): flg |= (int).chr.AtTy::SP;
      cond .s.equ(tmp, "ha"): flg |= (int).chr.AtTy::HA;
      cond .s.equ(tmp, "ht"): flg |= (int).chr.AtTy::HT;
      cond .s.equ(tmp, "hp"): flg |= (int).chr.AtTy::HP;
      cond .s.equ(tmp, "n"):
        flg |= (int).chr.AtTy::NA;
        flg |= (int).chr.AtTy::NT;
        flg |= (int).chr.AtTy::NP;
      cond .s.equ(tmp, "s"):
        flg |= (int).chr.AtTy::SA;
        flg |= (int).chr.AtTy::ST;
        flg |= (int).chr.AtTy::SP;
      cond .s.equ(tmp, "h"):
        flg |= (int).chr.AtTy::HA;
        flg |= (int).chr.AtTy::HT;
        flg |= (int).chr.AtTy::HP;
      cond .s.equ(tmp, "aa"):
        flg |= (int).chr.AtTy::NA;
        flg |= (int).chr.AtTy::SA;
        flg |= (int).chr.AtTy::HA;
      cond .s.equ(tmp, "at"):
        flg |= (int).chr.AtTy::NT;
        flg |= (int).chr.AtTy::ST;
        flg |= (int).chr.AtTy::HT;
      cond .s.equ(tmp, "ap"):
        flg |= (int).chr.AtTy::NP;
        flg |= (int).chr.AtTy::SP;
        flg |= (int).chr.AtTy::HP;
      cond .s.equ(tmp, "a"):
        flg |= (int).chr.AtTy::NA;
        flg |= (int).chr.AtTy::SA;
        flg |= (int).chr.AtTy::HA;
        flg |= (int).chr.AtTy::NT;
        flg |= (int).chr.AtTy::ST;
        flg |= (int).chr.AtTy::HT;
        flg |= (int).chr.AtTy::NP;
        flg |= (int).chr.AtTy::SP;
        flg |= (int).chr.AtTy::HP;
      else:
        if(!.cfg.IgnoreMostErrors){
          %char buf;
          `lasterror = (buf .= hit[i] .= "が無効な値です");
          ret false;
        }
      }
      i++;
    while i < #hit:
    }
    ret true;
  }
  bool expRedirectable(^/char obj, ^/char name, %char out=, ^/char in=)
  {:<-
    bool var(^/char obj, ^/char v, %char out=, ^/char in=)
    {
      %char buf;
      if(!`expValue(buf=, in=)) ret false;
      ^/char oldin = in;
      branch{
      cond .s.equ(`tokenizer(in=), ":="):
        out .= obj .= "trSet" .= v .= '(' .= buf .= "$.v,";
        if(!`expEqu(out=, in=)) ret false;
        out .= "$.v)";
      else:
        in = oldin;
        out .= buf .= '$' .= obj .= "tr" .= v .= "()";
      }
      ret true;
    }
    int eqneq(%char out=, ^/char in=, ~$int() proc)
    {
      branch{
        ^/char oldin = in;
        ^/char token = `tokenizer(in=);
        bool not = .s.equ("!", token), kakko = false;
        if(not) token = `tokenizer(in=);
      cond .s.equ("=", token):
      cond .s.equ("(", token):
        kakko = true;
      cond .s.equ("!=", token):
        not!!;
      else:
        if(!.cfg.IgnoreMostErrors){
          `lasterror = "=か!=がありません";
          ret -1;
        }
        in = oldin;
        ret 0;
      comm:
        {
          int re = proc(::);
          if(re < 0) ret re;
          if(kakko && !.s.equ(")", `tokenizer(in=))){
            `lasterror = ")がありません";
            ret -1;
          }
          if(re == 0) ret re;
        }
        if(not) out .= "$`trBoolNot()";
      }
      ret 1;
    }
    ^/char num = `number(name);
    out .= num;
    if(#num == 0) branch{
      ^/char token = name;
    cond .s.equ("(", token) || .s.equ("[", token):
      if(!`expBoolOr(out=, in=)) ret false;
      loop{continue; do:
        if(.cfg.IgnoreMostErrors && .s.equ(",", token)){
          *out.self o;
          if(!`expBoolOr(o=, in=)) ret false;
          break, continue;
        }
        `lasterror = "括弧が閉じていません";
        ret false;
      continue:
        token = `tokenizer(in=);
      while !.s.equ(")", token) && !.s.equ("]", token):
      }
    cond .s.equ("+", token):
      if(!`expPostNot(out=, in=)) ret false;
    cond .s.equ("-", token):
      if(!`expPostNot(out=, in=)) ret false;
      out .= "$`trMinus()";
    cond .s.equ("~", token):
      if(!`expPostNot(out=, in=)) ret false;
      out .= "$`trNot()";
    cond .s.equ("!", token):
      if(!`expPostNot(out=, in=)) ret false;
      out .= "$`trBoolNot()";
    cond .s.equ("abs", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trAbs()";
    cond .s.equ("floor", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trFloor()";
    cond .s.equ("ceil", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trCeil()";
    cond .s.equ("pi", token):
      out .= ".v.setF(.m.PI)";
    cond .s.equ("e", token):
      out .= ".v.setF(.m.E)";
    cond .s.equ("sin", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trSin()";
    cond .s.equ("cos", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trCos()";
    cond .s.equ("tan", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trTan()";
    cond .s.equ("asin", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trAsin()";
    cond .s.equ("acos", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trAcos()";
    cond .s.equ("atan", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trAtan()";
    cond .s.equ("ln", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trLn()";
    cond .s.equ("log", token):
      if(!.s.equ("(", `tokenizer(in=))){
        %char buf;
        `lasterror = (buf .= token .= "の次に(がありません");
        ret false;
      }
      out .= "`trLog(";
      if(!`expBoolOr(out=, in=)) ret false;
      out .= "$.v,";
      if(!.s.equ(",", `tokenizer(in=))){
        %char buf;
        `lasterror = (buf .= token .= "は引数が2個必要です");
        ret false;
      }
      if(!`expBoolOr(out=, in=)) ret false;
      out .= "$.v)";
      if(!.s.equ(")", `tokenizer(in=))){
        `lasterror = ")がありません";
        ret false;
      }
    cond .s.equ("exp", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trExp()";
    cond .s.equ("ifelse", token):
      out .= "`trIfelse(";
      if(!.s.equ("(", `tokenizer(in=))){
        %char buf;
        `lasterror = (buf .= token .= "の次に(がありません");
        ret false;
      }
      if(!`expBoolOr(out=, in=)) ret false;
      out .= "$.v,";
      if(!.s.equ(",", `tokenizer(in=))){
        %char buf;
        `lasterror = (buf .= token .= "は引数が3個必要です");
        ret false;
      }
      if(!`expBoolOr(out=, in=)) ret false;
      out .= "$.v,";
      if(!.s.equ(",", `tokenizer(in=))){
        %char buf;
        `lasterror = (buf .= token .= "は引数が3個必要です");
        ret false;
      }
      if(!`expBoolOr(out=, in=)) ret false;
      out .= "$.v)";
      if(!.s.equ(")", `tokenizer(in=))){
        `lasterror = ")がありません";
        ret false;
      }
    cond .s.equ("random", token):
      out .= ".v.setI(.m.rand(0,999))";
    cond .s.equ("gametime", token):
      out .= ".v.setI(.com.gametime)";
    cond .s.equ("matchover", token):
      out .= "`trMatchOver()";
    cond .s.equ("matchno", token):
      out .= "`trMatchNo()";
    cond .s.equ("roundno", token):
      out .= "`trRoundNo()";
    cond .s.equ("tickspersecond", token):
      out .= ".v.setI(.cfg.GameSpeed)";
    cond .s.equ("playeridexist", token):
      if(!`expValue(out=, in=)) ret false;
      out .= "$`trPlayerIDExist()";
    cond .s.equ("anim", token):
      out .= obj .= "trAnim()";
    cond .s.equ("animtime", token):
      out .= obj .= "trAnimTime()";
    cond .s.equ("time", token) || .s.equ("statetime", token):
      out .= ".v.setI(" .= obj .= "stVal.time)";
    cond .s.equ("animelem", token):
      {
        ^/char oldin0, oldin;
        %char buf;
        bool eq = false;
        oldin0 = in;
        branch{
          token = `tokenizer(in=);
        cond #token > 0 && token[-1] == '=':
          if(!`expAdsb(buf=, in=)) ret false;
          eq = true;
        cond .s.equ("(", token):
          in = oldin0;
          if(!`expValue(buf=, in=)) ret false;
          eq = true;
        else:
          in = oldin0;
          buf .= ".v.setI(1)";
        }
        buf .= '$' .= obj .= "trAnimElemTime()$(.v.isSF()?.v.setSF():";
        branch{
          oldin = in;
          token = `tokenizer(in=);
        cond
          .s.equ(",", token) || (
            eq && (
              .s.equ("=", token) || .s.equ("!=", token)
              || .s.equ("<", token) || .s.equ(">", token)
              || .s.equ("<=", token) || .s.equ(">=", token)))
          :
          if(.s.equ(",", token)){
            oldin = in;
            token = `tokenizer(in=);
          }
          branch{
          cond .s.equ("=", token):
            if(!`expEquSub(buf=, in=, false)) ret false;
            break;
          cond .s.equ("!=", token):
            if(!`expEquSub(buf=, in=, true)) ret false;
            break;
          cond .s.equ("<", token):
            buf .= "`trLs(.v,";
          cond .s.equ(">", token):
            buf .= "`trGr(.v,";
          cond .s.equ("<=", token):
            buf .= "`trLsE(.v,";
          cond .s.equ(">=", token):
            buf .= "`trGrE(.v,";
          else:
            in = oldin;
            if(!`expEquSub(buf=, in=, false)) ret false;
            break;
          comm:
            if(!`expAdsb(buf=, in=)) ret false;
            buf .= "$.v)";
          }
          out .= buf .= ')';
        else:
          in = oldin;
          out .= buf .= "`trEqu(.v,.v.setI(0)$.v))";
        }
      }
    cond .s.equ("animelemtime", token):
      if(!`expValue(out=, in=)) ret false;
      out .= '$' .= obj .= "trAnimElemTime()";
    cond .s.equ("animelemno", token):
      if(!`expValue(out=, in=)) ret false;
      out .= '$' .= obj .= "trAnimElemNo()";
    cond .s.equ("timemod", token):
      {
        ^/char oldin = in;
        token = `tokenizer(in=);
        branch{
          %char buf;
          bool not;
        cond .s.equ("<", token):
          out .= "`trLs(";
        cond .s.equ(">", token):
          out .= "`trGr(";
        cond .s.equ("<=", token):
          out .= "`trLsE(";
        cond .s.equ(">=", token):
          out .= "`trGrE(";
        else:
          branch{
          cond .s.equ("!=", token):
            not = true;
          else:
            if(!.s.equ("=", token)) in = oldin;
            not = false;
          }
          buf .= "`trMod(.v.setI(" .= obj .= "stVal.time)$.v,";
          if(!`expBoolOr(buf=, in=)) ret false;
          buf .= "$.v)";
          if(!.s.equ(",", `tokenizer(in=))){
            %char buf;
            `lasterror = (buf .= token .= ",がありません");
            ret false;
          }
          oldin = in;
          if(!.s.equ("=", `tokenizer(in=))) in = oldin;
          buf .= '$';
          if(!`expEquSub(buf=, in=, not)) ret false;
          out .= buf;
          break;
        comm:
          out .= "`trMod(.v.setI(" .= obj .= "stVal.time)$.v,";
          if(!`expBoolOr(out=, in=)) ret false;
          out .= "$.v)$.v,";
          if(!.s.equ(",", `tokenizer(in=))){
            %char buf;
            `lasterror = (buf .= token .= ",がありません");
            ret false;
          }
          oldin = in;
          if(!.s.equ("=", `tokenizer(in=))) in = oldin;
          if(!`expBoolOr(out=, in=)) ret false;
          out .= "$.v)";
        }
      }
    cond .s.equ("alive", token):
      out .= ".v.setB(" .= obj .= "sysivar[.iLIFE]>0)";
    cond .s.equ("win", token):
      out .=  obj .= "trWin()";
    cond .s.equ("winko", token):
      out .=  obj .= "trWinKO()";
    cond .s.equ("wintime", token):
      out .=  obj .= "trWinTime()";
    cond .s.equ("winperfect", token):
      out .=  obj .= "trWinPerfect()";
    cond .s.equ("lose", token):
      out .=  obj .= "trLose()";
    cond .s.equ("loseko", token):
      out .= obj .= "trLoseKO()";
    cond .s.equ("losetime", token):
      out .= obj .= "trLoseTime()";
    cond .s.equ("drawgame", token):
      out .= "`trDrawGame()";
    cond .s.equ("life", token):
      out .= ".v.setI(" .= obj .= "sysivar[.iLIFE])";
    cond .s.equ("p2life", token):
      out .= obj .= "trP2Life()";
    cond .s.equ("lifemax", token):
      out .= ".v.setI(" .= obj .= "sysivar[.iLIFEMAX])";
    cond .s.equ("power", token):
      out .= ".v.setI(" .= obj .= "getSharePower())";
    cond .s.equ("powermax", token):
      out .= ".v.setI(" .= obj .= "sysivar[.iPOWERMAX])";
    cond .s.equ("pos", token):
      token = `tokenizer(in=);
      branch{
      cond .s.equ("x", token):
        out .= ".v.setF(" .= obj .= "sysfvar[.fX]-.com.camerax)";
      cond .s.equ("y", token):
        out .= ".v.setF(" .= obj .= "sysfvar[.fY])";
      cond .s.equ("z", token):///////////////
        out .= ".v.setF(0.0)";
      else:
        break, else;
      }
    cond .s.equ("screenpos", token):
      token = `tokenizer(in=);
      branch{
      cond .s.equ("x", token):
        out .= ".v.setF((" .= obj .= "sysfvar[.fX]-.com.screenx)*.com.scale)";
      cond .s.equ("y", token):
        out .= ".v.setF((" .= obj .= "sysfvar[.fY]-.com.screeny)*.com.scale)";
      else:
        break, else;
      }
    cond .s.equ("id", token):
      out .= ".v.setI(" .= obj .= "trId())";
    cond .s.equ("facing", token):
      out .= ".v.setI(" .= obj .= "facing)";
    cond .s.equ("hitcount", token):
      out .= ".v.setI(" .= obj .= "sysivar[.iHITCOUNT])";
    cond .s.equ("uniqhitcount", token):
      out .= ".v.setI(" .= obj .= "sysivar[.iUNIQHITCOUNT])";
    cond
      .s.equ("p2dist", token) || .s.equ("p2bodydist", token)
      || .s.equ("rootdist", token) || .s.equ("parentdist", token)
      :
      branch{
        bool r = token[0] == 'r';
        bool p = token[1] == 'a';
        bool b = token[2] == 'b';
        ^/char oldin = in;
        token = `tokenizer(in=);
      cond .s.equ("y", token):
        branch{
        cond r:
          out .= obj .= "trRootDistY()";
        cond p:
          out .= obj .= "trParentDistY()";
        cond b:
          out .= obj .= "trP2BodyDistY()";
        else:
          out .= obj .= "trP2DistY()";
        }
      else:
        if(!.s.equ("x", token)) in = oldin;
        branch{
        cond r:
          out .= obj .= "trRootDistX()";
        cond p:
          out .= obj .= "trParentDistX()";
        cond b:
          out .= obj .= "trP2BodyDistX()";
        else:
          out .= obj .= "trP2DistX()";
        }
      }
    cond .s.equ("vel", token):
      token = `tokenizer(in=);
      branch{
      cond .s.equ("x", token):
        out .= ".v.setI(.fVX)$" .= obj .= "trSysFVar()";
      cond .s.equ("y", token):
        out .= ".v.setI(.fVY)$" .= obj .= "trSysFVar()";
      else:
        break, else;
      }
    cond .s.equ("hitvel", token):
      token = `tokenizer(in=);
      branch{
      cond .s.equ("x", token):
        out .= obj .= "trHitVelX()";
      cond .s.equ("y", token):
        out .= obj .= "trHitVelY()";
      else:
        break, else;
      }
    cond .s.equ("command", token):
      {
        int re = eqneq(out=, in=)<, [int(){
          if(!.s.equ(\", `tokenizer(in=))){
            `lasterror = "コマンド名が"\""で囲まれていません";
            ret -1;
          }
          {
            index fnd = .s.find(\", in);
            token = in[0..fnd];
            in = in[fnd+1..-1];
          }
          out .= obj .= "trCommand("\" .= token .= \"")";
          ret 1;
        }];
        if(re < 0) ret false;
        if(re == 0) break, else;
      }
    cond
      .s.equ("name", token) || .s.equ("p1name", token)
      || .s.equ("p2name", token)
      || .s.equ("p3name", token) || .s.equ("p4name", token)
      || .s.equ("authorname", token)
      :
      {
        bool a = token[0] =='a';
        bool p = token[0] =='p';
        int pn = token[0] =='n' ? 1 : (int)(token[1]-'0');
        int re = eqneq(out=, in=)<, [int(){
          if(!.s.equ(\", `tokenizer(in=))){
            `lasterror = "名前が"\""で囲まれていません";
            ret -1;
          }
          index fnd = .s.find(\", in);
          token = in[0..fnd];
          in = in[fnd+1..-1];
          branch{
          cond a:
            out .=
              ".v.setB(.s.equ(.s.toLower(" .= obj .= "author)"
              .= ",.s.toLower("\" .= token .= \"")))";
          else:
            out .= obj .= "trPName(" .= .s.iToS(pn) .= ","\" .= token .= \"")";
          }
          ret 1;
        }];
        if(re < 0) ret false;
        if(re == 0) break, else;
      }
    cond .s.equ("const", token):
      if(!.s.equ("(", `tokenizer(in=))){
        %char buf;
        `lasterror = (buf .= token .= "の次に(がありません");
        ret false;
      }
      token = `tokenizer(in=);
      branch{
      cond .s.equ("velocity.walk.fwd.x", token):
        out .= ".v.setI(.fWALK_FWD)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.walk.back.x", token):
        out .= ".v.setI(.fWALK_BACK)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.run.fwd.x", token):
        out .= ".v.setI(.fRUN_FWDX)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.run.fwd.y", token):
        out .= ".v.setI(.fRUN_FWDY)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.run.back.x", token):
        out .= ".v.setI(.fRUN_BACKX)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.run.back.y", token):
        out .= ".v.setI(.fRUN_BACKY)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.jump.y", token):
        out .= ".v.setI(.fJUMP_NEUY)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.jump.neu.x", token):
        out .= ".v.setI(.fJUMP_NEUX)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.jump.fwd.x", token):
        out .= ".v.setI(.fJUMP_FWD)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.jump.back.x", token):
        out .= ".v.setI(.fJUMP_BACK)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.airjump.y", token):
        out .= ".v.setI(.fAIRJUMP_NEUY)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.airjump.neu.x", token):
        out .= ".v.setI(.fAIRJUMP_NEUX)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.airjump.fwd.x", token):
        out .= ".v.setI(.fAIRJUMP_FWD)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.airjump.back.x", token):
        out .= ".v.setI(.fAIRJUMP_BACK)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.runjump.fwd.x", token):
        out .= ".v.setI(.fRUNJUMP_FWDX)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.runjump.y", token):
        out .= ".v.setI(.fRUNJUMP_FWDY)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.runjump.back.x", token):
        out .= ".v.setI(.fRUNJUMP_BACKX)$" .= obj .= "trSysFVar()";
      cond .s.equ("velocity.runjump.back.y", token):
        out .= ".v.setI(.fRUNJUMP_BACKY)$" .= obj .= "trSysFVar()";
      cond .s.equ("movement.yaccel", token):
        out .= ".v.setI(.fYACCEL)$" .= obj .= "trSysFVar()";
      cond .s.equ("movement.airjump.num", token):
        out .= ".v.setI(.iAIRJUMP_NUM)$" .= obj .= "trSysIVar()";
      cond .s.equ("movement.airjump.height", token):
        out .= ".v.setI(.iAIRJUMP_HEIGHT)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.height", token):
        out .= ".v.setI(.iHEIGHT)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.air.front", token):
        out .= ".v.setI(.iAIR_FRONT)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.ground.front", token):
        out .= ".v.setI(.iGROUND_FRONT)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.ground.back", token):
        out .= ".v.setI(.iGROUND_BACK)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.head.pos.x", token):
        out .= ".v.setI(.iHEAD_POSX)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.head.pos.y", token):
        out .= ".v.setI(.iHEAD_POSY)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.air.back", token):
        out .= ".v.setI(.iAIR_BACK)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.xscale", token):
        out .= ".v.setI(.fXSCALE)$" .= obj .= "trSysFVar()";
      cond .s.equ("size.yscale", token):
        out .= ".v.setI(.fYSCALE)$" .= obj .= "trSysFVar()";
      cond .s.equ("data.life", token):
        out .= ".v.setI(.iLIFEMAX)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.proj.doscale", token):
        out .= ".v.setI(.iPROJ_DOSCALE)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.shadowoffset", token):
        out .= ".v.setI(.iSHADOWOFFSET)$" .= obj .= "trSysIVar()";
      cond .s.equ("data.power", token):
        out .= ".v.setI(.iPOWERMAX)$" .= obj .= "trSysIVar()";
      cond .s.equ("data.attack", token):
        out .= ".v.setI(.iATTACK)$" .= obj .= "trSysIVar()";
      cond .s.equ("data.defence", token):
        out .= ".v.setI(.iDEFENCE)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.mid.pos.x", token):
        out .= ".v.setI(.iMID_POSX)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.mid.pos.y", token):
        out .= ".v.setI(.iMID_POSY)$" .= obj .= "trSysIVar()";
      cond .s.equ("data.fall.defence_mul", token):
        out .= ".v.setI(.fFALL_DEFENCE_MUL)$" .= obj .= "trSysFVar()";
      cond .s.equ("data.liedown.time", token):
        out .= ".v.setI(.iLIEDOWN_TIME)$" .= obj .= "trSysIVar()";
      cond .s.equ("data.airjuggle", token):
        out .= ".v.setI(.iAIRJUGGLE)$" .= obj .= "trSysIVar()";
      cond .s.equ("data.sparkno", token):
        out .= ".v.setI(.iSPARKNO)$" .= obj .= "trSysIVar()";
      cond .s.equ("data.guard.sparkno", token):
        out .= ".v.setI(.iGUARD_SPARKNO)$" .= obj .= "trSysIVar()";
      cond .s.equ("data.ko.echo", token):
        out .= ".v.setI(.iKO_ECHO)$" .= obj .= "trSysIVar()";
      cond .s.equ("data.intpersistindex", token):
        out .= ".v.setI(.iINTPERSISTINDEX)$" .= obj .= "trSysIVar()";
      cond .s.equ("data.FloatPersistIndex", token):
        out .= ".v.setI(.iFLOATPERSISTINDEX)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.attack.dist", token):
        out .= ".v.setI(.iATTACK_DIST)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.proj.attack.dist", token):
        out .= ".v.setI(.iPROJ_ATTACK_DIST)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.draw.offset.x", token):
        out .= ".v.setI(.iDRAW_OFFSETX)$" .= obj .= "trSysIVar()";
      cond .s.equ("size.draw.offset.y", token):
        out .= ".v.setI(.iDRAW_OFFSETY)$" .= obj .= "trSysIVar()";
      cond .s.equ("movement.stand.friction", token):
        out .= ".v.setI(.fSTAND_FRICTION)$" .= obj .= "trSysFVar()";
      cond .s.equ("movement.crouch.friction", token):
        out .= ".v.setI(.fCROUCH_FRICTION)$" .= obj .= "trSysFVar()";
      else:
        branch{
        cond .cfg.IgnoreMostErrors:
          out .= ".v.setSF()";
        else:
          break, break, else;
        }
      }
      if(!.s.equ(")", `tokenizer(in=))){
        `lasterror = ")がありません";
        ret false;
      }
    cond .s.equ("sysvar", token):
      if(!var(obj, "SysIVar", out=, in=)) ret false;
    cond .s.equ("sysfvar", token):
      if(!var(obj, "SysFVar", out=, in=)) ret false;
    cond .s.equ("var", token):
      if(!var(obj, "IVar", out=, in=)) ret false;
    cond .s.equ("fvar", token):
      if(!var(obj, "FVar", out=, in=)) ret false;
    cond .s.equ("animexist", token):
      if(!`expValue(out=, in=)) ret false;
      out .= '$' .= obj .= "trAnimExist(" .= .s.iToS(`playerno) .= ')';
    cond .s.equ("selfanimexist", token):
      if(!`expValue(out=, in=)) ret false;
      out .= '$' .= obj .= "trSelfAnimExist()";
    cond .s.equ("stateno", token):
      out .= ".v.setI(" .= obj .= "stVal.no)";
    cond .s.equ("p2stateno", token):
      out .= obj .= "trP2StateNo()";
    cond .s.equ("prevstateno", token):
      out .= ".v.setI(" .= obj .= "stVal.prevno)";
    cond .s.equ("statetype", token) || .s.equ("p2statetype", token):
      {
        bool p2 = token[0] == 'p';
        ^/char sty;
        int re = eqneq(out=, in=)<, [int(){
          token = `tokenizer(in=);
          switch(token[0]){
          case 's':
            sty = ".StTy::S";
          case 'c':
            sty = ".StTy::C";
          case 'a':
            sty = ".StTy::A";
          case 'l':
            sty = ".StTy::L";
          default:
            if(.cfg.IgnoreMostErrors) ret 0;
            {
              %char buf;
              `lasterror = (buf .= token .= "が無効な値です");
              ret -1;
            }
          }
          out .= obj .= (p2 ? "trP2StateType(" : "trStateType(") .= sty .= ")";
          ret 1;
        }];
        if(re < 0) ret false;
        if(re == 0) break, else;
      }
    cond .s.equ("movetype", token) || .s.equ("p2movetype", token):
      {
        bool p2 = token[0] == 'p';
        ^/char tmp;
        int re = eqneq(out=, in=)<, [int(){
          token = `tokenizer(in=);
          switch(token[0]){
          case 'i':
            tmp = ".MovTy::I";
          case 'a':
            tmp = ".MovTy::A";
          case 'h':
            tmp = ".MovTy::H";
          default:
            if(.cfg.IgnoreMostErrors) ret 0;
            {
              %char buf;
              `lasterror = (buf .= token .= "が無効な値です");
              ret -1;
            }
          }
          out .= obj .= (p2 ? "trP2MoveType(" : "trMoveType(") .= tmp .= ")";
          ret 1;
        }];
        if(re < 0) ret false;
        if(re == 0) break, else;
      }
    cond .s.equ("physics", token):
      {
        ^/char pty;
        int re = eqneq(out=, in=)<, [int(){
          token = `tokenizer(in=);
          switch(token[0]){
          case 's':
            pty = ".StTy::S";
          case 'c':
            pty = ".StTy::C";
          case 'a':
            pty = ".StTy::A";
          case 'n':
            pty = ".StTy::N";
          default:
            if(.cfg.IgnoreMostErrors) ret 0;
            {
              %char buf;
              `lasterror = (buf .= token .= "が無効な値です");
              ret -1;
            }
          }
          out .=
            ".v.setB(" .= obj .= "stVal.phy==" .= pty .= ")";
          ret 1;
        }];
        if(re < 0) ret false;
        if(re == 0) break, else;
      }
    cond .s.equ("teammode", token):
      {
        ^/char pty;
        int re = eqneq(out=, in=)<, [int(){
          token = `tokenizer(in=);
          branch{
          cond .s.equ("single", token):
            pty = ".com.TeamMode::Single";
          cond .s.equ("simul", token):
            pty = ".com.TeamMode::Simul";
          cond .s.equ("turns", token):
            pty = ".com.TeamMode::Turns";
          else:
            if(.cfg.IgnoreMostErrors) ret 0;
            {
              %char buf;
              `lasterror = (buf .= token .= "が無効な値です");
              ret -1;
            }
          }
          out .= obj .= "trTeamMode(" .= pty .= ")";
          ret 1;
        }];
        if(re < 0) ret false;
        if(re == 0) break, else;
      }
    cond .s.equ("gethitvar", token):
      if(!.s.equ("(", `tokenizer(in=))){
        %char buf;
        `lasterror = (buf .= token .= "の次に(がありません");
        ret false;
      }
      token = `tokenizer(in=);
      branch{
      cond .s.equ("xveladd", token):
        out .= ".v.setF(0.0)";////////////////////////////////////////
      cond .s.equ("yveladd", token):
        out .= ".v.setF(0.0)";////////////////////////////////////////
      cond .s.equ("type", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.typ)";
      cond .s.equ("animtype", token):
        out .=
          ".v.setI(`stVal.hb.fallf!=0?(int)"
          .= obj .= "stVal.hb.fall.animtype:"
          .= obj .= "stVal.hb.animtype)";
      cond .s.equ("airtype", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.airtype)";
      cond .s.equ("groundtype", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.groundtype)";
      cond .s.equ("damage", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.damage)";
      cond .s.equ("hitcount", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.hitcount)";
      cond .s.equ("fallcount", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.fallcount)";
      cond .s.equ("hitshaketime", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.hitshaketime)";
      cond .s.equ("hittime", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.hittime)";
      cond .s.equ("slidetime", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.slidetime)";
      cond .s.equ("ctrltime", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.ctrltime)";
      cond .s.equ("recovertime", token):
        out .= ".v.setI(" .= obj .= "sysivar[.iRECOVERTIME])";
      cond .s.equ("xoff", token):
        out .= ".v.setI(0)";//////////////////////////////////////////
      cond .s.equ("yoff", token):
        out .= ".v.setI(0)";//////////////////////////////////////////
      cond .s.equ("zoff", token):
        out .= ".v.setI(0)";//////////////////////////////////////////
      cond .s.equ("xvel", token):
        out .= obj .= "trHitXvel(`facing)";
      cond .s.equ("yvel", token):
        out .= ".v.setF(" .= obj .= "stVal.hb.yvel)";
      cond .s.equ("yaccel", token):
        out .= ".v.setF(" .= obj .= "stVal.hb.getYaccel())";
      cond .s.equ("hitid", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.hitid)";
      cond .s.equ("chainid", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.chainid)";
      cond .s.equ("guarded", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.guarded)";
      cond .s.equ("fall", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.fallf)";
      cond .s.equ("fall.damage", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.fall.damage)";
      cond .s.equ("fall.xvel", token):
        out .= obj .= "trFallXvel(`facing)";
      cond .s.equ("fall.yvel", token):
        out .= ".v.setF(" .= obj .= "stVal.hb.fall.yvelocity)";
      cond .s.equ("fall.recover", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.fall.recover)";
      cond .s.equ("fall.recovertime", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.fall.recovertime)";
      cond .s.equ("fall.kill", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.fall.kill)";
      cond .s.equ("fall.envshake.time", token):
        out .= ".v.setI(" .= obj .= "stVal.hb.fall.envshake_time)";
      cond .s.equ("fall.envshake.freq", token):
        out .= ".v.setF(" .= obj .= "stVal.hb.fall.envshake_freq)";
      cond .s.equ("fall.envshake.ampl", token):
        out .= ".v.setF(" .= obj .= "stVal.hb.fall.envshake_ampl)";
      cond .s.equ("fall.envshake.phase", token):
        out .= ".v.setF(" .= obj .= "stVal.hb.fall.envshake_phase)";
      cond .s.equ("isbound", token):
        out .= ".v.setB(" .= obj .= "isBound())";
      else:
        break, else;
      }
      if(!.s.equ(")", `tokenizer(in=))){
        `lasterror = ")がありません";
        ret false;
      }
    cond .s.equ("hitdefattr", token):
      {
        int flg;
        index fi;
        int re = eqneq(out=, in=)<, [int(){
          fi = .s.cFind(")&|^", in);
          if(!`attr(flg=, in[0..fi])) ret -1;
          in = in[fi..-1];
          out .= obj .= "trHitDefAttr(" .= .s.iToS(flg) .= ")";
          ret 1;
        }];
        if(re < 0) ret false;
        if(re == 0) break, else;
      }
    cond
      .s.equ("numhelper", token) || .s.equ("numexplod", token)
      || .s.equ("numtarget", token) || .s.equ("numprojid", token)
      || .s.equ("ishelper", token)
      :
      {
        bool is = token[0] == 'i';
        bool h = token[3] == 'h';
        bool t = token[3] == 't';
        bool p = token[3] == 'p';
        ^/char oldin = in;
        branch{
        cond .s.equ("(", `tokenizer(in=)):
          in = oldin;
          if(!`expValue(out=, in=)) ret false;
          out .= '$' .= obj;
          branch{
          cond is:
            out .= "trIsHelper()";
          cond h:
            out .= "trNumHelper()";
          cond t:
            out .= "trNumTarget()";
          cond p:
            out .= "trNumProjID()";
          else:
            out .= "trNumExplod()";
          }
        else:
          in = oldin;
          branch{
          cond is:
            out .= ".v.setI(-1)$" .= obj .= "trIsHelper()";
          cond h:
            out .= ".v.setI(-1)$" .= obj .= "trNumHelper()";
          cond t:
            out .= ".v.setI(-1)$" .= obj .= "trNumTarget()";
          cond p:
            out .= ".v.setI(-1)$" .= obj .= "trNumProjID()";
          else:
            out .= ".v.setI(-1)$" .= obj .= "trNumExplod()";
          }
        }
      }
    cond .s.equ("isplayer", token):
      out .= obj .= "trIsPlayer()";
    cond .s.equ("active", token):
      out .= obj .= "trActive()";
    cond .s.equ("numenemy", token):
      out .= obj .= "trNumEnemy()";
    cond .s.equ("numpartner", token):
      out .= obj .= "trNumPartner()";
    cond .s.equ("projhittime", token):
      if(!`expValue(out=, in=)) ret false;
      out .= '$' .= obj .= "trProjTime(.ProjContact::Hit)";
    cond .s.equ("projguardedtime", token):
      if(!`expValue(out=, in=)) ret false;
      out .= '$' .= obj .= "trProjTime(.ProjContact::Guarded)";
    cond .s.equ("projcontacttime", token):
      if(!`expValue(out=, in=)) ret false;
      out .= '$' .= obj .= "trProjContactTime()";
    cond .s.equ("projcanceltime", token):
      if(!`expValue(out=, in=)) ret false;
      out .= '$' .= obj .= "trProjTime(.ProjContact::Cancel)";
    cond
      .s.equ("projhit", token[0..7]) || .s.equ("projguarded", token[0..11])
      || .s.equ("projcontact", token[0..11])
      :
      {
        %char buf, buf2;
        bool h = token[4] == 'h', g = token[4] == 'g';
        ^/char ptime =
          h ? "trProjTime(.ProjContact::Hit)"
          : (g ? "trProjTime(.ProjContact::Guarded)" : "trProjContactTime()");
        ^/char oldin = in;
        branch{
        cond (h && #token == 7) || (!h && #token == 11):
          branch{
          cond .s.equ("(", `tokenizer(in=)):
            in = oldin;
            if(!`expValue(buf=, in=)) ret false;
          else:
            in = oldin;
            buf .= ".v.setI(0)";
          }
        else:
          token = token[(h?7:11)..-1];
          if(!`expValue(buf=, token=)) ret false;
        }
        oldin = in;
        bool foo = false;
        branch{
        cond .s.equ("=", `tokenizer(in=)):
          if(!`expEqu(buf2=, in=)) ret false;
        else:
          in = oldin;
          buf2 .= ".v.setI(1)";
          foo = true;
        }
        oldin = in;
        %char buf3;
        buf3 .=
          ".v.setB(" .= buf2 .= "$!.v.isTrue()^";
        branch{
          bool not;
        cond foo || .s.equ(",", `tokenizer(in=)):
          oldin = in;
          token = `tokenizer(in=);
          branch{
          cond<l> .s.equ("<", token):
            buf3 .= "(`trLs(";
          cond<g> .s.equ(">", token):
            buf3 .= "`trGr(";
          cond<le> .s.equ("<=", token):
            buf3 .= "(`trLsE(";
          cond<ge> .s.equ(">=", token):
            buf3 .= "`trGrE(";
          else:
            branch{
            cond .s.equ("!=", token):
              not = true;
            else:
              if(!.s.equ("=", token)) in = oldin;
              not = false;
            }
            buf2.new(0);
            buf2 .=  buf .= '$' .= obj .= ptime .= '$';
            if(!`expEquSub(buf2=, in=, not)) ret false;
            buf3 .= buf2 .= "$.v.isTrue()";
            break, break;
          comm:
            buf3 .= buf .= '$' .= obj .= ptime  .= "$.v,";
            if(!`expAdsb(buf3=, in=)) ret false;
            buf3 .= "$.v)$.v.isTrue()";
          diff<l>: else;
          diff<le>: else;
          else:
            buf3 .=
              "&&`trGrE(" .= buf .= '$' .= obj .= ptime
              .= "$.v,.v.setI(0)$.v)$.v.isTrue())";
          }
        else:
          in = oldin;
          buf3 .=
            "`trEqu(" .= buf .= '$' .= obj .= ptime
            .= "$.v,.v.setI(1)$.v)$.v.isTrue()";
        }
        out .= buf3 .= ")";
      }
    cond .s.equ("numproj", token):
      out .= obj .= "trNumProj()";
    cond .s.equ("hitpausetime", token):
      out .= obj .= "trHitPauseTime()";
    cond .s.equ("ctrl", token):
      out .= ".v.setB(" .= obj .= "ctrl())";
    cond .s.equ("teamside", token):
      out .= ".v.setI((" .= obj .= "playerno&1)+1)";
    cond .s.equ("noautoturn", token):
      out .= ".v.setB(" .= obj .= "ls(.lsNOAUTOTURN))";
    cond .s.equ("nokosnd", token):
      out .= ".v.setB(.gs(.gsNOKOSND))";
    cond .s.equ("gethit", token):
      out .= ".v.setB(" .= obj .= "ls(.lsGETHIT))";
    cond .s.equ("frontedgedist", token):
      out .= obj .= "trFrontEdgeDist()";
    cond .s.equ("frontedgebodydist", token):
      out .= obj .= "trFrontEdgeBodyDist()";
    cond .s.equ("backedgedist", token):
      out .= obj .= "trBackEdgeDist()";
    cond .s.equ("backedgebodydist", token):
      out .= obj .= "trBackEdgeBodyDist()";
    cond .s.equ("palno", token):
      out .= obj .= "trPalNo()";
    cond .s.equ("inguarddist", token):
      out .= obj .= "trInGuardDist()";
    cond .s.equ("hitover", token):
      out .= obj .= "trHitOver()";
    cond .s.equ("hitshakeover", token):
      out .= obj .= "trHitShakeOver()";
    cond .s.equ("hitfall", token):
      out .= obj .= "trHitFall()";
    cond .s.equ("canrecover", token):
      out .= obj .= "trCanRecover()";
    cond .s.equ("roundsexisted", token):
      out .= obj .= "trRoundsExisted()";
    cond .s.equ("movecontact", token):
      out .= obj .= "trMoveContact()";
    cond .s.equ("movereversed", token):
      out .= obj .= "trMoveReversed()";
    cond .s.equ("movehit", token):
      out .= obj .= "trMoveHit()";
    cond .s.equ("moveguarded", token):
      out .= obj .= "trMoveGuarded()";
    cond .s.equ("roundstate", token):
      out .= "`trRoundState()";
    cond .s.equ("ishometeam", token):
      out .= ".v.setB((" .= .s.iToS(`playerno&1) .= ")==.com.home)";
    cond .s.equ("playerid", token):
      if(!`expValue(out=, in=)) ret false;
      out .= '$' .= obj .= "trPlayerID()$(#.c>0?[._t(_=){";
      if(!.s.equ(",")<, `tokenizer(in=)){
        `lasterror = ",がありません";
        ret false;
      }
      if(!`expRedirectable("_.", `tokenizer(in=), out=, in=)) ret false;
      out .= ";}](:.c<>=:):.v.setSF())";
    cond
      .s.equ("enemy", token) || .s.equ("enemynear", token)
      || .s.equ("helper", token) || .s.equ("target", token)
      :
      branch{
        bool h = token[0] == 'h';
        bool t = token[0] == 't';
        bool n = token[5] == 'n';
        token = `tokenizer(in=);
      cond .s.equ("(", token):
        if(!`expBoolOr(out=, in=)) ret false;
        branch{
        cond h:
          out .= '$' .= obj .= "trHelper()";
        cond t:
          out .= '$' .= obj .= "trTarget()";
        cond n:
          out .= '$' .= obj .= "trEnemyNear()";
        else:
          out .= '$' .= obj .= "trEnemy()";
        }
        if(!.s.equ(")", `tokenizer(in=))){
          `lasterror = ")がありません";
          ret false;
        }
        if(!.s.equ(",")<, `tokenizer(in=)) else;
      cond .s.equ(",", token):
        branch{
        cond h:
          out .= ".v.setI(-1)$" .= obj .= "trHelper()";
        cond t:
          out .= ".v.setI(-1)$" .= obj .= "trTarget()";
        cond n:
          out .= ".v.setI(0)$" .= obj .= "trEnemyNear()";
        else:
          out .= ".v.setI(0)$" .= obj .= "trEnemy()";
        }
      else:
        `lasterror = ",がありません";
        ret false;
      }
      out .= "$(#.c>0?[._t(_=){";
      if(!`expRedirectable("_.", `tokenizer(in=), out=, in=)) ret false;
      out .= ";}](:.c<>=:):.v.setSF())";
    cond .s.equ("root", token) || .s.equ("parent", token):
      out .= obj .= token[0] == 'r' ? "trRoot()$" : "trParent()$";
      if(!.s.equ(",")<, `tokenizer(in=)){
        `lasterror = ",がありません";
        ret false;
      }
      out .= "[._t(_=){";
      if(!`expRedirectable("_.", `tokenizer(in=), out=, in=)) ret false;
      out .= ";}](:.c<>=:)";
    cond .s.equ("partner", token):
      out .= obj .= "trPartner()$(#.c>0?[._t(_=){";
      if(!.s.equ(",")<, `tokenizer(in=)){
        `lasterror = ",がありません";
        ret false;
      }
      if(!`expRedirectable("_.", `tokenizer(in=), out=, in=)) ret false;
      out .= ";}](:.c<>=:):.v.setSF())";
    else:
      branch{
      cond .cfg.IgnoreMostErrors:
        branch{
        cond .s.equ("", token):
          out .= ".v.setI(0)";
        else:
          out .= ".v.setSF()";
        }
      else:
        {
          %char buf;
          `lasterror = (buf .= token .= "が不正です");
          ret false;
        }
      }
    }
    ret true;
  }
  bool expValue(%char out=, ^/char in=)
  {
    ret `expRedirectable("`", `tokenizer(in=), out=, in=);
  }
  bool expPostNot(%char out=, ^/char in=)
  {
    if(!`expValue(out=, in=)) ret false;
    loop{
      ^/char oldin = in;
      while;
    do:
      out .= "$`trBoolNot()";
      oldin = in;
    while .s.equ(`tokenizer(in=), "!"):
      in = oldin;
    }
    ret true;
  }
  bool expPow(%char out=, ^/char in=)
  {
    %char buf;
    if(!`expPostNot(buf=, in=)) ret false;
    loop{
      ^/char oldin;
      ^/char token;
    do:
      oldin = in;
      token = `tokenizer(in=);
      branch{
        %char buf2;
      cond .s.equ("**", token):
        buf2 .= "`trPow(";
      else:
        out .= buf;
        in = oldin;
        ret true;
      comm:
        buf2 .= buf .= "$.v,";
        buf = buf2;
        if(!`expPostNot(buf=, in=)) ret false;
        buf .= "$.v)";
      }
    while true:
    }
    ret true;
  }
  bool expMldv(%char out=, ^/char in=)
  {
    %char buf;
    if(!`expPow(buf=, in=)) ret false;
    loop{
      ^/char oldin;
      ^/char token;
    do:
      oldin = in;
      token = `tokenizer(in=);
      branch{
        %char buf2;
      cond .s.equ("*", token):
        buf2 .= "`trMul(";
      cond .s.equ("/", token):
        buf2 .= "`trDiv(";
      cond .s.equ("%", token):
        buf2 .= "`trMod(";
      else:
        out .= buf;
        in = oldin;
        ret true;
      comm:
        buf2 .= buf .= "$.v,";
        buf = buf2;
        if(!`expPow(buf=, in=)) ret false;
        buf .= "$.v)";
      }
    while true:
    }
    ret true;
  }
  bool expAdsb(%char out=, ^/char in=)
  {
    %char buf;
    if(!`expMldv(buf=, in=)) ret false;
    loop{
      ^/char oldin;
      ^/char token;
    do:
      oldin = in;
      token = `tokenizer(in=);
      branch{
        %char buf2;
      cond .s.equ("+", token):
        buf2 .= "`trAdd(";
      cond .s.equ("-", token):
        buf2 .= "`trSub(";
      else:
        out .= buf;
        in = oldin;
        ret true;
      comm:
        buf2 .= buf .= "$.v,";
        buf = buf2;
        if(!`expMldv(buf=, in=)) ret false;
        buf .= "$.v)";
      }
    while true:
    }
    ret true;
  }
  bool expGrls(%char out=, ^/char in=)
  {
    %char buf;
    if(!`expAdsb(buf=, in=)) ret false;
    loop{
      ^/char oldin;
      ^/char token;
    do:
      oldin = in;
      token = `tokenizer(in=);
      branch{
        %char buf2;
      cond .s.equ(">", token):
        buf2 .= "`trGr(";
      cond .s.equ(">=", token):
        buf2 .= "`trGrE(";
      cond .s.equ("<", token):
        buf2 .= "`trLs(";
      cond .s.equ("<=", token):
        buf2 .= "`trLsE(";
      else:
        out .= buf;
        in = oldin;
        ret true;
      comm:
        buf2 .= buf .= "$.v,";
        buf = buf2;
        if(!`expAdsb(buf=, in=)) ret false;
        buf .= "$.v)";
      }
    while true:
    }
    ret true;
  }
  bool expRange(
    %char buf=, ^/char in=, ^/char oldoldin, bool openkaku, bool not)
  {
    %char buf3;
    if(!`expBoolOr(buf3=, in=)) ret false;
    ^/char oldin = in;
    ^/char token = `tokenizer(in=);
    branch{
    cond .s.equ(",", token):
      buf .=
        "`trRange(" .= (not ? ".v,true," : ".v,false,")
        .= (openkaku ? "true," : "false,") .= buf3 .= "$.v,";
      if(!`expBoolOr(buf=, in=)) ret false;
      buf .= "$.v,";
      token = `tokenizer(in=);
      branch{
      cond .s.equ("]", token):
        buf .= "true)";
      cond .s.equ(")", token):
        buf .= "false)";
      else:
        `lasterror = "]か)がありません";
        ret false;
      }
    else:
      if(!.s.equ(")", token) && !.s.equ("]", token)){
        `lasterror = "括弧が閉じていません";
        ret false;
      }
      in = oldoldin;
      branch{
      cond not:
        buf .= "`trNEqu(";
      else:
        buf .= "`trEqu(";
      }
      buf .= ".v,";
      if(!`expGrls(buf=, in=)) ret false;
      buf .= "$.v)";
    }
    ret true;
  }
  bool expEquSub(%char buf=, ^/char in=, bool not)
  {
    branch{
      bool openkaku = false;
      ^/char oldin = in;
      ^/char token = `tokenizer(in=);
    cond .s.equ("[", token):
      openkaku = true;
    cond .s.equ("(", token):
    else:
      in = oldin;
      branch{
      cond not:
        buf .= "`trNEqu(";
      else:
        buf .= "`trEqu(";
      }
      buf .= ".v,";
      if(!`expGrls(buf=, in=)) ret false;
      buf .= "$.v)";
      break;
    comm:
      if(!`expRange(buf=, in=, oldin, openkaku, not)) ret false;
    }
    ret true;
  }
  bool expEqu(%char out=, ^/char in=)
  {
    %char buf;
    if(!`expGrls(buf=, in=)) ret false;
    loop{
      ^/char oldin;
      ^/char token;
    do:
      oldin = in;
      token = `tokenizer(in=);
      branch{
        bool not;
      cond .s.equ("=", token):
        not = false;
      cond .s.equ("!=", token):
        not = true;
      else:
        out .= buf;
        in = oldin;
        ret true;
      comm:
        buf .= '$';
        if(!`expEquSub(buf=, in=, not)) ret false;
      }
    while true:
    }
    ret true;
  }
  bool expAnd(%char out=, ^/char in=)
  {
    %char buf;
    if(!`expEqu(buf=, in=)) ret false;
    loop{
      ^/char oldin;
      ^/char token;
    do:
      oldin = in;
      token = `tokenizer(in=);
      branch{
      cond !.s.equ("&", token):
        out .= buf;
        in = oldin;
        ret true;
      comm:
        {
          %char buf2;
          buf2 .= "`trAnd(" .= buf .= "$.v,";
          buf = buf2;
          if(!`expEqu(buf=, in=)) ret false;
          buf .= "$.v)";
        }
      }
    while true:
    }
    ret true;
  }
  bool expXor(%char out=, ^/char in=)
  {
    %char buf;
    if(!`expAnd(buf=, in=)) ret false;
    loop{
      ^/char oldin;
      ^/char token;
    do:
      oldin = in;
      token = `tokenizer(in=);
      branch{
      cond !.s.equ("^", token):
        out .= buf;
        in = oldin;
        ret true;
      comm:
        {
          %char buf2;
          buf2 .= "`trXor(" .= buf .= "$.v,";
          buf = buf2;
          if(!`expAnd(buf=, in=)) ret false;
          buf .= "$.v)";
        }
      }
    while true:
    }
    ret true;
  }
  bool expOr(%char out=, ^/char in=)
  {
    %char buf;
    if(!`expXor(buf=, in=)) ret false;
    loop{
      ^/char oldin;
      ^/char token;
    do:
      oldin = in;
      token = `tokenizer(in=);
      branch{
      cond !.s.equ("|", token):
        out .= buf;
        in = oldin;
        ret true;
      comm:
        {
          %char buf2;
          buf2 .= "`trOr(" .= buf .= "$.v,";
          buf = buf2;
          if(!`expXor(buf=, in=)) ret false;
          buf .= "$.v)";
        }
      }
    while true:
    }
    ret true;
  }
  bool expBoolAnd(%char out=, ^/char in=)
  {
    %char buf;
    if(!`expOr(buf=, in=)) ret false;
    loop{
      ^/char oldin;
      ^/char token;
    do:
      oldin = in;
      token = `tokenizer(in=);
      branch{
      cond !.s.equ("&&", token):
        out .= buf;
        in = oldin;
        ret true;
      comm:
        {
          %char buf2;
          buf2 .= "`trBoolAnd(" .= buf .= "$.v,";
          buf = buf2;
          if(!`expOr(buf=, in=)) ret false;
          buf .= "$.v)";
        }
      }
    while true:
    }
    ret true;
  }
  bool expBoolXor(%char out=, ^/char in=)
  {
    %char buf;
    if(!`expBoolAnd(buf=, in=)) ret false;
    loop{
      ^/char oldin;
      ^/char token;
    do:
      oldin = in;
      token = `tokenizer(in=);
      branch{
      cond !.s.equ("^^", token):
        out .= buf;
        in = oldin;
        ret true;
      comm:
        {
          %char buf2;
          buf2 .= ".v.setB(" .= buf .= "$.v.isTrue()^";
          buf = buf2;
          if(!`expBoolAnd(buf=, in=)) ret false;
          buf .= "$.v.isTrue())";
        }
      }
    while true:
    }
    ret true;
  }
  bool expBoolOr(%char out=, ^/char in=)
  {
    %char buf;
    if(!`expBoolXor(buf=, in=)) ret false;
    loop{
      ^/char oldin;
      ^/char token;
    do:
      oldin = in;
      token = `tokenizer(in=);
      branch{
      cond !.s.equ("||", token):
        out .= buf;
        in = oldin;
        ret true;
      comm:
        {
          %char buf2;
          buf2 .= "`trBoolOr(" .= buf .= "$.v,";
          buf = buf2;
          if(!`expBoolXor(buf=, in=)) ret false;
          buf .= "$.v)";
        }
      }
    while true:
    }
    ret true;
  }
  bool expression(%char out=, ^/char in=)
  {
    if(!`expBoolOr(out=, in=)) ret false;
    ^/char oldin = in;
    ^/char token = `tokenizer(in=);
    if(#token > 0) branch{
    cond .s.equ(token, ","):
      in = oldin;
    cond .cfg.IgnoreMostErrors:
      out .= "$.v.setSF()";
      in = in[.s.find(",", in)..-1];
    else:
      {
        %char buf;
        `lasterror = (buf .= token .= "が不正です");
        ret false;
      }
    }
    ret true;
  }
  bool fullExpression(%char out=, ^/char in=, ^/char bef, ^/char aft)
  {
    out .= bef;
    if(!`expression(out=, in=)) ret false;
    out .= aft;
    ret true;
  }
  bool parse<func_t>(%^/char lines, index i=, ^/char sec)
  {:<-
    bool atodeyaru<f_t>(^/char sec, ^^^/char am)
    {
      loop{index i = 0; while; do:
        if(!f_t(sec, am[i][0], am[i][1])) ret false;
        i++;
      while i < #am:
      }
      ret true;
    }
    loop{
      index f;
      ^/char line;
      &.tbl.NameTable!int? tbl;
      %^^/char atomawasi;
      bool typedeta = false;
      while;
    do:
      if(#lines[i] > 0 && lines[i][0] == '['){
        if(.s.find("]", lines[i]) < 0) break, continue;
        i--;
        break, break;
      }
      line = lines[i][0...s.find(";", lines[i])];
      f = .s.find("=", line);
      if(f > 0){
        ^/char name =
          @s.toLower()<, @s.trim()<,
          @s.join(" ")<, @s.split(\x81\x40)<, line[0..f];
        if(#name > 0){
          bool foo = true;
          ^/char data = .s.trim(line[f+1..-1]);
          if(#data == 0) break;
          if(
            typeidof(func_t) != typeidof(`stateBulid:<-state)
            && data[0] == '"')
          {
            data = data[1...s.find(\", data[1..-1])+1];
          }
          if(!.s.equ(name[0..7], "trigger")){
            index nr = -1;
            branch{
            cond .s.equ(name[0..3], "var"):
              nr = 3;
            cond .s.equ(name[0..4], "fvar"):
              nr = 4;
            cond .s.equ(name[0..6], "sysvar"):
              nr = 6;
            cond .s.equ(name[0..7], "sysfvar"):
              nr = 7;
            }
            tbl.operate(name[0..nr])<,
              [void(^int d=){
                if(#d > 0){
                  foo = false;
                  ret;
                }
                d.new(1);
              }];
          }
          if(!foo){
            if(.cfg.IgnoreMostErrors) break, break, break;
            %char buf;
            `lasterror = (buf .= name .= "が重複しています");
            ret false;
          }
          branch{
          cond
            typeidof(func_t) == typeidof(`stateBulid:<-state)
            && !typedeta && !.s.equ(name[0..7], "trigger")
            :
            branch{
            cond .s.equ(name, "type"):
              typedeta = true;
              if(
                !func_t(sec, name, data) || !atodeyaru!func_t?(sec, atomawasi))
              {
                ret false;
              }
            else:
              atomawasi.new[-1].new(2);
              atomawasi[-1][0] = name;
              atomawasi[-1][1] = data;
            }
          else:
            if(!func_t(sec, name, data)) ret false;
          }
        }
      }
    continue:
      i++;
    while i < #lines:
    }
    ret true;
  }
  bool hitdef(^/char name, ^/char text=, |.CtrlTy typ)
  {
    int flg;
    ^/char obj =
      typ == .CtrlTy::Projectile ? "pr~hit" : "`stVal.hit";
    branch{
    cond .s.equ(name, "attr"):
      if(!`attr(flg=, text)) ret false;
      `state.ctrlList[-1].task .= obj .= ".attr=" .= .s.iToS(flg) .= ';';
    cond .s.equ(name, "damage"):
      `state.ctrlList[-1].task .= obj .= ".hitdamage=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toInt();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".guarddamage=", "$.v.toInt();")) ret false;
      }
    cond .s.equ(name, "animtype") || .s.equ(name, "air.animtype")
      || .s.equ(name, "fall.animtype")
      :
      if(#text == 0){
        `lasterror = "値が指定されていません";
        ret false;
      }
      switch(text[0]){
        ^/char tmp =
          name[1] == 'n' ? ".animtype"
          : (name[0] == 'f' ? ".fall.animtype" : ".air_animtype");
      case 'L', 'l':
        `state.ctrlList[-1].task .= obj .= tmp .= "=.AnimTy::Light;";
      case 'M', 'm':
        `state.ctrlList[-1].task .= obj .= tmp .= "=.AnimTy::Medium;";
      case 'H', 'h':
        `state.ctrlList[-1].task .= obj .= tmp .= "=.AnimTy::Hard;";
      case 'B', 'b':
        `state.ctrlList[-1].task .= obj .= tmp .= "=.AnimTy::Back;";
      case 'U', 'u':
        `state.ctrlList[-1].task .= obj .= tmp .= "=.AnimTy::Up;";
      case 'D', 'd':
        `state.ctrlList[-1].task .= obj .= tmp .= "=.AnimTy::Diagup;";
      default:
        if(!.cfg.IgnoreMostErrors){
          %char buf;
          `lasterror = (buf .= text .= "が無効な値です");
          ret false;
        }
      }
    cond .s.equ(name, "guardflag") || .s.equ(name, "hitflag"):
      flg = 0;
      loop{index i = 0; while; do:
        switch(text[i]){
        case 'H', 'h': flg |= (int).chr.StTy::S;
        case 'L', 'l': flg |= (int).chr.StTy::C;
        case 'M', 'm': flg |= (int).chr.StTy::S | (int).chr.StTy::C;
        case 'A', 'a': flg |= (int).chr.StTy::A;
        case 'F', 'f': flg |= (int).chr.StTy::N;
        case 'D', 'd': flg |= (int).chr.StTy::L;
        case 'P', 'p': flg |= (int).chr.StTy::U;
        }
        i++;
      while i < #text:
      }
      `state.ctrlList[-1].task .=
        obj .= (name[0] == 'h' ? ".hitflag=" : ".guardflag=")
        .= .s.iToS(flg) .= ';';
    cond .s.equ(name, "priority"):
      `state.ctrlList[-1].task .= obj .= ".priority=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toInt();";
      if(.s.equ(",")<, `tokenizer(text=)){
        text = .s.toLower()<, .s.trim(text);
        switch(text[0]){
        case 'H', 'h':
          `state.ctrlList[-1].task .= obj .= ".bothhittype=.PriTy::Hit;";
        case 'M', 'm':
          `state.ctrlList[-1].task .= obj .= ".bothhittype=.PriTy::Miss;";
        case 'D', 'd':
          `state.ctrlList[-1].task .= obj .= ".bothhittype=.PriTy::Dodge;";
        default:
          if(!.cfg.IgnoreMostErrors){
            %char buf;
            `lasterror = (buf .= text .= "が無効な値です");
            ret false;
          }
        }
      }
    cond .s.equ(name, "pausetime"):
      `state.ctrlList[-1].task .= obj .= ".pausetime=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toInt();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".shaketime=", "$.v.toInt();")) ret false;
      }
    cond .s.equ(name, "guard.pausetime"):
      `state.ctrlList[-1].task .= obj .= ".guard_pausetime=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toInt();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".guard_shaketime=", "$.v.toInt();")) ret false;
      }
    cond .s.equ(name, "sparkno"):
      flg = -1;
      branch{
      cond text[0] == 'F' || text[0] == 'f':
      cond text[0] == 'S' || text[0] == 's':
        flg = 0;
      else:
        break;
      comm:
        text = text[1..-1];
      }
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".sparkno=", "$.v.toInt();")) ret false;
      `state.ctrlList[-1].task .=
        obj .= ".sparkno=" .= obj .= ".sparkno<0?.com.IERR:"
        .= obj .= ".sparkno^" .= .s.iToS(flg) .= ';';
    cond .s.equ(name, "sparkxy"):
      `state.ctrlList[-1].task .= obj .= ".sparkx=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toFloat();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".sparky=", "$.v.toFloat();")) ret false;
      }
    cond .s.equ(name, "hitsound"):
      flg = -1;
      branch{
      cond text[0] == 'F' || text[0] == 'f':
      cond text[0] == 'S' || text[0] == 's':
        flg = 0;
      else:
        break;
      comm:
        text = text[1..-1];
      }
      `state.ctrlList[-1].task .= obj .= ".hitsoundg=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .=
        "$.v.toInt();" .= obj .= ".hitsoundg="
        .= obj .= ".hitsoundg<0?.com.IERR:"
        .= obj .= ".hitsoundg^" .= .s.iToS(flg) .= ';';
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".hitsoundn=", "$.v.toInt();")) ret false;
      }
    cond .s.equ(name, "guardsound"):
      flg = -1;
      branch{
      cond text[0] == 'F' || text[0] == 'f':
      cond text[0] == 'S' || text[0] == 's':
        flg = 0;
      else:
        break;
      comm:
        text = text[1..-1];
      }
      `state.ctrlList[-1].task .= obj .= ".guardsoundg=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .=
        "$.v.toInt();" .= obj .= ".guardsoundg="
        .= obj .= ".guardsoundg<0?.com.IERR:"
        .= obj .= ".guardsoundg^" .= .s.iToS(flg) .= ';';
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".guardsoundn=", "$.v.toInt();")) ret false;
      }
    cond .s.equ(name, "ground.type") || .s.equ(name, "air.type"):
      switch(text[0]){
        ^/char tmp = (name[0] == 'g' ? ".ground_type" : ".air_type");
      case 'H', 'h':
        `state.ctrlList[-1].task .= obj .= tmp .= "=.ReactTy::High;";
      case 'L', 'l':
        `state.ctrlList[-1].task .= obj .= tmp .= "=.ReactTy::Low;";
      case 'T', 't':
        `state.ctrlList[-1].task .= obj .= tmp .= "=.ReactTy::Trip;";
      case 'N', 'n':
        `state.ctrlList[-1].task .= obj .= tmp .= "=.ReactTy::Non;";
      default:
        if(!.cfg.IgnoreMostErrors){
          %char buf;
          `lasterror = (buf .= text .= "が無効な値です");
          ret false;
        }
      }
    cond .s.equ(name, "ground.slidetime"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".ground_slidetime=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "ground.hittime"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".ground_hittime=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "ground.velocity"):
      `state.ctrlList[-1].task .= obj .= ".ground_velocityx=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toFloat();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".ground_velocityy=", "$.v.toFloat();")) ret false;
      }
    cond .s.equ(name, "airguard.velocity"):
      `state.ctrlList[-1].task .= obj .= ".airguard_velocityx=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toFloat();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".airguard_velocityy=", "$.v.toFloat();")) ret false;
      }
    cond .s.equ(name, "air.velocity"):
      `state.ctrlList[-1].task .= obj .= ".air_velocityx=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toFloat();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".air_velocityy=", "$.v.toFloat();")) ret false;
      }
    cond .s.equ(name, "air.hittime"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".air_hittime=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "getpower"):
      `state.ctrlList[-1].task .= obj .= ".hitgetpower=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toInt();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".guardgetpower=", "$.v.toInt();")) ret false;
      }
    cond .s.equ(name, "ground.cornerpush.veloff"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".ground_cornerpush_veloff=",
          "$.v.toFloat();")) ret false;
    cond .s.equ(name, "guard.cornerpush.veloff"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".guard_cornerpush_veloff=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "air.cornerpush.veloff"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".air_cornerpush_veloff=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "down.cornerpush.veloff"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".down_cornerpush_veloff=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "air.fall"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".air_fall=(int)(", "$.v.isTrue());")) ret false;
    cond .s.equ(name, "fall.recover"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".fall.recover=(int)(", "$.v.isTrue());")) ret false;
    cond .s.equ(name, "fall.recovertime"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".fall.recovertime=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "p2stateno"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".p2stateno=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "guard.velocity"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".guard_velocity=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "fall"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".ground_fall=(int)(", "$.v.isTrue());")) ret false;
    cond .s.equ(name, "p1stateno"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".p1stateno=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "p2facing"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".p2facing=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "guard.slidetime"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".guard_slidetime=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "guard.hittime"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".guard_hittime=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "palfx.time"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".palfx_time=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "palfx.mul"):
      `state.ctrlList[-1].task .= obj .= ".palfx_mulr=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toInt();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj .= ".palfx_mulg=";
        if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
        `state.ctrlList[-1].task .= "$.v.toInt();";
        if(.s.equ(",")<, `tokenizer(text=)){
          `state.ctrlList[-1].task .= obj;
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              ".palfx_mulb=", "$.v.toInt();")) ret false;
        }
      }
    cond .s.equ(name, "palfx.add"):
      `state.ctrlList[-1].task .= obj .= ".palfx_addr=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toInt();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj .= ".palfx_addg=";
        if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
        `state.ctrlList[-1].task .= "$.v.toInt();";
        if(.s.equ(",")<, `tokenizer(text=)){
          `state.ctrlList[-1].task .= obj;
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              ".palfx_addb=", "$.v.toInt();")) ret false;
        }
      }
    cond .s.equ(name, "palfx.sinadd"):
      `state.ctrlList[-1].task .= obj .= ".palfx_amplr=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toInt();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj .= ".palfx_amplg=";
        if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
        `state.ctrlList[-1].task .= "$.v.toInt();";
        if(.s.equ(",")<, `tokenizer(text=)){
          `state.ctrlList[-1].task .= obj .= ".palfx_amplb=";
          if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
          `state.ctrlList[-1].task .= "$.v.toInt();";
          if(.s.equ(",")<, `tokenizer(text=)){
            `state.ctrlList[-1].task .= obj;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".palfx_cycletime=", "$.v.toInt();")) ret false;
          }
        }
      }
    cond .s.equ(name, "palfx.color"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".palfx_color=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "palfx.invertall"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".palfx_invertall=(int)(", "$.v.isTrue());")) ret false;
    cond .s.equ(name, "kill"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".kill=(int)(", "$.v.isTrue());")) ret false;
    cond .s.equ(name, "guard.kill"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".guard_kill=(int)(", "$.v.isTrue());")) ret false;
    cond .s.equ(name, "envshake.time"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".envshake_time=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "envshake.ampl"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".envshake_ampl=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "envshake.freq"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".envshake_freq=.m.max!float?(0.0,", "$.v.toFloat());")) ret false;
    cond .s.equ(name, "envshake.phase"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".envshake_phase=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "airguard.ctrltime"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".airguard_ctrltime=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "down.velocity"):
      `state.ctrlList[-1].task .= obj .= ".down_velocityx=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toFloat();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".down_velocityy=", "$.v.toFloat();")) ret false;
      }
    cond .s.equ(name, "yaccel"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".yaccel=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "airguard.cornerpush.veloff"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".airguard_cornerpush_veloff=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "id"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=, ".id=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "sprpriority") || .s.equ(name, "p1sprpriority"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".p1sprpriority=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "p2sprpriority"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".p2sprpriority=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "numhits"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".numhits=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "p1facing"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".p1facing=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "forcestand"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".forcestand=(int)(", "$.v.isTrue());")) ret false;
    cond .s.equ(name, "snap"):
      `state.ctrlList[-1].task .=
        obj .= ".mindistx=" .= obj .= ".maxdistx=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toFloat();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .=
          obj .= ".mindisty=" .= obj .= ".maxdisty=";
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            "", "$.v.toFloat();")) ret false;
      }
    cond .s.equ(name, "guard.ctrltime"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".guard_ctrltime=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "down.hittime"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".down_hittime=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "givepower"):
      `state.ctrlList[-1].task .= obj .= ".hitgivepower=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toInt();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".guardgivepower=", "$.v.toInt();")) ret false;
      }
    cond .s.equ(name, "guard.sparkno"):
      flg = -1;
      branch{
      cond text[0] == 'F' || text[0] == 'f':
      cond text[0] == 'S' || text[0] == 's':
        flg = 0;
      else:
        break;
      comm:
        text = text[1..-1];
      }
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".guard_sparkno=", "$.v.toInt();")) ret false;
      `state.ctrlList[-1].task .=
        obj .= ".guard_sparkno=" .= obj .= ".guard_sparkno<0?.com.IERR:"
        .= obj .= ".guard_sparkno^" .= .s.iToS(flg) .= ';';
    cond .s.equ(name, "fall.xvelocity"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".fall.xvelocity=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "fall.yvelocity"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".fall.yvelocity=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "guard.dist"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".guard_dist=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "fall.damage"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".fall.damage=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "fall.envshake.time"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".fall.envshake_time=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "fall.envshake.ampl"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".fall.envshake_ampl=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "fall.envshake.freq"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".fall.envshake_freq=.m.max!float?(0.0,",
          "$.v.toFloat());")) ret false;
    cond .s.equ(name, "fall.envshake.phase"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".fall.envshake_phase=", "$.v.toFloat();")) ret false;
    cond .s.equ(name, "mindist"):
      `state.ctrlList[-1].task .= obj .= ".mindistx=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toFloat();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".mindisty=", "$.v.toFloat();")) ret false;
      }
    cond .s.equ(name, "maxdist"):
      `state.ctrlList[-1].task .= obj .= ".maxdistx=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toFloat();";
      if(!.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".maxdisty=", "$.v.toFloat();")) ret false;
      }
    cond .s.equ(name, "air.juggle"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".air_juggle=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "nochainid"):
      `state.ctrlList[-1].task .= obj .= ".nochainid1=";
      if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
      `state.ctrlList[-1].task .= "$.v.toInt();";
      if(.s.equ(",")<, `tokenizer(text=)){
        `state.ctrlList[-1].task .= obj;
        if(
          !`fullExpression(
            `state.ctrlList[-1].task=, text=,
            ".nochainid2=", "$.v.toInt();")) ret false;
      }
    cond .s.equ(name, "down.bounce"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".down_bounce=(int)(", "$.v.isTrue());")) ret false;
    cond .s.equ(name, "hitonce"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".hitonce=(int)(", "$.v.isTrue());")) ret false;
    cond .s.equ(name, "affectteam"):
      switch(text[0]){
      case 'E', 'e':
        `state.ctrlList[-1].task .= obj .= ".affectteam=1;";
      case 'B', 'b':
        `state.ctrlList[-1].task .= obj .= ".affectteam=0;";
      case 'F', 'f':
        `state.ctrlList[-1].task .= obj .= ".affectteam=-1;";
      default:
        if(!.cfg.IgnoreMostErrors){
          %char buf;
          `lasterror = (buf .= text .= "が無効な値です");
          ret false;
        }
      }
    cond .s.equ(name, "p2getp1state"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".p2getp1state=(int)(", "$.v.isTrue());")) ret false;
    cond .s.equ(name, "p1getp2facing"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".p1getp2facing=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "chainid"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".chainid=", "$.v.toInt();")) ret false;
    cond .s.equ(name, "fall.kill"):
      `state.ctrlList[-1].task .= obj;
      if(
        !`fullExpression(
          `state.ctrlList[-1].task=, text=,
          ".fall.kill=(int)(", "$.v.isTrue());")) ret false;
    else:
      switch(typ){
      case .CtrlTy::ReversalDef:
        branch{
        cond .s.equ(name, "reversal.attr"):
          if(!`attr(flg=, text)) ret false;
          `state.ctrlList[-1].task .=
            obj .= ".reversal_attr=" .= .s.iToS(flg) .= ';';
        else:
          break, default;
        }
      case .CtrlTy::Projectile:
        branch{
        cond .s.equ(name, "projid"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~id=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "projanim"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~anim=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "projhitanim"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~hitanim=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "projremanim"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~remanim=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "projcancelanim"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~cancelanim=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "projscale"):
          `state.ctrlList[-1].task .= "pr~scalex=";
          if(
            !`expression(
              `state.ctrlList[-1].task=, text=)) ret false;
          `state.ctrlList[-1].task .= "$.v.toFloat();";
          if(.s.equ(",")<, `tokenizer(text=)){
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "pr~scaley=", "$.v.toFloat();")) ret false;
          }
        cond .s.equ(name, "projremove"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~remove=(int)(", "$.v.isTrue());")) ret false;
        cond .s.equ(name, "projremovetime"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~removetime=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "velocity"):
          `state.ctrlList[-1].task .= "pr~velocityx=";
          if(
            !`expression(`state.ctrlList[-1].task=, text=)) ret false;
          `state.ctrlList[-1].task .= "$.v.toFloat();";
          if(.s.equ(",")<, `tokenizer(text=)){
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "pr~velocityy=", "$.v.toFloat();")) ret false;
          }
        cond .s.equ(name, "remvelocity"):
          `state.ctrlList[-1].task .= "pr~remvelocityx=";
          if(
            !`expression(
              `state.ctrlList[-1].task=, text=)) ret false;
          `state.ctrlList[-1].task .= "$.v.toFloat();";
          if(.s.equ(",")<, `tokenizer(text=)){
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "pr~remvelocityy=", "$.v.toFloat();")) ret false;
          }
        cond .s.equ(name, "accel"):
          `state.ctrlList[-1].task .= "pr~accelx=";
          if(
            !`expression(
              `state.ctrlList[-1].task=, text=)) ret false;
          `state.ctrlList[-1].task .= "$.v.toFloat();";
          if(.s.equ(",")<, `tokenizer(text=)){
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "pr~accely=", "$.v.toFloat();")) ret false;
          }
        cond .s.equ(name, "velmul"):
          `state.ctrlList[-1].task .= "pr~velmulx=";
          if(
            !`expression(
              `state.ctrlList[-1].task=, text=)) ret false;
          `state.ctrlList[-1].task .= "$.v.toFloat();";
          if(.s.equ(",")<, `tokenizer(text=)){
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "pr~velmuly=", "$.v.toFloat();")) ret false;
          }
        cond .s.equ(name, "projhits"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~hits=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "projmisstime"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~misstime=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "projpriority"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~prioritypoint=pr~priority=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "projsprpriority"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~sprpriority=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "projedgebound"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~edgebound=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "projstagebound"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~stagebound=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "projheightbound"):
          `state.ctrlList[-1].task .= "pr~heightboundt=";
          if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
          `state.ctrlList[-1].task .= "$.v.toInt();";
          if(.s.equ(",")<, `tokenizer(text=)){
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "pr~heightboundb=", "$.v.toInt();")) ret false;
          }
        cond .s.equ(name, "projshadow"):
          `state.ctrlList[-1].task .= "pr~shadowr=";
          if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
          `state.ctrlList[-1].task .= "$.v.toInt();";
          if(.s.equ(",")<, `tokenizer(text=)){
            `state.ctrlList[-1].task .= "pr~shadowg=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "pr~shadowb=", "$.v.toInt();")) ret false;
            }
          }
        cond .s.equ(name, "supermovetime"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~supermovetime=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "pausemovetime"):
          if(
            !`fullExpression(
              `state.ctrlList[-1].task=, text=,
              "pr~pausemovetime=", "$.v.toInt();")) ret false;
        cond .s.equ(name, "postype"):
          text = .s.toLower(text);
          branch{
          cond .s.equ(text[0..2], "p2"):
            `state.ctrlList[-1].task .= "pt=1;";
          cond text[0] == 'p':
            `state.ctrlList[-1].task .= "pt=0;";
          cond text[0] == 'f':
            `state.ctrlList[-1].task .= "pt=2;";
          cond text[0] == 'b':
            `state.ctrlList[-1].task .= "pt=3;";
          cond text[0] == 'l':
            `state.ctrlList[-1].task .= "pt=4;";
          cond text[0] == 'r':
            `state.ctrlList[-1].task .= "pt=5;";
          else:
            if(!.cfg.IgnoreMostErrors){
              %char buf;
              `lasterror = (buf .= text .= "が無効な値です");
              ret false;
            }
          }
        cond .s.equ(name, "offset"):
          `state.ctrlList[-1].task .= "x=";
          if(
            !`expression(
              `state.ctrlList[-1].task=, text=)) ret false;
          `state.ctrlList[-1].task .= "$.v.toFloat();";
          if(.s.equ(",")<, `tokenizer(text=)){
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "y=", "$.v.toFloat();")) ret false;
          }
        else:
          break, default;
        }
      default:
        if(.cfg.IgnoreMostErrors) break;
        `lasterror = "無効なキー名です";
        ret false;
      }
    }
    ret true;
  }
  bool stateBulid(%char buf=, ^/char def, ^/char st=)
  {:<-
    public bool statedef(^/char sec, ^/char name, ^/char data)
    {
      ^/char text = data;
      branch{
      cond .s.equ(name, "type"):
        switch(.s.toLowerChar(data[0])){
        case 's':
          `state.typ = .chr.StTy::S;
        case 'c':
          `state.typ = .chr.StTy::C;
        case 'a':
          `state.typ = .chr.StTy::A;
        case 'l':
          `state.typ = .chr.StTy::L;
        case 'u':
          `state.typ = .chr.StTy::U;
        default:
          if(!.cfg.IgnoreMostErrors){
            %char buf;
            `lasterror = (buf .= data .= "が無効な値です");
            ret false;
          }
        }
      cond .s.equ(name, "movetype"):
        switch(.s.toLowerChar(data[0])){
        case 'i':
          `state.mov = .chr.MovTy::I;
        case 'a':
          `state.mov = .chr.MovTy::A;
        case 'h':
          `state.mov = .chr.MovTy::H;
        case 'u':
          `state.mov = .chr.MovTy::U;
        default:
          if(!.cfg.IgnoreMostErrors){
            %char buf;
            `lasterror = (buf .= data .= "が無効な値です");
            ret false;
          }
        }
      cond .s.equ(name, "physics"):
        switch(.s.toLowerChar(data[0])){
        case 's':
          `state.phy = .chr.StTy::S;
        case 'c':
          `state.phy = .chr.StTy::C;
        case 'a':
          `state.phy = .chr.StTy::A;
        case 'n':
          `state.phy = .chr.StTy::N;
        case 'u':
          `state.phy = .chr.StTy::U;
        default:
          if(!.cfg.IgnoreMostErrors){
            %char buf;
            `lasterror = (buf .= data .= "が無効な値です");
            ret false;
          }
        }
      cond .s.equ(name, "sprpriority"):
        if(
          !`fullExpression(
            `state.deftask=, text=,
            "`sprpriority=", "$.v.toInt();")) ret false;
      cond .s.equ(name, "anim"):
        if(
          !`fullExpression(
            `state.deftask=, text=,
            "`trChangeAnim(", "$.v.toInt());")) ret false;
      cond .s.equ(name, "ctrl"):
        if(
          !`fullExpression(
            `state.deftask=, text=,
            "`setCtrl(", "$.v.isTrue());")) ret false;
      cond .s.equ(name, "hitcountpersist"):
        if(
          !`fullExpression(
            `state.deftask=, text=, "if(",
            "$!.v.isTrue())`clearHitCount();")) ret false;
        `state.hitcountpersist = 1;
      cond .s.equ(name, "velset"):
        if(!`expression(`state.deftask=, text=)) ret false;
        `state.deftask .= "$`trVelSetX();";
        branch{
          ^/char tmp = `tokenizer(text=);
        cond .s.equ(",", tmp):
          if(
            !`fullExpression(
              `state.deftask=, text=, "", "$`trVelSetY();")) ret false;
        cond #tmp != 0:
          {
            %char buf;
            `lasterror = (buf .= tmp .= "が不正です");
            ret false;
          }
        }
      cond .s.equ(name, "juggle"):
        if(
          !`fullExpression(
            `state.deftask=, text=,
            "`stVal.juggle=", "$.v.toInt();")) ret false;
        `state.juggle = 1;
      cond .s.equ(name, "poweradd"):
        if(
          !`fullExpression(
            `state.deftask=, text=,
            "`addPower(", "$.v.toInt());")) ret false;
      cond .s.equ(name, "facep2"):
        if(
          !`fullExpression(
            `state.deftask=, text=, "if(",
            "$.v.isTrue()&&`trP2DistX()$.v.toFloat()<0.0)"
            "`setFacing(-`facing);")) ret false;
      cond .s.equ(name, "hitdefpersist"):
        if(
          !`fullExpression(
            `state.deftask=, text=, "if(",
            "$!.v.isTrue())`clearHitDef();")) ret false;
        `state.hitdefpersist = 1;
      cond .s.equ(name, "movehitpersist"):
        if(
          !`fullExpression(
            `state.deftask=, text=, "if(",
            "$!.v.isTrue())`stVal.mctime=0;")) ret false;
        `state.movehitpersist = 1;
      else:
        if(.cfg.IgnoreMostErrors) break;
        `lasterror = "無効なキー名です";
        ret false;
      }
      ret true;
    }
    public bool state(^/char sec, ^/char name, ^/char data)
    {
      branch{
        ^/char text = data;
      cond .s.equ(name, "type"):
        branch{
          ^char s = .s.toLower(data);
          if(`state.ctrlList[-1].typ != .CtrlTy::Unknown){
            if(.cfg.IgnoreMostErrors) break, break;
            `lasterror = "typeが二重指定されています";
            ret false;
          }
        cond .s.equ(s, "changestate"):
          `state.ctrlList[-1].typ = .CtrlTy::ChangeState;
        cond .s.equ(s, "selfstate"):
          `state.ctrlList[-1].typ = .CtrlTy::SelfState;
        cond .s.equ(s, "changeanim"):
          `state.ctrlList[-1].typ = .CtrlTy::ChangeAnim;
        cond .s.equ(s, "changeanim2"):
          `state.ctrlList[-1].typ = .CtrlTy::ChangeAnim2;
        cond .s.equ(s, "posset"):
          `state.ctrlList[-1].typ = .CtrlTy::PosSet;
        cond .s.equ(s, "posadd"):
          `state.ctrlList[-1].typ = .CtrlTy::PosAdd;
        cond .s.equ(s, "velset"):
          `state.ctrlList[-1].typ = .CtrlTy::VelSet;
        cond .s.equ(s, "veladd"):
          `state.ctrlList[-1].typ = .CtrlTy::VelAdd;
        cond .s.equ(s, "velmul"):
          `state.ctrlList[-1].typ = .CtrlTy::VelMul;
        cond .s.equ(s, "varset") || .s.equ(s, "parentvarset"):
          `state.ctrlList[-1].typ = .CtrlTy::VarSet;
          if(s[0] == 'p'){
            `state.flag = 1;
            `state.ctrlList[-1].task .= "^`self p=`trParent()$.c;";
          }
        cond .s.equ(s, "varadd") || .s.equ(s, "parentvaradd"):
          `state.ctrlList[-1].typ = .CtrlTy::VarAdd;
          if(s[0] == 'p'){
            `state.flag = 1;
            `state.ctrlList[-1].task .= "^`self p=`trParent()$.c;";
          }
        cond .s.equ(s, "varrangeset"):
          `state.ctrlList[-1].typ = .CtrlTy::VarRangeSet;
        cond .s.equ(s, "varrandom"):
          `state.ctrlList[-1].typ = .CtrlTy::VarRandom;
        cond .s.equ(s, "turn"):
          `state.ctrlList[-1].typ = .CtrlTy::Turn;
          `state.ctrlList[-1].task .= "`setFacing(-`facing);";
        cond .s.equ(s, "ctrlset"):
          `state.ctrlList[-1].typ = .CtrlTy::CtrlSet;
        cond .s.equ(s, "statetypeset"):
          `state.ctrlList[-1].typ = .CtrlTy::StateTypeSet;
        cond .s.equ(s, "sprpriority"):
          `state.ctrlList[-1].typ = .CtrlTy::SprPriority;
        cond .s.equ(s, "hitdef"):
          `state.ctrlList[-1].typ = .CtrlTy::HitDef;
          `state.ctrlList[-1].task .=
            "`stVal.hit.clear();"
            "`stVal.hit.sparkno=!`sysivar[.iSPARKNO];"
            "`stVal.hit.guard_sparkno=!`sysivar[.iGUARD_SPARKNO];";
        cond .s.equ(s, "projectile"):
          `state.ctrlList[-1].typ = .CtrlTy::Projectile;
          `state.ctrlList[-1].task .=
            "^&.Projectile pr=`newProj();if(#pr==0)ret;"
            "int pt=0;float x=0.0,y=0.0;";
        cond .s.equ(s, "reversaldef"):
          `state.ctrlList[-1].typ = .CtrlTy::ReversalDef;
          `state.ctrlList[-1].task .= "`stVal.hit.clear();";
        cond .s.equ(s, "attackdist"):
          `state.ctrlList[-1].typ = .CtrlTy::AttackDist;
        cond .s.equ(s, "hitoverride"):
          `state.ctrlList[-1].typ = .CtrlTy::HitOverride;
          `state.ctrlList[-1].task .= "int a=0,s=0,st=-1,t=1,f=0;";
        cond .s.equ(s, "pause"):
          `state.ctrlList[-1].typ = .CtrlTy::Pause;
          `state.ctrlList[-1].task .= "int t;.pausebg=1;";
        cond .s.equ(s, "superpause"):
          `state.ctrlList[-1].typ = .CtrlTy::SuperPause;
          `state.ctrlList[-1].task .=
            .sndstart
            .= "int t;.superanim=.fight~getAction(30);.superfacing=`facing;"
            ".superposx=`sysfvar[.fX];.superposy=`sysfvar[.fY];"
            "`sysivar[.iMOVETIMESUPER]=0;"
            ".superdarken=1;"
            ".superp2defmul=.cfg.Super_TargetDefenceMul;"
            ".superunhittable=1;"
            ".superpausebg=1;";
        cond .s.equ(s, "lifeadd"):
          `state.ctrlList[-1].typ = .CtrlTy::LifeAdd;
          `state.ctrlList[-1].task .= "int va=0,k=1,a=0;";
        cond .s.equ(s, "lifeset"):
          `state.ctrlList[-1].typ = .CtrlTy::LifeSet;
        cond .s.equ(s, "poweradd"):
          `state.ctrlList[-1].typ = .CtrlTy::PowerAdd;
        cond .s.equ(s, "powerset"):
          `state.ctrlList[-1].typ = .CtrlTy::PowerSet;
        cond .s.equ(s, "targetlifeadd"):
          `state.ctrlList[-1].typ = .CtrlTy::TargetLifeAdd;
          `state.ctrlList[-1].task .= "int va=0,k=1,a=1,i=-1;";
        cond .s.equ(s, "targetbind"):
          `state.ctrlList[-1].typ = .CtrlTy::TargetBind;
          `state.ctrlList[-1].task .= "int t=1,i=-1;float x=0.0,y=0.0;";
        cond .s.equ(s, "targetstate"):
          `state.ctrlList[-1].typ = .CtrlTy::TargetState;
          `state.ctrlList[-1].task .= "int s=0,i=-1;";
        cond .s.equ(s, "targetvelset"):
          `state.ctrlList[-1].typ = .CtrlTy::TargetVelSet;
          `state.ctrlList[-1].task .= "int i=-1;";
        cond .s.equ(s, "targetveladd"):
          `state.ctrlList[-1].typ = .CtrlTy::TargetVelAdd;
          `state.ctrlList[-1].task .= "int i=-1;";
        cond .s.equ(s, "targetfacing"):
          `state.ctrlList[-1].typ = .CtrlTy::TargetFacing;
          `state.ctrlList[-1].task .= "int f=0,i=-1;";
        cond .s.equ(s, "targetpoweradd"):
          `state.ctrlList[-1].typ = .CtrlTy::TargetPowerAdd;
          `state.ctrlList[-1].task .= "int pw=0,i=-1;";
        cond .s.equ(s, "targetdrop"):
          `state.ctrlList[-1].typ = .CtrlTy::TargetDrop;
          `state.ctrlList[-1].task .= "int ex=-1,one=1;";
        cond .s.equ(s, "hitby"):
          `state.ctrlList[-1].typ = .CtrlTy::HitBy;
        cond .s.equ(s, "nothitby"):
          `state.ctrlList[-1].typ = .CtrlTy::NotHitBy;
        cond .s.equ(s, "attackmulset"):
          `state.ctrlList[-1].typ = .CtrlTy::AttackMulSet;
        cond .s.equ(s, "defencemulset"):
          `state.ctrlList[-1].typ = .CtrlTy::DefenceMulSet;
        cond .s.equ(s, "movehitreset"):
          `state.ctrlList[-1].typ = .CtrlTy::MoveHitReset;
          `state.ctrlList[-1].task .= "`trMoveHitReset();";
        cond .s.equ(s, "assertspecial"):
          `state.ctrlList[-1].typ = .CtrlTy::AssertSpecial;
        cond .s.equ(s, "posfreeze"):
          `state.ctrlList[-1].typ = .CtrlTy::PosFreeze;
        cond .s.equ(s, "playerpush"):
          `state.ctrlList[-1].typ = .CtrlTy::PlayerPush;
        cond .s.equ(s, "gravity"):
          `state.ctrlList[-1].typ = .CtrlTy::Gravity;
          `state.ctrlList[-1].task .= "`sysivar[.iSPECIALFLAG]|=.lsGRAVITY;";
        cond .s.equ(s, "bindtoparent"):
          `state.ctrlList[-1].typ = .CtrlTy::BindToParent;
          `state.ctrlList[-1].task .=
            "`sysivar[.iBINDTIME]=1;"
            "`sysfvar[.fBINDPOSX]=0.0;`sysfvar[.fBINDPOSY]=0.0;"
            "`trParent()$`setBindToId(.c<>=);";
        cond .s.equ(s, "bindtoroot"):
          `state.ctrlList[-1].typ = .CtrlTy::BindToRoot;
          `state.ctrlList[-1].task .=
            "`sysivar[.iBINDTIME]=1;"
            "`sysfvar[.fBINDPOSX]=0.0;`sysfvar[.fBINDPOSY]=0.0;"
            "`trRoot()$`setBindToId(.c<>=);";
        cond .s.equ(s, "bindtotarget"):
          `state.ctrlList[-1].typ = .CtrlTy::BindToTarget;
          `state.ctrlList[-1].task .=
            "int hmf=0;`sysivar[.iBINDTIME]=1;"
            "`sysfvar[.fBINDPOSX]=0.0;`sysfvar[.fBINDPOSY]=0.0;";
          `state.value =
            "branch{cond .v.setI(-1)$`trTarget()$#.c>0:"
            "`setBindToId(.c<>=);"
            "else:`sysivar[.iBINDTOID]=.com.IERR;}";
        cond .s.equ(s, "helper"):
          `state.ctrlList[-1].typ = .CtrlTy::Helper;
          `state.ctrlList[-1].task .=
            "^`self h;`trNewHelper(h=);if(#h==0)ret;"
            "int pt=0,f=1,st=0,o=0;float x=0.0,y=0.0;";
        cond .s.equ(s, "destroyself"):
          `state.ctrlList[-1].typ = .CtrlTy::DestroySelf;
          `state.ctrlList[-1].task .= "`trDestroySelf();";
        cond .s.equ(s, "explod"):
          `state.ctrlList[-1].typ = .CtrlTy::Explod;
          `state.ctrlList[-1].task .=
            "index i;^&.Explod e=`newExplod(i=);"
            "if(#e==0)ret;int t=0;float rx=0.0,ry=0.0;e~id=0;";
        cond .s.equ(s, "modifyexplod"):
          `state.ctrlList[-1].typ = .CtrlTy::ModifyExplod;
          `state.ctrlList[-1].task .=
            "&.ModifyExplod m;int t=0;float rx=0.0,ry=0.0;";
        cond .s.equ(s, "explodbindtime"):
          `state.ctrlList[-1].typ = .CtrlTy::ExplodBindTime;
          `state.ctrlList[-1].task .= "int i=-1,t=0;";
        cond .s.equ(s, "removeexplod"):
          `state.ctrlList[-1].typ = .CtrlTy::RemoveExplod;
          `state.ctrlList[-1].task .= "int i=-1;";
        cond .s.equ(s, "afterimage"):
          `state.ctrlList[-1].typ = .CtrlTy::AfterImage;
          `state.ctrlList[-1].task .= "`aimg.clear();`aimg.time=1;";
        cond .s.equ(s, "afterimagetime"):
          `state.ctrlList[-1].typ = .CtrlTy::AfterImageTime;
        cond .s.equ(s, "gamemakeanim"):
          `state.ctrlList[-1].typ = .CtrlTy::GameMakeAnim;
          `state.ctrlList[-1].task .=
            "index i;^&.Explod e=`newExplod(i=);if(#e==0)ret;"
            "int t=0;float rx=0.0,ry=0.0;"
            "e~ontop=1;e~sprpriority=-5;e~ownpal=1;";
        cond .s.equ(s, "makedust"):
          `state.ctrlList[-1].typ = .CtrlTy::MakeDust;
          `state.ctrlList[-1].task .=
            "int s=3;float x=0.0,y=0.0,x2=.com.FERR,y2=.com.FERR;";
        cond .s.equ(s, "angledraw"):
          `state.ctrlList[-1].typ = .CtrlTy::AngleDraw;
          `state.ctrlList[-1].task .=
          "`sysivar[.iSPECIALFLAG]|=.lsANGLEDRAW;"
          "`sysfvar[.fANGLESCALEX]=`sysfvar[.fANGLESCALEY]=1.0;";
        cond .s.equ(s, "angleadd"):
          `state.ctrlList[-1].typ = .CtrlTy::AngleAdd;
        cond .s.equ(s, "anglemul"):
          `state.ctrlList[-1].typ = .CtrlTy::AngleMul;
        cond .s.equ(s, "angleset"):
          `state.ctrlList[-1].typ = .CtrlTy::AngleSet;
        cond .s.equ(s, "palfx"):
          `state.ctrlList[-1].typ = .CtrlTy::PalFX;
          `state.ctrlList[-1].task .=
            "^&.com.PalFX fx=`getPalfx();fx~clear();fx~player=`id;";
        cond .s.equ(s, "allpalfx"):
          `state.ctrlList[-1].typ = .CtrlTy::AllPalFX;
          `state.ctrlList[-1].task .= ".com.allPalFX~clear();";
        cond .s.equ(s, "bgpalfx"):
          `state.ctrlList[-1].typ = .CtrlTy::BGPalFX;
          `state.ctrlList[-1].task .= ".stage.bgPalFX~clear();";
        cond .s.equ(s, "trans"):
          `state.ctrlList[-1].typ = .CtrlTy::Trans;
          `state.ctrlList[-1].task .= "int t=0;";
        cond .s.equ(s, "offset"):
          `state.ctrlList[-1].typ = .CtrlTy::Offset;
        cond .s.equ(s, "hitvelset"):
          `state.ctrlList[-1].typ = .CtrlTy::HitVelSet;
        cond .s.equ(s, "hitfallset"):
          `state.ctrlList[-1].typ = .CtrlTy::HitFallSet;
          `state.ctrlList[-1].task .=
            "int f=-1;float vx=.com.FERR,vy=.com.FERR;";
        cond .s.equ(s, "hitfallvel"):
          `state.ctrlList[-1].typ = .CtrlTy::HitFallVel;
          `state.ctrlList[-1].task .= "`trHitFallVel();";
        cond .s.equ(s, "hitfalldamage"):
          `state.ctrlList[-1].typ = .CtrlTy::HitFallDamage;
          `state.ctrlList[-1].task .= "`trHitFallDamage();";
        cond .s.equ(s, "fallenvshake"):
          `state.ctrlList[-1].typ = .CtrlTy::FallEnvShake;
          `state.ctrlList[-1].task .=
            ".stage.envShake.time=`stVal.hb.fall.envshake_time;"
            ".stage.envShake.freq=(`stVal.hb.fall.envshake_freq/180.0)*.m.PI;"
            ".stage.envShake.ampl=`stVal.hb.fall.envshake_ampl;"
            ".stage.envShake.phase=`stVal.hb.fall.envshake_phase;";
            ".stage.envShake.setDefPhase();";
        cond .s.equ(s, "envcolor"):
          `state.ctrlList[-1].typ = .CtrlTy::EnvColor;
          `state.ctrlList[-1].task .=
            ".envcol_time=1;"
            ".envcol_r=255;.envcol_g=255;.envcol_b=255;.envcol_under=0;";
        cond .s.equ(s, "envshake"):
          `state.ctrlList[-1].typ = .CtrlTy::EnvShake;
          `state.ctrlList[-1].task .= ".stage.envShake.clear();";
        cond .s.equ(s, "width"):
          `state.ctrlList[-1].typ = .CtrlTy::Width;
          `state.ctrlList[-1].task .= "float f=0.0,b=0.0;";
        cond .s.equ(s, "screenbound"):
          `state.ctrlList[-1].typ = .CtrlTy::ScreenBound;
        cond .s.equ(s, "hitadd"):
          `state.ctrlList[-1].typ = .CtrlTy::HitAdd;
        cond .s.equ(s, "playsnd"):
          `state.ctrlList[-1].typ = .CtrlTy::PlaySnd;
          `state.ctrlList[-1].task .= .sndstart;
        cond .s.equ(s, "stopsnd"):
          `state.ctrlList[-1].typ = .CtrlTy::StopSnd;
        cond .s.equ(s, "sndpan"):
          `state.ctrlList[-1].typ = .CtrlTy::SndPan;
          `state.ctrlList[-1].task .=
            "int ch=-1;float p=0.0;^float x=`sysfvar[.fX...fX+1];";
        cond .s.equ(s, "displaytoclipboard"):
          `state.ctrlList[-1].typ = .CtrlTy::DisplayToClipboard;
          `state.ctrlList[-1].task .=
            "^/char text;%&.Var vars;.com.clipboardText[`playerno].new(0);";
        cond .s.equ(s, "appendtoclipboard"):
          `state.ctrlList[-1].typ = .CtrlTy::AppendToClipboard;
          `state.ctrlList[-1].task .= "^/char text;%&.Var vars;";
        cond .s.equ(s, "clearclipboard"):
          `state.ctrlList[-1].typ = .CtrlTy::ClearClipboard;
          `state.ctrlList[-1].task .= ".com.clipboardText[`playerno].new(0);";
        cond .s.equ(s, "forcefeedback"):
          `state.ctrlList[-1].typ = .CtrlTy::ForceFeedback;
        cond .s.equ(s, "null"):
          `state.ctrlList[-1].typ = .CtrlTy::Null;
        else:
          if(!.cfg.IgnoreMostErrors){
            %char buf;
            `lasterror = (buf .= data .= "が無効な値です");
            ret false;
          }
          break;
        comm:
          `stconcnt++;
        }
      cond .s.equ(name, "triggerall"):
        if(#`state.ctrlList[-1].triggerall > 0){
          `state.ctrlList[-1].triggerall .= "&&";
        }
        if(
          !`fullExpression(
            `state.ctrlList[-1].triggerall=, text=,
            "", "$.v.isTrue()")) ret false;
      cond .s.equ(name[0..7], "trigger"):
        {
          index idx;
          if(!.s.sToNumber!idx.self?(idx=, name[7..-1]) || idx <= 0){
            if(.cfg.IgnoreMostErrors) loop{
              index tail = #name-1;
            do:
              if(.s.sToNumber!idx.self?(idx=, name[7..tail])) break, break;
            while --tail > 7:
              break, break, break;
            }
            `lasterror = "トリガー名が不正です";
            ret false;
          }
          idx--;
          if(#`state.ctrlList[-1].trigger.new[idx] > 0){
            `state.ctrlList[-1].trigger[idx] .= "&&";
          }
          if(
            !`fullExpression(
              `state.ctrlList[-1].trigger[idx]=, text=,
              "", "$.v.isTrue()")) ret false;
        }
      cond .s.equ(name, "persistent"):
        if(`state.no >= 0){
          %char buf;
          if(
            !`fullExpression(
              buf=, text=, "", "$`trSetPersistent(`stVal.ps[")) ret false;
          buf .= .s.iToS(#`state.ctrlList-1) .= "].p=)";
          `state.persist = buf;
        }
      cond .s.equ(name, "ignorehitpause"):
        {
          %char buf;
          if(!`fullExpression(buf=, text=,"", "$.v")) ret false;
          `state.ignorehitpause = buf;
        }
      else:
        if(`state.ctrlList[-1].typ == .CtrlTy::Unknown){
          if(.cfg.IgnoreMostErrors) break, break;
          `lasterror = "typeが指定されていません";
          ret false;
        }
        switch(`state.ctrlList[-1].typ){
        case .CtrlTy::ChangeState, .CtrlTy::SelfState:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=, "", "$")) ret false;
            branch{
            cond `state.ctrlList[-1].typ == .CtrlTy::SelfState:
              `state.ctrlList[-1].task .= "`trSelfState(a,c);";
            else:
              `state.ctrlList[-1].task .= "`trChangeState(a,c);";
            }
          cond .s.equ(name, "ctrl"):
            {
              %char buf;
              if(
                !`fullExpression(
                  buf=, text=, "c=", "$(int).v.isTrue();")) ret false;
              buf .= `state.ctrlList[-1].task;
              `state.ctrlList[-1].task = buf;
            }
          cond .s.equ(name, "anim"):
            {
              %char buf;
              if(
                !`fullExpression(buf=, text=, "a=", "$.v.toInt();")) ret false;
              buf .= `state.ctrlList[-1].task;
              `state.ctrlList[-1].task = buf;
            }
          else:
            break, default;
          }
        case .CtrlTy::ChangeAnim:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`trChangeAnim(.m.max!int?(0,", "$.v.toInt()));")) ret false;
          cond .s.equ(name, "elem"):
            {
              %char buf;
              if(
                !`fullExpression(
                  buf=, text=, "e=", "$.v.toInt();")) ret false;
              buf .= `state.ctrlList[-1].task;
              `state.ctrlList[-1].task = buf;
            }
            `state.value = "if(#`ani>0)`ani~ani.setAnimElem(e);";
          else:
            break, default;
          }
        case .CtrlTy::ChangeAnim2:
          branch{
          cond .s.equ(name, "value"):
            `state.ctrlList[-1].task .=
              "`trChangeAnim2(" .= .s.iToS(`playerno);
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=,
                text=, ",.m.max!int?(0,", "$.v.toInt()));")) ret false;
          cond .s.equ(name, "elem"):
            {
              %char buf;
              if(
                !`fullExpression(
                  buf=, text=, "e=", "$.v.toInt();")) ret false;
              buf .= `state.ctrlList[-1].task;
              `state.ctrlList[-1].task = buf;
            }
            `state.value = "if(#`ani>0)`ani~ani.setAnimElem(e);";
          else:
            break, default;
          }
        case .CtrlTy::PosSet:
          branch{
          cond .s.equ(name, "x"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`trAdd(.v.setF(.com.camerax)$.v,",
                "$.v)$`trSetX();")) ret false;
          cond .s.equ(name, "y"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "", "$`trSetY();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::PosAdd:
          branch{
          cond .s.equ(name, "x"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "", "$`trAddX();")) ret false;
          cond .s.equ(name, "y"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "", "$`trAddY();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::VelSet:
          branch{
          cond .s.equ(name, "x"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "", "$`trVelSetX();")) ret false;
          cond .s.equ(name, "y"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "", "$`trVelSetY();")) ret false;
          cond .s.equ(name, "z"):
          else:
            break, default;
          }
        case .CtrlTy::VelAdd:
          branch{
          cond .s.equ(name, "x"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "", "$`trVelAddX();")) ret false;
          cond .s.equ(name, "y"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "", "$`trVelAddY();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::VelMul:
          branch{
          cond .s.equ(name, "x"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "", "$`trVelMulX();")) ret false;
          cond .s.equ(name, "y"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "", "$`trVelMulY();")) ret false;
          cond .s.equ(name, "z"):
          else:
            break, default;
          }
        case .CtrlTy::VarSet:
          branch{
            %char buf;
          cond .s.equ(name, "v"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.v = buf;
          cond .s.equ(name, "fv"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.fv = buf;
          cond .s.equ(name, "value"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.value = buf;
          cond .s.equ(name[0..3], "var"):
            if(name[3] != '(' && .cfg.IgnoreMostErrors) break;
            {
              %char tmp;
              tmp .= name[3..-1] .= '=' .= text;
              text = tmp;
            }
            `state.ctrlList[-1].task .=
              `state.flag != 0 ? "p~trSetIVar(" : "`trSetIVar(";
            if(!`expValue(`state.ctrlList[-1].task=, text=)) ret false;
            {
              index f = .s.find("=", text);
              if(f < 0){
                `lasterror = "'='がありません";
                ret false;
              }
              text = text[f+1..-1];
            }
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=, "$.v,", "$.v);")) ret false;
          cond .s.equ(name[0..4], "fvar"):
            if(name[4] != '(' && .cfg.IgnoreMostErrors) break;
            {
              %char tmp;
              tmp .= name[4..-1] .= '=' .= text;
              text = tmp;
            }
            `state.ctrlList[-1].task .=
              `state.flag != 0 ? "p~trSetFVar(" : "`trSetFVar(";
            if(!`expValue(`state.ctrlList[-1].task=, text=)) ret false;
            {
              index f = .s.find("=", text);
              if(f < 0){
                `lasterror = "'='がありません";
                ret false;
              }
              text = text[f+1..-1];
            }
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=, "$.v,", "$.v);")) ret false;
          cond .s.equ(name[0..6], "sysvar"):
            if(name[6] != '(' && .cfg.IgnoreMostErrors) break;
            {
              %char tmp;
              tmp .= name[6..-1] .= '=' .= text;
              text = tmp;
            }
            `state.ctrlList[-1].task .=
              `state.flag != 0 ? "p~trSetSysIVar(" : "`trSetSysIVar(";
            if(!`expValue(`state.ctrlList[-1].task=, text=)) ret false;
            {
              index f = .s.find("=", text);
              if(f < 0){
                `lasterror = "'='がありません";
                ret false;
              }
              text = text[f+1..-1];
            }
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=, "$.v,", "$.v);")) ret false;
          cond .s.equ(name[0..7], "sysfvar"):
            if(name[7] != '(' && .cfg.IgnoreMostErrors) break;
            {
              %char tmp;
              tmp .= name[7..-1] .= '=' .= text;
              text = tmp;
            }
            `state.ctrlList[-1].task .=
              `state.flag != 0 ? "p~trSetSysFVar(" : "`trSetSysFVar(";
            if(!`expValue(`state.ctrlList[-1].task=, text=)) ret false;
            {
              index f = .s.find("=", text);
              if(f < 0){
                `lasterror = "'='がありません";
                ret false;
              }
              text = text[f+1..-1];
            }
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=, "$.v,", "$.v);")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::VarAdd:
          branch{
            %char buf;
          cond .s.equ(name, "v"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.v = buf;
          cond .s.equ(name, "fv"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.fv = buf;
          cond .s.equ(name, "value"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.value = buf;
          cond .s.equ(name[0..3], "var"):
            if(name[3] != '(' && .cfg.IgnoreMostErrors) break;
            {
              %char tmp;
              tmp .= name[3..-1] .= '=' .= text;
              text = tmp;
            }
            `state.ctrlList[-1].task .=
              `state.flag != 0 ? "p~trSetIVar(" : "`trSetIVar(";
            if(!`expValue(`state.ctrlList[-1].task=, text=)) ret false;
            {
              index f = .s.find("=", text);
              if(f < 0){
                `lasterror = "'='がありません";
                ret false;
              }
              text = text[f+1..-1];
            }
            `state.ctrlList[-1].task .=
              "$.v,`trAdd(" .= (`state.flag != 0 ? "p~trIVar()" : "`trIVar()");
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "$.v,", "$.v)$.v);")) ret false;
          cond .s.equ(name[0..4], "fvar"):
            if(name[4] != '(' && .cfg.IgnoreMostErrors) break;
            {
              %char tmp;
              tmp .= name[4..-1] .= '=' .= text;
              text = tmp;
            }
            `state.ctrlList[-1].task .=
              `state.flag != 0 ? "p~trSetFVar(" : "`trSetFVar(";
            if(!`expValue(`state.ctrlList[-1].task=, text=)) ret false;
            {
              index f = .s.find("=", text);
              if(f < 0){
                `lasterror = "'='がありません";
                ret false;
              }
              text = text[f+1..-1];
            }
            `state.ctrlList[-1].task .=
              "$.v,`trAdd(" .= (`state.flag != 0 ? "p~trFVar()" : "`trFVar()");
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "$.v,", "$.v)$.v);")) ret false;
          cond .s.equ(name[0..6], "sysvar"):
            if(name[6] != '(' && .cfg.IgnoreMostErrors) break;
            {
              %char tmp;
              tmp .= name[6..-1] .= '=' .= text;
              text = tmp;
            }
            `state.ctrlList[-1].task .=
              `state.flag != 0 ? "p~trSetSysIVar(" : "`trSetSysIVar(";
            if(!`expValue(`state.ctrlList[-1].task=, text=)) ret false;
            {
              index f = .s.find("=", text);
              if(f < 0){
                `lasterror = "'='がありません";
                ret false;
              }
              text = text[f+1..-1];
            }
            `state.ctrlList[-1].task .=
              "$.v,`trAdd(" .= (
                `state.flag != 0 ? "p~trSysIVar()" : "`trSysIVar()");
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "$.v,", "$.v)$.v);")) ret false;
          cond .s.equ(name[0..7], "sysfvar"):
            if(name[7] != '(' && .cfg.IgnoreMostErrors) break;
            {
              %char tmp .= name[7..-1] .= '=' .= text;
              text = tmp;
            }
            `state.ctrlList[-1].task .=
              `state.flag != 0 ? "p~trSetSysFVar(" : "`trSetSysFVar(";
            if(!`expValue(`state.ctrlList[-1].task=, text=)) ret false;
            {
              index f = .s.find("=", text);
              if(f < 0){
                `lasterror = "'='がありません";
                ret false;
              }
              text = text[f+1..-1];
            }
            `state.ctrlList[-1].task .=
              "$.v,`trAdd(" .= (
                `state.flag != 0 ? "p~trSysFVar()" : "`trSysFVar()");
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "$.v,", "$.v)$.v);")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::VarRangeSet:
          branch{
            %char buf;
          cond .s.equ(name, "first"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.v = buf;
          cond .s.equ(name, "last"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.fv = buf;
          cond .s.equ(name, "value"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.value = buf;
            `state.flag = 1;
          cond .s.equ(name, "fvalue"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.value = buf;
            `state.flag = 2;
          else:
            break, default;
          }
        case .CtrlTy::VarRandom:
          branch{
            %char buf;
          cond .s.equ(name, "v"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.value = buf;
          cond .s.equ(name, "range"):
            if(!`expression(buf=, text=)) ret false;
            buf .= "$.v.toInt()";
            `state.v = buf;
            branch{
              ^/char tmp = `tokenizer(text=);
            cond .s.equ(tmp, ","):
              buf.new(0);
              if(!`fullExpression(buf=, text=, "", "$.v.toInt()")) ret false;
              `state.fv = buf;
            cond #tmp == 0:
              `state.fv = `state.v;
              `state.v = "0";
            else:
              buf.new(0);
              `lasterror = (buf .= tmp .= "が不正です");
              ret false;
            }
          else:
            break, default;
          }
        case .CtrlTy::CtrlSet:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`setCtrl(", "$.v.isTrue());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::StateTypeSet:
          branch{
            text = .s.toLower(text);
          cond .s.equ(name, "statetype") || .s.equ(name, "value"):
            switch(text[0]){
            case 's':
              `state.ctrlList[-1].task .= "`stVal.typ=.StTy::S;";
            case 'c':
              `state.ctrlList[-1].task .= "`stVal.typ=.StTy::C;";
            case 'a':
              `state.ctrlList[-1].task .= "`stVal.typ=.StTy::A;";
            case 'l':
              `state.ctrlList[-1].task .= "`stVal.typ=.StTy::L;";
            default:
              if(!.cfg.IgnoreMostErrors){
                %char buf;
                `lasterror = (buf .= data .= "が無効な値です");
                ret false;
              }
            }
          cond .s.equ(name, "physics"):
            switch(text[0]){
            case 's':
              `state.ctrlList[-1].task .= "`stVal.phy=.StTy::S;";
            case 'c':
              `state.ctrlList[-1].task .= "`stVal.phy=.StTy::C;";
            case 'a':
              `state.ctrlList[-1].task .= "`stVal.phy=.StTy::A;";
            case 'n':
              `state.ctrlList[-1].task .= "`stVal.phy=.StTy::N;";
            default:
              if(!.cfg.IgnoreMostErrors){
                %char buf;
                `lasterror = (buf .= data .= "が無効な値です");
                ret false;
              }
            }
          cond .s.equ(name, "movetype"):
            switch(text[0]){
            case 'i':
              `state.ctrlList[-1].task .= "`stVal.mov=.MovTy::I;";
            case 'a':
              `state.ctrlList[-1].task .= "`stVal.mov=.MovTy::A;";
            case 'h':
              `state.ctrlList[-1].task .= "`stVal.mov=.MovTy::H;";
            default:
              if(!.cfg.IgnoreMostErrors){
                %char buf;
                `lasterror = (buf .= data .= "が無効な値です");
                ret false;
              }
            }
          else:
            break, default;
          }
        case .CtrlTy::SprPriority:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`sprpriority=", "$.v.toInt();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::HitBy, .CtrlTy::NotHitBy:
          branch{
            int flg = 0;
          cond<1> .s.equ(name, "value"):
          cond<2> .s.equ(name, "value2"):
          cond<t> .s.equ(name, "time"):
            {
              %char buf;
              if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
              `state.value = buf;
            }
            break;
          else:
            break, default;
          comm:
            if(!`attr(flg=, data)) ret false;
            if(`state.ctrlList[-1].typ == .CtrlTy::NotHitBy) flg = !flg;
          diff<1>:
            `state.ctrlList[-1].task .=
              "`stVal.hb.hitf1=" .= .s.iToS(flg) .= ';';
            branch{
            cond `state.flag == 2 || `state.flag == 3:
              `state.flag = 3;
            else:
              `state.flag = 1;
            }
          diff<2>:
            `state.ctrlList[-1].task .=
              "`stVal.hb.hitf2=" .= .s.iToS(flg) .= ';';
            branch{
            cond `state.flag == 1 || `state.flag == 3:
              `state.flag = 3;
            else:
              `state.flag = 2;
            }
          }
        case .CtrlTy::AttackMulSet:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`attackmul=((float)`sysivar[.iATTACK]/100.0)*",
                "$.v.toFloat();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::DefenceMulSet:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`defencemul=(float)`sysivar[.iDEFENCE]/(",
                "$.v.toFloat()*100.0);")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::AssertSpecial:
          if(
            !.s.equ(name, "flag")
            && !.s.equ(name, "flag2") && !.s.equ(name, "flag3"))
          {
            break, default;
          }
          text = .s.toLower(text);
          branch{
          cond .s.equ(text, "noautoturn"):
            `state.ctrlList[-1].task .=
              "`sysivar[.iSPECIALFLAG]|=.lsNOAUTOTURN;";
          cond .s.equ(text, "nowalk"):
            `state.ctrlList[-1].task .=
              "`sysivar[.iSPECIALFLAG]|=.lsNOWALK;";
          cond .s.equ(text, "nostandguard"):
            `state.ctrlList[-1].task .=
              "`sysivar[.iSPECIALFLAG]|=.lsNOSTANDGUARD;";
          cond .s.equ(text, "nocrouchguard"):
            `state.ctrlList[-1].task .=
              "`sysivar[.iSPECIALFLAG]|=.lsNOCROUCHGUARD;";
          cond .s.equ(text, "noairguard"):
            `state.ctrlList[-1].task .=
              "`sysivar[.iSPECIALFLAG]|=.lsNOAIRGUARD;";
          cond .s.equ(text, "roundnotover"):
            `state.ctrlList[-1].task .= ".specialFlag|=.gsROUNDNOTOVER;";
          cond .s.equ(text, "nomusic"):
            `state.ctrlList[-1].task .= ".specialFlag|=.gsNOMUSIC;";
          cond .s.equ(text, "nobardisplay"):
            `state.ctrlList[-1].task .= ".specialFlag|=.gsNOBARDISPLAY;";
          cond .s.equ(text, "noshadow"):
            `state.ctrlList[-1].task .=
              "`sysivar[.iSPECIALFLAG]|=.lsNOSHADOW;";
          cond .s.equ(text, "intro"):
            `state.ctrlList[-1].task .= ".specialFlag|=.gsINTRO;";
          cond .s.equ(text, "nokosnd"):
            `state.ctrlList[-1].task .= ".specialFlag|=.gsNOKOSND;";
          cond .s.equ(text, "nobg"):
            `state.ctrlList[-1].task .= ".specialFlag|=.gsNOBG;";
          cond .s.equ(text, "nofg"):
            `state.ctrlList[-1].task .= ".specialFlag|=.gsNOFG;";
          cond .s.equ(text, "invisible"):
            `state.ctrlList[-1].task .=
              "`sysivar[.iSPECIALFLAG]|=.lsINVISIBLE;";
          cond .s.equ(text, "globalnoshadow"):
            `state.ctrlList[-1].task .= ".specialFlag|=.gsGLOBALNOSHADOW;";
          cond .s.equ(text, "timerfreeze"):
            `state.ctrlList[-1].task .= ".specialFlag|=.gsTIMERFREEZE;";
          cond .s.equ(text, "nokoslow"):
            `state.ctrlList[-1].task .= ".specialFlag|=.gsNOKOSLOW;";
          cond .s.equ(text, "unguardable"):
            `state.ctrlList[-1].task .=
              "`sysivar[.iSPECIALFLAG]|=.lsUNGUARDABLE;";
          cond .s.equ(text, "nojugglecheck"):
            `state.ctrlList[-1].task .=
              "`sysivar[.iSPECIALFLAG]|=.lsNOJUGGLECHECK;";
          cond .s.equ(text, "noko"):
            `state.ctrlList[-1].task .= ".specialFlag|=.gsNOKO;";
          cond .s.equ(text, "guard"):
            `state.ctrlList[-1].task .= "`sysivar[.iSPECIALFLAG]|=.lsGUARD;";
          else:
            if(!.cfg.IgnoreMostErrors){
              %char buf;
              `lasterror = (buf .= data .= "が無効な値です");
              ret false;
            }
          }
        case .CtrlTy::PosFreeze:
          branch{
            %char buf;
          cond .s.equ(name, "value"):
            buf .= `state.value;
            if(
              !`fullExpression(
                buf=, text=, "if(",
                "$.v.isTrue())`sysivar[.iSPECIALFLAG]|="
                ".lsPOSFREEZEX|.lsPOSFREEZEY;")) ret false;
            `state.value = buf;
          cond .s.equ(name, "x"):
            buf .= `state.value;
            if(
              !`fullExpression(
                buf=, text=, "if(",
                "$.v.isTrue())`sysivar[.iSPECIALFLAG]|="
                ".lsPOSFREEZEX;")) ret false;
            `state.value = buf;
          cond .s.equ(name, "y"):
            buf .= `state.value;
            if(
              !`fullExpression(
                buf=, text=, "if(",
                "$.v.isTrue())`sysivar[.iSPECIALFLAG]|="
                ".lsPOSFREEZEY;")) ret false;
            `state.value = buf;
          else:
            break, default;
          }
        case .CtrlTy::PlayerPush:
          branch{
            %char buf;
          cond .s.equ(name, "value"):
            buf .= `state.value;
            if(
              !`fullExpression(
                buf=, text=, "branch{cond ",
                "$.v.isTrue():`sysivar[.iSPECIALFLAG]|=.lsPLAYERPUSH;"
                "else:`sysivar[.iSPECIALFLAG]&=!.lsPLAYERPUSH;}")) ret false;
            `state.value = buf;
          else:
            break, default;
          }
        case .CtrlTy::Width:
          branch{
          cond .s.equ(name, "edge") || .s.equ(name, "value"):
            {
              `state.ctrlList[-1].task .= "f=";
              if(!`expression(`state.ctrlList[-1].task=, text=)){
                ret false;
              }
              `state.ctrlList[-1].task .= "$.v.toFloat();";
              branch{
              cond .s.equ(",")<, `tokenizer(text=):
                if(
                  !`fullExpression(`state.ctrlList[-1].task=, text=,
                    "b=", "$.v.toFloat();")) ret false;
              else:
                `state.ctrlList[-1].task .= "b=f;";
              }
              `state.ctrlList[-1].task .=
                ".chars[`playerno]<>~setFEdge(f);"
                ".chars[`playerno]<>~setBEdge(b);";
              if(name[0] == 'v'){
                `state.ctrlList[-1].task .=
                  ".chars[`playerno]<>~setFWidth(f);"
                  ".chars[`playerno]<>~setBWidth(b);";
              }
            }
          cond .s.equ(name, "player"):
            `state.ctrlList[-1].task .= ".chars[`playerno]<>~setFWidth(";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat());";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  ".chars[`playerno]<>~setBWidth(",
                  "$.v.toFloat());")) ret false;
            }
          else:
            break, default;
          }
        case .CtrlTy::ScreenBound:
          branch{
            %char buf;
          cond .s.equ(name, "value"):
            if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
            `state.value = buf;
          cond .s.equ(name, "movecamera"):
            if(!`expression(buf=, text=)) ret false;
            buf .= "$.v";
            `state.v = buf;
            if(.s.equ(",")<, `tokenizer(text=)){
              buf.new(0);
              if(!`fullExpression(buf=, text=, "", "$.v")) ret false;
              `state.fv = buf;
            }
          else:
            break, default;
          }
        case .CtrlTy::LifeAdd:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "va=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "kill"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "k=(int)(", "$.v.isTrue());")) ret false;
          cond .s.equ(name, "absolute"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "a=(int)(", "$.v.isTrue());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::LifeSet:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`setLife(", "$.v.toInt());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::PowerAdd:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`addPower(", "$.v.toInt());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::PowerSet:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`addPower(", "$.v.toInt()-`getSharePower());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::Pause:
          branch{
          cond .s.equ(name, "time"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "t=", "$!.v.toInt();")) ret false;
            `state.ctrlList[-1].task .=
              "if(.pauseplayer==" .= .s.iToS(`playerno)
              .= "||t<.pausetime){.pausetime=t;.pauseplayer=`playerno;}";
          cond .s.equ(name, "movetime"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`trSetSysIVar(.v.setI(.iMOVETIMEPAUSE)$.v,",
                "$.v);")) ret false;
          cond .s.equ(name, "pausebg"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".pausebg=(int)(", "$.v.isTrue());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::SuperPause:
          branch{
          cond .s.equ(name, "time"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "t=", "$!.v.toInt();")) ret false;
            `state.ctrlList[-1].task .=
              "if(.superplayer==" .= .s.iToS(`playerno)
              .= "||t<.supertime){.supertime=t;.superplayer=`playerno;}";
            `state.flag = 1;
          cond .s.equ(name, "anim"):
            branch{
            cond text[0] == 'S' || text[0] == 's':
              text = text[1..-1];
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  ".superanim=`getAction (", "$.v.toInt());")) ret false;
            cond text[0] == 'F' || text[0] == 'f':
              text = text[1..-1];
              else;
            else:
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  ".superanim=.fight~getAction(", "$.v.toInt());")) ret false;
            }
          cond .s.equ(name, "sound"):
            branch{
            cond text[0] == 'F' || text[0] == 'f':
              `state.ctrlList[-1].task .= "f=true;";
            cond text[0] == 'S' || text[0] == 's':
            else:
              `state.ctrlList[-1].task .= "f=true;";
              break;
            comm:
              text = text[1..-1];
            }
            `state.ctrlList[-1].task .= "g=";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "s=", "$.v.toInt();")) ret false;
            }
          cond .s.equ(name, "pos"):
            `state.ctrlList[-1].task .=
              ".superposx=`sysfvar[.fX]+(float)`facing*";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  ".superposy=`sysfvar[.fY]+", "$.v.toFloat();")) ret false;
            }
          cond .s.equ(name, "movetime"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`trSetSysIVar(.v.setI(.iMOVETIMESUPER)$.v,",
                "$.v);")) ret false;
          cond .s.equ(name, "darken"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".superdarken=(int)(", "$.v.isTrue());")) ret false;
          cond .s.equ(name, "p2defmul"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".superp2defmul=",
                "$.v.toFloat();if(.superp2defmul==0.0)"
                ".superp2defmul=.cfg.Super_TargetDefenceMul;")) ret false;
          cond .s.equ(name, "poweradd"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`addPower(", "$.v.toInt());")) ret false;
          cond .s.equ(name, "unhittable"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".superunhittable=(int)(", "$.v.isTrue());")) ret false;
          cond .s.equ(name, "pausebg"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".superpausebg=(int)(", "$.v.isTrue());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::PlaySnd:
          branch{
          cond .s.equ(name, "value"):
            branch{
            cond text[0] == 'F' || text[0] == 'f':
              `state.ctrlList[-1].task .= "f=true;";
            cond text[0] == 'S' || text[0] == 's':
            else:
              break;
            comm:
              text = text[1..-1];
            }
            `state.ctrlList[-1].task .= "g=";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();";
            branch{
            cond .s.equ(",")<, `tokenizer(text=):
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "s=", "$.v.toInt();")) ret false;
            else:
              `state.ctrlList[-1].task .= "s=0;";
            }
          cond .s.equ(name, "volume"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "vo=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "channel"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "ch=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "lowpriority"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "lw=", "$.v.isTrue();")) ret false;
          cond .s.equ(name, "freqmul"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "fr=", "$.v.toFloat();")) ret false;
          cond .s.equ(name, "loop"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "lp=", "$.v.isTrue();")) ret false;
          cond .s.equ(name, "pan"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "p=", "$.v.toFloat();")) ret false;
          cond .s.equ(name, "abspan"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "x.new(0);p=", "$.v.toFloat();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::StopSnd:
          branch{
          cond .s.equ(name, "channel"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "branch{int i=.m.min!int?(255,",
                "$.v.toInt());cond i<0:.stopAllSound();"
                "else:"
                "`sounds.new[i].sound.new(0);}")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::SndPan:
          branch{
          cond .s.equ(name, "channel"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "ch=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "pan"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "p=", "$.v.toFloat();")) ret false;
          cond .s.equ(name, "abspan"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "x.new(0);p=", "$.v.toFloat();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::Helper:
          branch{
          cond .s.equ(name, "helpertype"):
            text = .s.toLower(text);
            switch(text[0]){
            case 'n':
              `state.ctrlList[-1].task .= "h~player=false;";
            case 'p':
              `state.ctrlList[-1].task .= "h~player=true;";
            default:
              if(!.cfg.IgnoreMostErrors){
                %char buf;
                `lasterror = (buf .= data .= "が無効な値です");
                ret false;
              }
            }
          cond .s.equ(name, "name"):
            {
              branch{
              cond #text > 0 && text[0] == '"':
                text = text[1...s.find(\", text[1..-1])+1];
              else:
                if(.s.find(\", text) >= 0){
                  `lasterror = \""が含まれています";
                  ret false;
                }
              }
              `state.ctrlList[-1].task .= "h~name="\" .= text .= \"";";
            }
          cond .s.equ(name, "id"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~helperid=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "pos"):
            `state.ctrlList[-1].task .= "x=";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "y=", "$.v.toFloat();")) ret false;
            }
          cond .s.equ(name, "postype"):
            text = .s.toLower(text);
            branch{
            cond .s.equ(text[0..2], "p2"):
              `state.ctrlList[-1].task .= "pt=1;";
            cond text[0] == 'p':
              `state.ctrlList[-1].task .= "pt=0;";
            cond text[0] == 'f':
              `state.ctrlList[-1].task .= "pt=2;";
            cond text[0] == 'b':
              `state.ctrlList[-1].task .= "pt=3;";
            cond text[0] == 'l':
              `state.ctrlList[-1].task .= "pt=4;";
            cond text[0] == 'r':
              `state.ctrlList[-1].task .= "pt=5;";
            else:
              if(!.cfg.IgnoreMostErrors){
                %char buf;
                `lasterror = (buf .= data .= "が無効な値です");
                ret false;
              }
            }
          cond .s.equ(name, "facing"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "f=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "stateno"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "st=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "keyctrl"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~keyctrl=", "$.v.isTrue();")) ret false;
          cond .s.equ(name, "ownpal"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "o=(int)(", "$.v.isTrue());")) ret false;
          cond .s.equ(name, "supermovetime"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~trSetSysIVar(.v.setI(.iSUPERMOVETIME)$.v,",
                "$.v);")) ret false;
          cond .s.equ(name, "pausemovetime"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~trSetSysIVar(.v.setI(.iPAUSEMOVETIME)$.v,",
                "$.v);")) ret false;
          cond .s.equ(name, "size.xscale"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~trSetSysFVar(.v.setI(.fXSCALE)$.v,", "$.v);")) ret false;
          cond .s.equ(name, "size.yscale"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~trSetSysFVar(.v.setI(.fYSCALE)$.v,", "$.v);")) ret false;
          cond .s.equ(name, "size.ground.back"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~trSetSysIVar(.v.setI(.iGROUND_BACK)$.v,",
                "$.v);")) ret false;
          cond .s.equ(name, "size.ground.front"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~trSetSysIVar(.v.setI(.iGROUND_FRONT)$.v,",
                "$.v);")) ret false;
          cond .s.equ(name, "size.air.back"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~trSetSysIVar(.v.setI(.iAIR_BACK)$.v,", "$.v);")) ret false;
          cond .s.equ(name, "size.air.front"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~trSetSysIVar(.v.setI(.iAIR_FRONT)$.v,", "$.v);")) ret false;
          cond .s.equ(name, "size.height"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~trSetSysIVar(.v.setI(.iHEIGHT)$.v,", "$.v);")) ret false;
          cond .s.equ(name, "size.proj.doscale"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~sysivar[.iPROJ_DOSCALE]=(int)(",
                "$.v.isTrue());")) ret false;
          cond .s.equ(name, "size.head.pos"):
            `state.ctrlList[-1].task .=
              "h~trSetSysIVar(.v.setI(.iHEAD_POSX)$.v,";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v);";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "h~trSetSysIVar(.v.setI(.iHEAD_POSY)$.v,",
                  "$.v);")) ret false;
            }
          cond .s.equ(name, "size.mid.pos"):
            `state.ctrlList[-1].task .=
              "h~trSetSysIVar(.v.setI(.iMID_POSX)$.v,";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v);";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "h~trSetSysIVar(.v.setI(.iMID_POSY)$.v,",
                  "$.v);")) ret false;
            }
          cond .s.equ(name, "size.shadowoffset"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "h~trSetSysIVar(.v.setI(.iSHADOWOFFSET)$.v,",
                "$.v);")) ret false;
          else:
            break, default;
          }
        case
          .CtrlTy::BindToParent, .CtrlTy::BindToRoot, .CtrlTy::BindToTarget
          :
          branch{
          cond .s.equ(name, "time"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`trSetSysIVar(.v.setI(.iBINDTIME)$.v,", "$.v);")) ret false;
          cond .s.equ(name, "facing"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`setBindFacing(", "$.v.toInt());"))
            {
              ret false;
            }
          cond .s.equ(name, "pos"):
            `state.ctrlList[-1].task .=
              "`trSetSysFVar(.v.setI(.fBINDPOSX)$.v,";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v);";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .=
                "`trSetSysFVar(.v.setI(.fBINDPOSY)$.v,";
              if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
              `state.ctrlList[-1].task .= "$.v);";
              if(
                .s.equ(",")<, `tokenizer(text=)
                && `state.ctrlList[-1].typ == .CtrlTy::BindToTarget)
              {
                ^/char t = `tokenizer(text=);
                if(#t == 0) break;
                switch(.s.toLowerChar(t[0])){
                case 'h':
                  `state.ctrlList[-1].task .= "hmf=2;";
                case 'm':
                  `state.ctrlList[-1].task .= "hmf=1;";
                case 'f':
                  `state.ctrlList[-1].task .= "hmf=0;";
                }
              }
            }
          cond .s.equ(name, "id"):
            if(`state.ctrlList[-1].typ != .CtrlTy::BindToTarget) else;
            `state.value = "";
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "branch{cond ",
                "$`trTarget()$#.c>0:`setBindToId(.c<>=);"
                "else:`sysivar[.iBINDTOID]=.com.IERR;}")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::TargetBind:
          branch{
          cond .s.equ(name, "time"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "t=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "id"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "i=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "pos"):
            `state.ctrlList[-1].task .= "x=";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "y=", "$.v.toFloat();")) ret false;
            }
          else:
            break, default;
          }
        case .CtrlTy::TargetFacing:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "f=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "id"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "i=", "$.v.toInt();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::TargetState:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "s=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "id"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "i=", "$.v.toInt();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::TargetVelSet, .CtrlTy::TargetVelAdd:
          branch{
            %char buf;
          cond .s.equ(name, "x"):
            if(!`fullExpression(buf=, text=, "", "$.v.toFloat()")) ret false;
            `state.v = buf;
          cond .s.equ(name, "y"):
            if(!`fullExpression(buf=, text=, "", "$.v.toFloat()")) ret false;
            `state.fv = buf;
          cond .s.equ(name, "id"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "i=", "$.v.toInt();")) ret false;
            `state.value = buf;
          else:
            break, default;
          }
        case .CtrlTy::TargetLifeAdd:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "va=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "kill"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "k=(int)(", "$.v.isTrue());")) ret false;
          cond .s.equ(name, "absolute"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "a=(int)(", "$.v.isTrue());")) ret false;
          cond .s.equ(name, "id"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "i=", "$.v.toInt();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::TargetPowerAdd:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "pw=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "id"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "i=", "$.v.toInt();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::TargetDrop:
          branch{
          cond .s.equ(name, "excludeid"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "ex=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "keepone"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "one=(int)(", "$.v.isTrue());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::HitFallSet:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "f=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "xvel"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "vx=", "$.v.toFloat();")) ret false;
          cond .s.equ(name, "yvel"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "vy=", "$.v.toFloat();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::HitVelSet:
          branch{
          cond .s.equ(name, "x"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "if(", "$.v.isTrue())`trHitVelSetX();")) ret false;
          cond .s.equ(name, "y"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "if(", "$.v.isTrue())`trHitVelSetY();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::HitOverride:
          branch{
          cond .s.equ(name, "attr"):
            {
              int flg;
              if(!`attr(flg=, text)) ret false;
              `state.ctrlList[-1].task .= "a=" .= .s.iToS(flg) .= ';';
            }
          cond .s.equ(name, "slot"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "s=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "stateno"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "st=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "time"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "t=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "forceair"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "f=(int)(", "$.v.isTrue());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::AttackDist:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`attackdist=", "$.v.toFloat();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::Explod, .CtrlTy::ModifyExplod:
          branch{
            ^/char exp =
              `state.ctrlList[-1].typ == .CtrlTy::Explod ? "e<>" : "m";
          cond .s.equ(name, "id"):
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".id=", "$.v.toInt();")) ret false;
            if(`state.ctrlList[-1].typ == .CtrlTy::Explod){
              `state.ctrlList[-1].task .=
                "if(" .= exp .= ".id<0)" .= exp .= ".id=0;";
            }
          cond .s.equ(name, "postype"):
            text = .s.toLower(text);
            branch{
            cond .s.equ(text[0..2], "p2"):
              `state.ctrlList[-1].task .= exp .= ".postype=1;";
            cond text[0] == 'p':
              `state.ctrlList[-1].task .= exp .= ".postype=0;";
            cond text[0] == 'f':
              `state.ctrlList[-1].task .= exp .= ".postype=2;";
            cond text[0] == 'b':
              `state.ctrlList[-1].task .= exp .= ".postype=3;";
            cond text[0] == 'l':
              `state.ctrlList[-1].task .= exp .= ".postype=4;";
            cond text[0] == 'r':
              `state.ctrlList[-1].task .= exp .= ".postype=5;";
            else:
              if(!.cfg.IgnoreMostErrors){
                %char buf;
                `lasterror = (buf .= text .= "が無効な値です");
                ret false;
              }
            }
          cond .s.equ(name, "pos"):
            `state.ctrlList[-1].task .= exp .= ".offsetx=";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= exp;
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  ".offsety=", "$.v.toFloat();")) ret false;
            }
          cond .s.equ(name, "facing"):
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".relativef=", "$.v.toInt()<0?-1:1;")) ret false;
          cond .s.equ(name, "vfacing"):
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".vfacing=", "$.v.toInt()<0?-1:1;")) ret false;
          cond .s.equ(name, "bindtime"):
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".bindtime=", "$.v.toInt();")) ret false;
            `state.ctrlList[-1].task .=
              "if(" .= exp .= ".bindtime>0)" .= exp .= ".bindtime++;";
          cond .s.equ(name, "vel") || .s.equ(name, "velocity"):
            `state.ctrlList[-1].task .= exp .= ".velocityx=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= exp;
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  ".velocityy=", "$.v.toFloat();")) ret false;
            }
          cond .s.equ(name, "accel"):
            `state.ctrlList[-1].task .= exp .= ".accelx=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= exp;
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  ".accely=", "$.v.toFloat();")) ret false;
            }
          cond .s.equ(name, "random"):
            `state.ctrlList[-1].task .= "rx=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "ry=", "$.v.toFloat();")) ret false;
            }
          cond .s.equ(name, "removetime"):
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".removetime=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "supermovetime"):
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".supermovetime=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "supermove"):
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".supermovetime=", "$.v.isTrue()?-1:0;")) ret false;
          cond .s.equ(name, "pausemovetime"):
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".pausemovetime=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "scale"):
            `state.ctrlList[-1].task .= exp .= ".scalex=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= exp;
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  ".scaley=", "$.v.toFloat();")) ret false;
            }
          cond .s.equ(name, "sprpriority"):
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".sprpriority=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "ontop"):
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".ontop=(int)(", "$.v.isTrue());")) ret false;
          cond .s.equ(name, "shadow"):
            `state.ctrlList[-1].task .= exp .= ".shadowr=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= exp .= ".shadowg=";
              if(
                !`expression(
                  `state.ctrlList[-1].task=, text=)) ret false;
              `state.ctrlList[-1].task .= "$.v.toInt();";
              if(.s.equ(",")<, `tokenizer(text=)){
                `state.ctrlList[-1].task .= exp;
                if(
                  !`fullExpression(
                    `state.ctrlList[-1].task=, text=,
                    ".shadowb=", "$.v.toInt();")) ret false;
              }
            }
          cond .s.equ(name, "removeongethit"):
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".removeongethit=(int)(", "$.v.isTrue());")) ret false;
          cond .s.equ(name, "trans"):
            text = .s.toLower(text);
            branch{
            cond .s.equ(text, "default"):
              `state.ctrlList[-1].task .= "t=0;";
            cond .s.equ(text, "none"):
              `state.ctrlList[-1].task .= "t=1;";
            cond .s.equ(text, "add"):
              `state.ctrlList[-1].task .= "t=2;";
            cond .s.equ(text, "addalpha"):
              `state.ctrlList[-1].task .= "t=3;";
            cond .s.equ(text, "add1"):
              `state.ctrlList[-1].task .= "t=4;";
            cond .s.equ(text, "sub"):
              `state.ctrlList[-1].task .= "t=5;";
            else:
              if(!.cfg.IgnoreMostErrors){
                %char buf;
                `lasterror = (buf .= text .= "が無効な値です");
                ret false;
              }
            }
          cond .s.equ(name, "alpha"):
            `state.ctrlList[-1].task .= exp .= ".alphas=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();" .= exp;
            branch{
            cond .s.equ(",")<, `tokenizer(text=):
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  ".alphad=", "$.v.toInt();")) ret false;
            else:
              `state.ctrlList[-1].task .= exp .= ".alphad=255;";
            }
          cond .s.equ(name, "ownpal"):
            if(`state.ctrlList[-1].typ != .CtrlTy::Explod) break, default;
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".ownpal=(int)(", "$.v.isTrue());")) ret false;
          cond .s.equ(name, "anim"):
            if(`state.ctrlList[-1].typ != .CtrlTy::Explod) break, default;
            branch{
            cond text[0] == 'F' || text[0] == 'f':
              `state.ctrlList[-1].task .= exp .= ".ani=.fight~";
            cond text[0] == 'S' || text[0] == 's':
              `state.ctrlList[-1].task .= exp .= ".ani=`";
            else:
              `state.ctrlList[-1].task .= exp .= ".ani=`";
              break;
            comm:
              text = text[1..-1];
            }
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "getAction(", "$.v.toInt());")) ret false;
          cond .s.equ(name, "sprpriority"):
            if(`state.ctrlList[-1].typ != .CtrlTy::Explod) break, default;
            `state.ctrlList[-1].task .= exp;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".sprpriority=", "$.v.toInt();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::ExplodBindTime:
          branch{
          cond .s.equ(name, "id"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "i=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "time") || .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "t=", "$.v.toInt();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::RemoveExplod:
          branch{
          cond .s.equ(name, "id"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "i=", "$.v.toInt();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::HitDef, .CtrlTy::ReversalDef, .CtrlTy::Projectile:
          if(!`hitdef(name, text=, `state.ctrlList[-1].typ)) ret false;
        case .CtrlTy::AngleDraw:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "", "$`trAngleSet();")) ret false;
          cond .s.equ(name, "scale"):
            `state.ctrlList[-1].task .=
              "`trSetSysFVar(.v.setI(.fANGLESCALEX)$.v,";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v);";
            branch{
              ^/char tmp = `tokenizer(text=);
            cond .s.equ(tmp, ","):
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "`trSetSysFVar(.v.setI(.fANGLESCALEY)$.v,",
                  "$.v);")) ret false;
            cond #tmp == 0:
              `state.ctrlList[-1].task .= "`sysfvar[.fANGLESCALEY]=1.0;";
            else:
              {
                %char buf;
                buf.new(0);
                `lasterror = (buf .= tmp .= "が不正です");
                ret false;
              }
            }
          cond .s.equ(name, "xscale"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`trSetSysFVar(.v.setI(.fANGLESCALEX)$.v,",
                "$.v);")) ret false;
          cond .s.equ(name, "yscale"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`trSetSysFVar(.v.setI(.fANGLESCALEY)$.v,",
                "$.v);")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::AngleAdd:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`trAdd(.v.setI(.fANGLE)$`trSysFVar()$.v,",
                "$.v)$`trAngleSet();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::AngleMul:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`trMul(.v.setI(.fANGLE)$`trSysFVar()$.v,",
                "$.v)$`trAngleSet();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::AngleSet:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "", "$`trAngleSet();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::Trans:
          branch{
          cond .s.equ(name, "trans"):
            text = .s.toLower(text);
            branch{
            cond .s.equ(text, "default"):
              `state.ctrlList[-1].task .=
                "t=0;`sysivar[.iSPECIALFLAG]&=!.lsTRANS;";
            cond .s.equ(text, "none"):
              `state.ctrlList[-1].task .=
                "t=1;`sysivar[.iSPECIALFLAG]|=.lsTRANS;";
            cond .s.equ(text, "add"):
              `state.ctrlList[-1].task .=
                "t=2;`sysivar[.iSPECIALFLAG]|=.lsTRANS;";
            cond .s.equ(text, "addalpha"):
              `state.ctrlList[-1].task .=
                "t=3;`sysivar[.iSPECIALFLAG]|=.lsTRANS;";
            cond .s.equ(text, "add1"):
              `state.ctrlList[-1].task .=
                "t=4;`sysivar[.iSPECIALFLAG]|=.lsTRANS;";
            cond .s.equ(text, "sub"):
              `state.ctrlList[-1].task .=
                "t=5;`sysivar[.iSPECIALFLAG]|=.lsTRANS;";
            else:
              if(!.cfg.IgnoreMostErrors){
                %char buf;
                `lasterror = (buf .= text .= "が無効な値です");
                ret false;
              }
            }
          cond .s.equ(name, "alpha"):
            `state.ctrlList[-1].task .= "`trSetSysIVar(.v.setI(.iALPHAS)$.v,";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v);";
            branch{
            cond .s.equ(",")<, `tokenizer(text=):
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "`trSetSysIVar(.v.setI(.iALPHAD)$.v,", "$.v);")) ret false;
            else:
              `state.ctrlList[-1].task .= "`sysivar[.iALPHAD]=255;";
            }
          else:
            break, default;
          }
        case .CtrlTy::Offset:
          branch{
          cond .s.equ(name, "x"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`offsetx=", "$.v.toFloat();")) ret false;
          cond .s.equ(name, "y"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`offsety=", "$.v.toFloat();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::EnvColor:
          branch{
          cond .s.equ(name, "value"):
            `state.ctrlList[-1].task .= ".envcol_r=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();";
            if(!.s.equ(",")<, `tokenizer(text=)){
              `lasterror = ",がありません";
              ret false;
            }
            `state.ctrlList[-1].task .= ".envcol_g=";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();";
            if(!.s.equ(",")<, `tokenizer(text=)){
              `lasterror = ",がありません";
              ret false;
            }
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".envcol_b=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "time"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".envcol_time=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "under"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".envcol_under=(int)(", "$.v.isTrue());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::AfterImage:
          branch{
          cond .s.equ(name, "time"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`aimg.time=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "length"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`aimg.length=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "palcolor"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`aimg.palfx~color=.m.max!float?(0.0,"
                ".m.min!float?(1.0,",
                "$.v.toFloat()/256.0));")) ret false;
          cond .s.equ(name, "palinvertall"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`aimg.palfx~invertall=(int)(",
                "$.v.isTrue());")) ret false;
          cond .s.equ(name, "palbright"):
            `state.ctrlList[-1].task .= "`aimg.palfx~addr=";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= "`aimg.palfx~addg=";
              if(
                !`expression(
                  `state.ctrlList[-1].task=, text=)) ret false;
              `state.ctrlList[-1].task .= "$.v.toInt();";
              if(.s.equ(",")<, `tokenizer(text=)){
                if(
                  !`fullExpression(
                    `state.ctrlList[-1].task=, text=,
                    "`aimg.palfx~addb=", "$.v.toInt();")) ret false;
              }
            }
          cond .s.equ(name, "palcontrast"):
            `state.ctrlList[-1].task .= "`aimg.palfx~mulr=";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat()/256.0;";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= "`aimg.palfx~mulg=";
              if(
                !`expression(
                  `state.ctrlList[-1].task=, text=)) ret false;
              `state.ctrlList[-1].task .= "$.v.toFloat()/256.0;";
              if(.s.equ(",")<, `tokenizer(text=)){
                if(
                  !`fullExpression(
                    `state.ctrlList[-1].task=, text=,
                    "`aimg.palfx~mulb=", "$.v.toFloat()/256.0;")) ret false;
              }
            }
          cond .s.equ(name, "palpostbright"):
            `state.ctrlList[-1].task .= "`aimg.postbrightr=";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= "`aimg.postbrightg=";
              if(
                !`expression(
                  `state.ctrlList[-1].task=, text=)) ret false;
              `state.ctrlList[-1].task .= "$.v.toInt();";
              if(.s.equ(",")<, `tokenizer(text=)){
                if(
                  !`fullExpression(
                    `state.ctrlList[-1].task=, text=,
                    "`aimg.postbrightb=", "$.v.toInt();")) ret false;
              }
            }
          cond .s.equ(name, "paladd"):
            `state.ctrlList[-1].task .= "`aimg.addr=";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= "`aimg.addg=";
              if(
                !`expression(
                  `state.ctrlList[-1].task=, text=)) ret false;
              `state.ctrlList[-1].task .= "$.v.toInt();";
              if(.s.equ(",")<, `tokenizer(text=)){
                if(
                  !`fullExpression(
                    `state.ctrlList[-1].task=, text=,
                    "`aimg.addb=", "$.v.toInt();")) ret false;
              }
            }
          cond .s.equ(name, "palmul"):
            `state.ctrlList[-1].task .= "`aimg.mulr=";
            if(
              !`expression(
                `state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= "`aimg.mulg=";
              if(
                !`expression(
                  `state.ctrlList[-1].task=, text=)) ret false;
              `state.ctrlList[-1].task .= "$.v.toFloat();";
              if(.s.equ(",")<, `tokenizer(text=)){
                if(
                  !`fullExpression(
                    `state.ctrlList[-1].task=, text=,
                    "`aimg.mulb=", "$.v.toFloat();")) ret false;
              }
            }
          cond .s.equ(name, "timegap") || .s.equ(name, "gap"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`aimg.timegap=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "framegap"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`aimg.framegap=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "trans"):
            text = .s.toLower(text);
            branch{
            cond .s.equ(text, "none"):
              `state.ctrlList[-1].task .= "`aimg.alphas=-1;";
            cond .s.equ(text, "add1"):
              `state.ctrlList[-1].task .= "`aimg.alphas=255;`aimg.alphad=128;";
            cond .s.equ(text[0..3], "add"):
              `state.ctrlList[-1].task .= "`aimg.alphas=255;`aimg.alphad=255;";
            cond .s.equ(text, "sub"):
              `state.ctrlList[-1].task .= "`aimg.alphas=1;`aimg.alphad=255;";
            else:
              if(!.cfg.IgnoreMostErrors){
                %char buf;
                `lasterror = (buf .= text .= "が無効な値です");
                ret false;
              }
            }
          else:
            break, default;
          }
        case .CtrlTy::AfterImageTime:
          branch{
          cond .s.equ(name, "time") || .s.equ(name, "value"):
            `state.flag = 1;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`aimg.time=", "$.v.toInt();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::PalFX, .CtrlTy::AllPalFX, .CtrlTy::BGPalFX:
          branch{
            ^/char pf =
              `state.ctrlList[-1].typ == .CtrlTy::PalFX
              ? "fx~" : (
                `state.ctrlList[-1].typ == .CtrlTy::BGPalFX
                ? ".stage.bgPalFX~" : ".com.allPalFX~");
          cond .s.equ(name, "time"):
            `state.ctrlList[-1].task .= pf;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "time=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "add"):
            `state.ctrlList[-1].task .= pf .= "addr=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= pf .= "addg=";
              if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
              `state.ctrlList[-1].task .= "$.v.toInt();";
              if(.s.equ(",")<, `tokenizer(text=)){
                `state.ctrlList[-1].task .= pf;
                if(
                  !`fullExpression(
                    `state.ctrlList[-1].task=, text=,
                    "addb=", "$.v.toInt();")) ret false;
              }
            }
          cond .s.equ(name, "mul"):
            `state.ctrlList[-1].task .= pf .= "mulr=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat()/256.0;";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= pf .= "mulg=";
              if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
              `state.ctrlList[-1].task .= "$.v.toFloat()/256.0;";
              if(.s.equ(",")<, `tokenizer(text=)){
                `state.ctrlList[-1].task .= pf;
                if(
                  !`fullExpression(
                    `state.ctrlList[-1].task=, text=,
                    "mulb=", "$.v.toFloat()/256.0;")) ret false;
              }
            }
          cond .s.equ(name, "sinadd"):
            `state.ctrlList[-1].task .= pf .= "amplr=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toInt();";
            if(.s.equ(",")<, `tokenizer(text=)){
              `state.ctrlList[-1].task .= pf .= "amplg=";
              if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
              `state.ctrlList[-1].task .= "$.v.toInt();";
              if(.s.equ(",")<, `tokenizer(text=)){
                `state.ctrlList[-1].task .= pf .= "amplb=";
                if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
                `state.ctrlList[-1].task .= "$.v.toInt();";
                if(.s.equ(",")<, `tokenizer(text=)){
                  `state.ctrlList[-1].task .= pf;
                  if(
                    !`fullExpression(
                      `state.ctrlList[-1].task=, text=,
                      "cycletime=", "$.v.toInt();")) ret false;
                }
              }
            }
          cond .s.equ(name, "invertall"):
            `state.ctrlList[-1].task .= pf;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "invertall=(int)(", "$.v.isTrue());")) ret false;
          cond .s.equ(name, "color"):
            `state.ctrlList[-1].task .= pf;
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "color=.m.max!float?(0.0,.m.min!float?(1.0,",
                "$.v.toFloat()/256.0));")) ret false;
          }
        case .CtrlTy::EnvShake:
          branch{
          cond .s.equ(name, "time"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".stage.envShake.time=", "$.v.toInt();")) ret false;
          cond .s.equ(name, "freq"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".stage.envShake.freq=.m.max!float?(0.0,(",
                "$.v.toFloat()/180.0)*.m.PI);")) ret false;
          cond .s.equ(name, "ampl"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".stage.envShake.ampl=", "$.v.toFloat();")) ret false;
          cond .s.equ(name, "phase"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                ".stage.envShake.phase=", "$.v.toFloat();")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::GameMakeAnim:
          branch{
          cond .s.equ(name, "value") || .s.equ(name, "anim"):
            branch{
            cond text[0] == 'F' || text[0] == 'f':
              `state.ctrlList[-1].task .= "e~ani=.fight~";
            cond text[0] == 'S' || text[0] == 's':
              `state.ctrlList[-1].task .= "e~ani=`";
            else:
              `state.ctrlList[-1].task .= "e~ani=.fight~";
              break;
            comm:
              text = text[1..-1];
            }
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "getAction(", "$.v.toInt());")) ret false;
          cond .s.equ(name, "under"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "e~ontop=(int)(", "$!.v.isTrue());")) ret false;
          cond .s.equ(name, "pos"):
            `state.ctrlList[-1].task .= "e~offsetx=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "e~offsety=", "$.v.toFloat();")) ret false;
            }
          cond .s.equ(name, "random"):
            `state.ctrlList[-1].task .= "rx=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "ry=", "$.v.toFloat();")) ret false;
            }
          else:
            break, default;
          }
        case .CtrlTy::HitAdd:
          branch{
          cond .s.equ(name, "value"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "`trHitAdd(", "$.v.toInt());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::DisplayToClipboard, .CtrlTy::AppendToClipboard:
          branch{
          cond .s.equ(name, "text"):
            branch{
            cond #text > 0 && text[0] == '"':
              text = text[1...s.find(\", text[1..-1])+1];
            else:
              if(.s.find(\", text) >= 0){
                `lasterror = \""が含まれています";
                ret false;
              }
            }
            `state.ctrlList[-1].task .= "text="\" .= text .= \"";";
          cond .s.equ(name, "params"):
            loop{do:
              `state.ctrlList[-1].task .= "vars.new[-1]=";
              if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
              `state.ctrlList[-1].task .= "$.v;";
            while .s.equ(",")<, `tokenizer(text=):
            }
          else:
            break, default;
          }
        case .CtrlTy::MakeDust:
          branch{
          cond .s.equ(name, "pos"):
            `state.ctrlList[-1].task .= "x=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "y=", "$.v.toFloat();")) ret false;
            }
          cond .s.equ(name, "pos2"):
            `state.ctrlList[-1].task .= "x2=";
            if(!`expression(`state.ctrlList[-1].task=, text=)) ret false;
            `state.ctrlList[-1].task .= "$.v.toFloat();";
            if(.s.equ(",")<, `tokenizer(text=)){
              if(
                !`fullExpression(
                  `state.ctrlList[-1].task=, text=,
                  "y2=", "$.v.toFloat();")) ret false;
            }
          cond .s.equ(name, "spacing"):
            if(
              !`fullExpression(
                `state.ctrlList[-1].task=, text=,
                "s=.m.max!int?(1,", "$.v.toInt());")) ret false;
          else:
            break, default;
          }
        case .CtrlTy::ForceFeedback:
        case .CtrlTy::Null:
        default:
          if(.cfg.IgnoreMostErrors) break;
          `lasterror = "無効なキー名です";
          ret false;
        }
      }
      ret true;
    }
    ^char mainbuf;
    if(
      !.com.loadFile(def, st=)<, [bool(^/char f){
        ret #(mainbuf = .file.loadAsciiText(f)) > 0;
      }])
    {
      if(.cfg.IgnoreMostErrors) ret true;
      %char buf;
      .al.alert!.self?(buf .= st .= "を読み込めません");
      ret false;
    }
    ^/char fn = st;
    %^/char lines = .com.splitLines(mainbuf);
    .s.each!^/char?([void(^/char l=){l=.s.trim(l);}], lines);
    loop{
      index i = 0, fnd;
      ^char line;
      while;
    do:
      if(
        #lines[i] <= 0 || lines[i][0] != '['
        || .s.find("]", lines[i]) < 0 ) continue;
      line = .s.toLower(lines[i]);
      fnd = .s.cFind(" ]"\t, line);
      if(fnd < 0 || !.s.equ("statedef", line[1..fnd])) continue;
      `state.no = .com.atoi(line[fnd+1..-1]);
      if(`existState(`state.no)) continue;
      `stnoList .= `state.no;
      `state.clear();
      i++;
      if(
        .s.equ(fn[0..4], "ssz/") && .s.find("..", fn) < 0
        && .s.equ(lines[i], "SSZ_CODE:"))
      {
        i++;
        loop{
          ^/char tmp;
          while;
        do:
          tmp = .s.join(.s.iToS(`state.no))<, .s.split("##", lines[i]);
          buf .= .s.join(.s.iToS(`playerno))<, .s.split("@@", tmp) .= \r\n;
          i++;
        while #lines[i] <= 0 || lines[i][0] != '[' && i < #lines:
        }
        break, while;
      }
      if(!`parse!`stateBulid:<-statedef?(lines, i=, "")){
        .errmes(fn, lines[i], i, `lasterror);
        ret false;
      }
      loop{
        int cn;
        %char fname;
        %char cbuf, dbuf;
        &.tbl.NameTable!^/char? tbl;
        ^^/char item;
        branch{
        cond `state.no < 0:
          fname .= "s_" .= .s.iToS(-`state.no);
        else:
          fname .= 's' .= .s.iToS(`state.no);
        }
        fname .= '_' .= .s.iToS(`playerno) .= 'P';
        buf .=
          "void c.Char::" .= fname .= "()"\r\n
          "{"\r\n;
        if(`state.no == -1){
          buf .= \t"if(!`ctrlOver()){"\r\n;
        }
        buf .=
          \t"bool nh = !`isHitPaused();"\r\n
          \t"byte ih;"\r\n;
        while;
      do:
        line = .s.toLower(lines[i+1]);
        fnd = .s.cFind(" ]"\t, line);
        if(.s.equ("statedef", line[1..fnd])) break;
        if(fnd < 0 || !.s.equ("state", line[1..fnd])) loop{while; do:
          i++;
          if(
            #lines[i+1] > 0 && lines[i+1][0] == '['
            && .s.find("]", lines[i+1]) >= 0) break, do;
        while i+1 < #lines && #lines[i+1] > 0:
          break, break;
        }
        i++;
        `state.tmpreset();
        `state.ctrlList.new[-1];
        i++;
        if(!`parse!`stateBulid:<-state?(lines, i=, "")){
          .errmes(fn, lines[i], i, `lasterror);
          ret false;
        }
        {
          buf .= \t"if(";
          branch{
          cond #`state.ignorehitpause > 0:
            branch{
            cond<ex> `state.ctrlList[-1].typ == .CtrlTy::Explod:
              buf .= "((ih=(int)(";
            else:
              buf .= "(nh||";
            comm:
              buf .= `state.ignorehitpause .= ".isTrue()";
            diff<ex>:
              buf .= "))!=0||nh";
            }
            buf .= ")&&";
          else:
            if(`state.ctrlList[-1].typ == .CtrlTy::Explod){
              buf .= "(ih=-1)$";
            }
            buf .= "nh&&";
          }
          if(#`state.persist > 0){
            buf .=
              "--`stVal.ps[" .= .s.iToS(#`state.ctrlList-1) .= "].p<=0&&";
          }
          branch{
          cond
            #`state.ctrlList[-1].trigger > 0
            && #`state.ctrlList[-1].trigger[0] > 0
            :
            branch{
            cond #`state.ctrlList[-1].triggerall > 0:
              branch{
              cond #`state.ctrlList[-1].triggerall > 384:
                item.new(0);
              else:
                item = tbl.get(`state.ctrlList[-1].triggerall);
              }
              if(#item == 0){
                %char tmp;
                tmp .=
                  fname .= 'c' .= .s.iToS(#`state.ctrlList-1) .= "ta";
                item.new(1);
                item<> = tmp;
                tbl.set(`state.ctrlList[-1].triggerall, item);
                cbuf .=
                  "bool c.Char::" .= item<> .= "()"\r\n
                  "{"\r\n
                  \t"ret "
                  .= `okikae(`state.ctrlList[-1].triggerall) .= ";"\r\n
                  "}"\r\n;
              }
              buf .= '`' .= item<> .= "()&&(";
            else:
              buf .= '(';
            comm:
              loop{index m = 0;while; do:
                if(#`state.ctrlList[-1].trigger[m] == 0) break;
                if(m != 0) buf .= "||";
                branch{
                cond #`state.ctrlList[-1].trigger[m] > 384:
                  item.new(0);
                else:
                  item = tbl.get(`state.ctrlList[-1].trigger[m]);
                }
                if(#item == 0){
                  %char tmp;
                  tmp .=
                    fname .= 'c' .= .s.iToS(#`state.ctrlList-1)
                    .= 't' .= .s.iToS(m+1);
                  item.new(1);
                  item<> = tmp;
                  tbl.set(`state.ctrlList[-1].trigger[m], item);
                  cbuf .=
                    "bool c.Char::" .= item<> .= "()"\r\n
                    "{"\r\n
                    \t"ret "
                    .= `okikae(`state.ctrlList[-1].trigger[m]) .= ";"\r\n
                    "}"\r\n;
                }
                buf .= '`' .= item<> .= "()";
                m++;
              while m < #`state.ctrlList[-1].trigger:
              }
            }
          else:
            buf .= "(false";
          }
          buf .= "))";
          dbuf.new(0);
          if(#`state.persist > 0) dbuf .= `state.persist .= ';';
          switch(`state.ctrlList[-1].typ){
          case .CtrlTy::ChangeAnim, .CtrlTy::ChangeAnim2:
            if(#`state.value > 0) dbuf .= "int e;";
          case .CtrlTy::ChangeState, .CtrlTy::SelfState:
            dbuf .= "int a=-1,c=-1;";
          case .CtrlTy::BindToTarget:
            if(#`state.value > 0) dbuf .= `state.value;
          }
          dbuf .= `state.ctrlList[-1].task;
          switch(`state.ctrlList[-1].typ){
          case .CtrlTy::ChangeAnim, .CtrlTy::ChangeAnim2:
            if(#`state.value > 0) dbuf .= `state.value;
          case .CtrlTy::VarSet:
            if(#`state.value > 0){
              if(#`state.v > 0){
                dbuf .=
                  (`state.flag != 0 ? "p~trSetIVar(" : "`trSetIVar(")
                  .= `state.v .= "," .= `state.value .= ");";
              }
              if(#`state.fv > 0){
                dbuf .=
                  (`state.flag != 0 ? "p~trSetFVar(" : "`trSetFVar(")
                  .= `state.fv .= "," .= `state.value .= ");";
              }
            }
          case .CtrlTy::VarAdd:
            if(#`state.value > 0){
              if(#`state.v > 0){
                dbuf .=
                  (`state.flag != 0 ? "p~trSetIVar(" : "`trSetIVar(")
                  .= `state.v .= ','
                  .= "`trAdd("
                  .= (`state.flag != 0 ? "p~trIVar()" : "`trIVar()")
                  .= "$.v," .= `state.value .= ")$.v);";
              }
              if(#`state.fv > 0){
                dbuf .=
                  (`state.flag != 0 ? "p~trSetFVar(" : "`trSetFVar(")
                  .= `state.fv .= ','
                  .= "`trAdd("
                  .= (`state.flag != 0 ? "p~trFVar()" : "`trFVar()")
                  .= "$.v," .= `state.value .= ")$.v);";
              }
            }
          case .CtrlTy::VarRangeSet:
            switch(`state.flag){
            case 1:
              dbuf .= "`rangeSetIVar(";
              branch{
              cond #`state.v > 0:
                dbuf .= `state.v .= ".toInt(),";
              else:
                dbuf .= "0,";
              }
              branch{
              cond #`state.fv > 0:
                dbuf .= `state.fv .= ".toInt(),";
              else:
                dbuf .= "59,";
              }
              dbuf .= `state.value .= ".toInt());";
            case 2:
              dbuf .= "`rangeSetFVar(";
              branch{
              cond #`state.v > 0:
                dbuf .= `state.v .= ".toInt(),";
              else:
                dbuf .= "0,";
              }
              branch{
              cond #`state.fv > 0:
                dbuf .= `state.fv .= ".toInt(),";
              else:
                dbuf .= "39,";
              }
              dbuf .= "" .= `state.value .= ".toFloat());";
            }
          case .CtrlTy::VarRandom:
            if(
              #`state.value > 0
              && #`state.v > 0 && #`state.fv > 0)
            {
              dbuf .=
                "`trSetIVar(" .= `state.value .= ",.v.setI(.m.randI("
                .= `state.v .= ',' .= `state.fv .= "))$.v);";
            }
          case .CtrlTy::HitBy, .CtrlTy::NotHitBy:
            branch{
            cond #`state.value > 0:
              switch(`state.flag){
              case 1:
                dbuf .=
                  "`stVal.hb.hitt1=" .= `state.value .= ".toInt();"
                  "if(`stVal.hb.hitt1==.com.IERR)`stVal.hb.hitt1=0;";
              case 2:
                dbuf .=
                  "`stVal.hb.hitt2=" .= `state.value .= ".toInt();"
                  "if(`stVal.hb.hitt2==.com.IERR)`stVal.hb.hitt2=0;";
              case 3:
                dbuf .=
                  "`stVal.hb.hitt1=`stVal.hb.hitt2="
                  .= `state.value .= ".toInt();"
                  "if(`stVal.hb.hitt1==.com.IERR)"
                  "`stVal.hb.hitt1=`stVal.hb.hitt2=0;";
              }
            else:
              switch(`state.flag){
              case 1:
                dbuf .= "`stVal.hb.hitt1=1;";
              case 2:
                dbuf .= "`stVal.hb.hitt2=1;";
              case 3:
                dbuf .= "`stVal.hb.hitt1=`stVal.hb.hitt2=1;";
              }
            }
          case .CtrlTy::PosFreeze:
            branch{
            cond #`state.value > 0:
              dbuf .= `state.value;
            else:
              dbuf .= "`sysivar[.iSPECIALFLAG]|=.lsPOSFREEZEX|.lsPOSFREEZEY;";
            }
          case .CtrlTy::PlayerPush:
            branch{
            cond #`state.value > 0:
              dbuf .= `state.value;
            else:
              dbuf .= "`sysivar[.iSPECIALFLAG]|=.lsPLAYERPUSH;";
            }
          case .CtrlTy::ScreenBound:
            branch{
            cond #`state.value > 0:
              dbuf .=
                "branch{cond " .= `state.value
                .= ".isTrue():`sysivar[.iSPECIALFLAG]|="
                ".lsSCREENBOUNDX|.lsSCREENBOUNDY;"
                "else:`sysivar[.iSPECIALFLAG]&="
                "!(.lsSCREENBOUNDX|.lsSCREENBOUNDY);}";
            cond #`state.v > 0 || #`state.fv > 0:
              if(#`state.v > 0){
                dbuf .=
                  "branch{cond " .= `state.v
                  .= ".isTrue():`sysivar[.iSPECIALFLAG]|=.lsSCREENBOUNDX;"
                  "else:`sysivar[.iSPECIALFLAG]&=!.lsSCREENBOUNDX;}";
              }
              if(#`state.fv > 0){
                dbuf .=
                  "branch{cond " .= `state.fv
                  .= ".isTrue():`sysivar[.iSPECIALFLAG]|=.lsSCREENBOUNDY;"
                  "else:`sysivar[.iSPECIALFLAG]&=!.lsSCREENBOUNDY;}";
              }
            else:
              dbuf .=
                "`sysivar[.iSPECIALFLAG]&=!(.lsSCREENBOUNDX|.lsSCREENBOUNDY);";
            }
          case .CtrlTy::SuperPause:
            if(`state.flag == 0){
              dbuf .=
                "if(.superplayer==" .= .s.iToS(`playerno)
                .= "||-30<.supertime){.supertime=-30;.superplayer=`playerno;}";
            }
            dbuf .= .sndend;
          case .CtrlTy::PlaySnd:
            dbuf .= .sndend;
          case .CtrlTy::SndPan:
            dbuf .=
              "if((uint)ch<0x100){"
              "`sounds.new[ch].chrx=x;"
              "`sounds.new[ch].setPan(p*(float)`facing);"
              "}";
          case .CtrlTy::Helper:
            dbuf .= "`trHelperInit(h<>=,st,pt,x,y,f,o);";
          case .CtrlTy::TargetBind:
            dbuf .= "`trTargetBind(t,i,x,y);";
          case .CtrlTy::TargetFacing:
            dbuf .= "`trTargetFacing(f,i);";
          case .CtrlTy::TargetState:
            dbuf .= "`trTargetState(" .= .s.iToS(`playerno) .= ",s,i);";
          case .CtrlTy::TargetVelSet:
            if(#`state.v > 0){
              dbuf .= "`trTargetVelSetX(i," .= `state.v .= ");";
            }
            if(#`state.fv > 0){
              dbuf .= "`trTargetVelSetY(i," .= `state.fv .= ");";
            }
          case .CtrlTy::TargetVelAdd:
            if(#`state.v > 0){
              dbuf .= "`trTargetVelAddX(i," .= `state.v .= ");";
            }
            if(#`state.fv > 0){
              dbuf .= "`trTargetVelAddY(i," .= `state.fv .= ");";
            }
          case .CtrlTy::TargetLifeAdd:
            dbuf .= "`trTargetLifeAdd(va,i,k!=0,a!=0);";
          case .CtrlTy::TargetPowerAdd:
            dbuf .= "`trTargetPowerAdd(pw,i);";
          case .CtrlTy::TargetDrop:
            dbuf .= "`trTargetDrop(ex,one);";
          case .CtrlTy::HitOverride:
            dbuf .=
              "if(st>=0&&t!=.com.IERR&&s>=0&&s<8)"
              "{`stVal.ho[s].attr=a;`stVal.ho[s].stateno=st;"
              "`stVal.ho[s].time=t;`stVal.ho[s].forceair=f;}";
          case .CtrlTy::BindToRoot:
            dbuf .= "`bind();";
          case .CtrlTy::BindToTarget:
            dbuf .= "`trBindToTarget(hmf);";
          case .CtrlTy::HitFallSet:
            dbuf .= "`trHitFallSet(f,vx,vy);";
          case .CtrlTy::ExplodBindTime:
            dbuf .= "`trExplodBindTime(i,t);";
          case .CtrlTy::RemoveExplod:
            dbuf .= "`trRemoveExplod(i);";
          case .CtrlTy::HitDef, .CtrlTy::ReversalDef, .CtrlTy::Projectile:
            dbuf .= "`setHitdefDefault";
            branch{
            cond `state.ctrlList[-1].typ == .CtrlTy::Projectile:
              dbuf .= "(pr~hit=,true);";
            else:
              dbuf .= "(`stVal.hit=,false);";
              break;
            comm:
              dbuf .=
                "if(pr~remanim<0)pr~remanim=pr~hitanim;"
                "if(pr~cancelanim<0)pr~cancelanim=pr~remanim;"
                "`trProjInit(pr<>=,pt,x,y);";
            }
          case .CtrlTy::Explod, .CtrlTy::GameMakeAnim:
            dbuf .=
              "if(e~offsetx!=.com.FERR)e~offsetx+=.m.randF(-rx,rx);"
              "if(e~offsety!=.com.FERR)e~offsety+=.m.randF(-ry,ry);"
              "e~setPos(`=);`setAlpha(t,e~alphas=,e~alphad=);"
              "`insertExplod(i," .= .s.iToS(`stconcnt) .= ");";
            if(`state.ctrlList[-1].typ == .CtrlTy::Explod){
              dbuf .= "e~ignorehitpause=ih;if(e~ontop != 0)e~sprpriority=0;";
            }
          case .CtrlTy::ModifyExplod:
            dbuf .=
              "if(m.offsetx!=.com.FERR)m.offsetx+=.m.randF(-rx,rx);"
              "if(m.offsety!=.com.FERR)m.offsety+=.m.randF(-ry,ry);"
              "`setAlpha(t,m.alphas=,m.alphad=);"
              "loop{index i=0;while;do:"
              ".explods[`playerno][i].modify(`=,m=,i++);"
              "while i<#.explods[`playerno]:}";
          case .CtrlTy::LifeAdd:
            dbuf .= "`addLife(va,k!=0,a!=0);";
          case .CtrlTy::Trans:
            dbuf .= "`setAlpha(t,`sysivar[.iALPHAS]=,`sysivar[.iALPHAD]=);";
          case .CtrlTy::AfterImage:
            dbuf .= "`aimg.setupPalfx();";
          case .CtrlTy::EnvShake:
            dbuf .= ".stage.envShake.setDefPhase();";
          case .CtrlTy::DisplayToClipboard, .CtrlTy::AppendToClipboard:
            dbuf .= ".appendToClipboard(`playerno,text,vars);";
          case .CtrlTy::AfterImageTime:
            if(`state.flag == 0) dbuf .= "`aimg.time=0;";
          case .CtrlTy::MakeDust:
            dbuf .=
            "if(`stVal.time%s!=0)ret;"
            "`makeDust(x,y);"
            "if(x2==.com.FERR||y2==.com.FERR)ret;"
            "`makeDust(x2,y2);";
          }
          branch{
          cond #dbuf > 64:
            item.new(0);
          else:
            item = tbl.get(dbuf);
          }
          if(#item == 0){
            %char tmp .= fname .= 'c' .= .s.iToS(#`state.ctrlList-1);
            item.new(1);
            item<> = tmp;
            tbl.set(dbuf, item);
            cbuf .=
              "void c.Char::" .= item<> .= (
                `state.ctrlList[-1].typ == .CtrlTy::Explod
                ? "(int ih)" :  "()")
              .= \r\n"{"\r\n\t .= `okikae(dbuf) .= \r\n"}"\r\n;
          }
          branch{
          cond<cs>
            `state.ctrlList[-1].typ == .CtrlTy::ChangeState
            || `state.ctrlList[-1].typ == .CtrlTy::SelfState
            :
            buf .= '{';
          comm:
            buf .=
              '`' .= item<> .= (
                `state.ctrlList[-1].typ == .CtrlTy::Explod ? "(ih);" : "();");
          diff<cs>:
             buf .= "ret;}";
          comm:
             buf .= \r\n;
          }
        }
      while
        i+1 < #lines && #lines[i+1] > 0 && lines[i+1][0] == '['
        && .s.find("]", lines[i+1]) >= 0
        :
      break:
        if(`state.no == -1) buf .= \t"}"\r\n;
        buf .= "}"\r\n .= cbuf;
        if(`state.no >= 0){
          buf .=
            "void c.Char::" .= fname .= "Init()"\r\n
            "{"\r\n
            \t"`state = `" .= fname .= ";"\r\n;
          if(
            `state.typ != .chr.StTy::U
            && `state.typ != .chr.StTy::A
            && `state.typ != .chr.StTy::L
            && `state.phy != .chr.StTy::U
            && `state.phy != .chr.StTy::N
            && `state.phy != .chr.StTy::A)
          {
            buf .= \t"`ifAlaSetVyZero();"\r\n;
          }
          switch(`state.typ){
          case .chr.StTy::S:
            buf .= \t"`stVal.typ = .StTy::S;"\r\n;
          case .chr.StTy::C:
            buf .= \t"`stVal.typ = .StTy::C;"\r\n;
          case .chr.StTy::A:
            buf .= \t"`stVal.typ = .StTy::A;"\r\n;
          case .chr.StTy::L:
            buf .= \t"`stVal.typ = .StTy::L;"\r\n;
          }
          switch(`state.phy){
          case .chr.StTy::S:
            buf .= \t"`stVal.phy = .StTy::S;"\r\n;
          case .chr.StTy::C:
            buf .= \t"`stVal.phy = .StTy::C;"\r\n;
          case .chr.StTy::A:
            buf .= \t"`stVal.phy = .StTy::A;"\r\n;
          case .chr.StTy::N:
            buf .= \t"`stVal.phy = .StTy::N;"\r\n;
          }
          if(#`state.ctrlList > 0){
            buf .=
              \t"`stVal.ps.new("
              .= .s.iToS(#`state.ctrlList) .= ");"\r\n
              \t"loop{index i = 0; do:"\r\n
              \t\t"`stVal.ps[i].p = 0;"\r\n
              \t"while ++i < " .= .s.iToS(#`state.ctrlList) .= ":"\r\n
              \t"}"\r\n;
          }
          if(#`state.deftask > 0){
             buf .= '\t' .= `okikae(`state.deftask) .= \r\n;
          }
          if(`state.hitcountpersist == 0){
            buf .= \t"`clearHitCount();"\r\n;
          }
          if(`state.hitdefpersist == 0){
            buf .= \t"`clearHitDef();"\r\n;
          }
          if(`state.movehitpersist == 0){
            buf .= \t"`stVal.mctime = 0;"\r\n;
          }
          if(`state.juggle == 0) buf .= \t"`stVal.juggle = 0;"\r\n;
          buf .=
            "}"\r\n
            "void c.Char::" .= fname .= "Set()"\r\n
            "{"\r\n
            \t"`state = `" .= fname .= "Init;"\r\n;
          switch(`state.mov){
          case .chr.MovTy::I:
            buf .= \t"`stVal.mov = .MovTy::I;"\r\n;
          case .chr.MovTy::A:
            buf .= \t"`stVal.mov = .MovTy::A;"\r\n;
          case .chr.MovTy::H:
            buf .= \t"`stVal.mov = .MovTy::H;"\r\n;
          }
          buf .= "}"\r\n;
        }
      }
    continue:
      i++;
    while i < #lines:
    }
    ret true;
  }
  public bool build(int no, ^/char def)
  {:<-
    public bool files(^/char sec, ^/char name, ^/char data)
    {
      type _t = .com.readFileName;
      branch{
      cond .s.equ(name, "cmd"):
        if(#`cmd == 0) `cmd = _t(data);
      cond .s.equ(name, "cns"):
        if(#`cns == 0) `cns = _t(data);
      cond .s.equ(name, "st"):
        if(#`st.new[0] == 0) `st[0] = _t(data);
      cond .s.equ(name, "st0"):
        if(#`st.new[1] == 0) `st[1] = _t(data);
      cond .s.equ(name, "st1"):
        if(#`st.new[2] == 0) `st[2] = _t(data);
      cond .s.equ(name, "st2"):
        if(#`st.new[3] == 0) `st[3] = _t(data);
      cond .s.equ(name, "st3"):
        if(#`st.new[4] == 0) `st[4] = _t(data);
      cond .s.equ(name, "st4"):
        if(#`st.new[5] == 0) `st[5] = _t(data);
      cond .s.equ(name, "st5"):
        if(#`st.new[6] == 0) `st[6] = _t(data);
      cond .s.equ(name, "st6"):
        if(#`st.new[7] == 0) `st[7] = _t(data);
      cond .s.equ(name, "st7"):
        if(#`st.new[8] == 0) `st[8] = _t(data);
      cond .s.equ(name, "st8"):
        if(#`st.new[9] == 0) `st[9] = _t(data);
      cond .s.equ(name, "st9"):
        if(#`st.new[10] == 0) `st[10] = _t(data);
      cond .s.equ(name, "stcommon"):
        if(#`stcommon == 0) `stcommon = _t(data);
      }
      ret true;
    }
    void section(%^/char lines, index i=)
    {
      ^/char sec = lines[i];
      ^/char secname = .com.sectionName(sec=);
      if(#secname == 0) ret;
      i++;
      branch{
      cond .s.equ(secname, "files"):
        `parse!`build:<-files?(lines, i=, sec);
      }
    }
    public bool data(^/char sec, ^/char name, ^/char data)
    {
      branch{
      cond .s.equ(name, "life"):
        `c.d.life = .s.sToN!`c.d.life.self?(data);
      cond .s.equ(name, "power"):
        `c.d.power = .s.sToN!`c.d.power.self?(data);
      cond .s.equ(name, "attack"):
        `c.d.attack = .s.sToN!`c.d.attack.self?(data);
      cond .s.equ(name, "defence"):
        `c.d.defence = .s.sToN!`c.d.defence.self?(data);
      cond .s.equ(name, "fall.defence_up"):
        `c.d.fall_defence_mul =
          (.s.sToN!`c.d.fall_defence_mul.self?(data)+100.0) / 100.0;
      cond .s.equ(name, "liedown.time"):
        `c.d.liedown_time =
          .m.max!int?(1)<, .s.sToN!`c.d.liedown_time.self?(data);
      cond .s.equ(name, "airjuggle"):
        `c.d.airjuggle = .s.sToN!`c.d.airjuggle.self?(data);
      cond .s.equ(name, "sparkno"):
        `c.d.sparkno = .s.sToN!`c.d.sparkno.self?(data);
      cond .s.equ(name, "guard.sparkno"):
        `c.d.guard_sparkno = .s.sToN!`c.d.guard_sparkno.self?(data);
      cond .s.equ(name, "ko.echo"):
        `c.d.ko_echo = .s.sToN!`c.d.ko_echo.self?(data);
      cond .s.equ(name, "volume"):
        `c.d.volume = .s.sToN!`c.d.volume.self?(data);
      cond .s.equ(name, "intpersistindex"):
        `c.d.intpersistindex = .s.sToN!`c.d.intpersistindex.self?(data);
      cond .s.equ(name, "floatpersistindex"):
        `c.d.floatpersistindex =
          .s.sToN!`c.d.floatpersistindex.self?(data);
      }
      ret true;
    }
    public bool size(^/char sec, ^/char name, ^/char data)
    {
      branch{
      cond .s.equ(name, "xscale"):
        {
          ^float ary = .s.svToAry!float?(",", data);
          `c.s.xscale = ary<>;
        }
      cond .s.equ(name, "yscale"):
        {
          ^float ary = .s.svToAry!float?(",", data);
          `c.s.yscale = ary<>;
        }
      cond .s.equ(name, "ground.back"):
        `c.s.ground_back = .s.sToN!`c.s.ground_back.self?(data);
      cond .s.equ(name, "ground.front"):
        `c.s.ground_front = .s.sToN!`c.s.ground_front.self?(data);
      cond .s.equ(name, "air.back"):
        `c.s.air_back = .s.sToN!`c.s.air_back.self?(data);
      cond .s.equ(name, "air.front"):
        `c.s.air_front = .s.sToN!`c.s.air_front.self?(data);
      cond .s.equ(name, "height"):
        `c.s.height = .s.sToN!`c.s.height.self?(data);
      cond .s.equ(name, "attack.dist"):
        `c.s.attack_dist = .s.sToN!`c.s.attack_dist.self?(data);
      cond .s.equ(name, "proj.attack.dist"):
        `c.s.proj_attack_dist = .s.sToN!`c.s.proj_attack_dist.self?(data);
      cond .s.equ(name, "proj.doscale"):
        `c.s.proj_doscale = .s.sToN!`c.s.proj_doscale.self?(data);
      cond .s.equ(name, "head.pos"):
        .com.readPair!int?(`c.s.head_posx=, `c.s.head_posy=, data);
      cond .s.equ(name, "mid.pos"):
        .com.readPair!int?(`c.s.mid_posx=, `c.s.mid_posy=, data);
      cond .s.equ(name, "shadowoffset"):
        `c.s.shadowoffset = .s.sToN!`c.s.shadowoffset.self?(data);
      cond .s.equ(name, "draw.offset"):
        .com.readPair!int?(`c.s.draw_offsetx=, `c.s.draw_offsety=, data);
      }
      ret true;
    }
    public bool velocity(
      ^/char sec, ^/char name, ^/char data)
    {
      float dummy;
      branch{
      cond .s.equ(name, "walk.fwd"):
        .com.readPair!float?(`c.v.walk_fwd=, dummy=, data);
      cond .s.equ(name, "walk.back"):
        .com.readPair!float?(`c.v.walk_back=, dummy=, data);
      cond .s.equ(name, "run.fwd"):
        .com.readPair!float?(`c.v.run_fwdx=, `c.v.run_fwdy=, data);
      cond .s.equ(name, "run.back"):
        .com.readPair!float?(`c.v.run_backx=, `c.v.run_backy=, data);
      cond .s.equ(name, "jump.neu"):
        .com.readPair!float?(`c.v.jump_neux=, `c.v.jump_neuy=, data);
      cond .s.equ(name, "jump.back"):
        .com.readPair!float?(`c.v.jump_back=, dummy=, data);
      cond .s.equ(name, "jump.fwd"):
        .com.readPair!float?(`c.v.jump_fwd=, dummy=, data);
      cond .s.equ(name, "runjump.back"):
        .com.readPair!float?(`c.v.runjump_backx=, `c.v.runjump_backy=, data);
      cond .s.equ(name, "runjump.fwd"):
        .com.readPair!float?(`c.v.runjump_fwdx=, `c.v.runjump_fwdy=, data);
      cond .s.equ(name, "airjump.neu"):
        .com.readPair!float?(`c.v.airjump_neux=, `c.v.airjump_neuy=, data);
      cond .s.equ(name, "airjump.back"):
        .com.readPair!float?(`c.v.airjump_back=, dummy=, data);
      cond .s.equ(name, "airjump.fwd"):
        .com.readPair!float?(`c.v.airjump_fwd=, dummy=, data);
      }
      ret true;
    }
    public bool movement(
      ^/char sec, ^/char name, ^/char data)
    {
      branch{
      cond .s.equ(name, "airjump.num"):
        `c.m.airjump_num = .s.sToN!`c.m.airjump_num.self?(data);
      cond .s.equ(name, "airjump.height"):
        `c.m.airjump_height = .s.sToN!`c.m.airjump_height.self?(data);
      cond .s.equ(name, "yaccel"):
        `c.m.yaccel = .s.sToN!`c.m.yaccel.self?(data);
      cond .s.equ(name, "stand.friction"):
        `c.m.stand_friction = .s.sToN!`c.m.stand_friction.self?(data);
      cond .s.equ(name, "crouch.friction"):
        `c.m.crouch_friction = .s.sToN!`c.m.crouch_friction.self?(data);
      }
      ret true;
    }
    void cns(%^/char lines, index i=)
    {
      ^/char sec = lines[i];
      ^/char secname = .com.sectionName(sec=);
      if(#secname == 0) ret;
      i++;
      branch{
      cond .s.equ(secname, "data"):
        `parse!`build:<-data?(lines, i=, sec);
      cond .s.equ(secname, "size"):
        `parse!`build:<-size?(lines, i=, sec);
        if(`c.s.proj_doscale != 0){
          `c.s.proj_xscale = `c.s.xscale;
          `c.s.proj_yscale = `c.s.yscale;
        }
      cond .s.equ(secname, "velocity"):
        `parse!`build:<-velocity?(lines, i=, sec);
      cond .s.equ(secname, "movement"):
        `parse!`build:<-movement?(lines, i=, sec);
      }
    }
    `playerno = no;
    `cmd = "";
    `cns = "";
    `st.new(0);
    `stcommon = "";
    ^char mainbuf = .file.loadAsciiText(def);
    %^/char lines = .com.splitLines(mainbuf);
    .s.each!^/char?([void(^/char l=){l=.s.trim(l);}], lines);
    loop{index i = 0; while; do:
      section(lines, i=);
      i++;
    while i < #lines:
    }
    if(
      !.com.loadFile(def, `cns=)<, [bool(^/char f){
        ret (mainbuf = .file.loadAsciiText(f))$#mainbuf > 0;}])
    {
      %char buf;
      .al.alert!.self?(buf .= `cns .= "を読み込めません");
      ret false;
    }
    lines = .com.splitLines(mainbuf);
    .s.each!^/char?([void(^/char l=){l=.s.trim(l);}], lines);
    `c.reset();
    loop{index i = 0; while; do:
      cns(lines, i=);
      i++;
    while i < #lines:
    }
    `stnoList.new(0);
    %char buf;
    buf .= \xfeff"lib c = "\""char.ssz"\"";"\r\n;
    if(!`stateBulid(buf=, def, `cmd=)) ret false;
    loop{index i = 0; while; do:
      if(#`st[i] > 0 && !`stateBulid(buf=, def, `st[i]=)) ret false;
      i++;
    while i < #`st:
    }
    if(#`stcommon > 0 && !`stateBulid(buf=, def, `stcommon=)) ret false;
    ^/char minus = "ssz/minus.cns";
    if(!`stateBulid(buf=, def, minus=)) ret false;
    buf .=
      "public void c.Char::stateInit" .= .s.iToS(`playerno) .= "P()"\r\n
      "{"\r\n
      \t"`sysfvar[.fX] = 0.0;"\r\n
      \t"`sysfvar[.fY] = 0.0;"\r\n
      \t"`sysfvar[.fVX] = 0.0;"\r\n
      \t"`sysfvar[.fVY] = 0.0;"\r\n
      \t"`sysivar[.iLIFEMAX] = " .= .s.iToS(`c.d.life) .= ";"\r\n
      \t"`sysivar[.iPOWERMAX] = " .= .s.iToS(`c.d.power) .= ";"\r\n
      \t"`sysivar[.iATTACK] = " .= .s.iToS(`c.d.attack) .= ";"\r\n
      \t"`sysivar[.iDEFENCE] = " .= .s.iToS(`c.d.defence) .= ";"\r\n
      \t"`sysfvar[.fFALL_DEFENCE_MUL] = "
      .= `fToS(`c.d.fall_defence_mul) .= ";"\r\n
      \t"`sysivar[.iLIEDOWN_TIME] = "
      .= .s.iToS(`c.d.liedown_time) .= ";"\r\n
      \t"`sysivar[.iAIRJUGGLE] = "
      .= .s.iToS(`c.d.airjuggle) .= ";"\r\n
      \t"`sysivar[.iSPARKNO] = "
      .= (`c.d.sparkno >= 0 ? .s.iToS(`c.d.sparkno) : "!.com.IERR")
      .= ";"\r\n
      \t"`sysivar[.iGUARD_SPARKNO] = " .= (
        `c.d.guard_sparkno >= 0
        ? .s.iToS(`c.d.guard_sparkno) : "!.com.IERR") .= ";"\r\n
      \t"`sysivar[.iKO_ECHO] = " .= .s.iToS(`c.d.ko_echo) .= ";"\r\n
      \t"`sysivar[.iVOLUME] = " .= .s.iToS(`c.d.volume) .= ";"\r\n
      \t"`sysivar[.iINTPERSISTINDEX] = "
      .= .s.iToS(`c.d.intpersistindex) .= ";"\r\n
      \t"`sysivar[.iFLOATPERSISTINDEX] = "
      .= .s.iToS(`c.d.floatpersistindex) .= ";"\r\n
      \t"`sysfvar[.fXSCALE] = " .= `fToS(`c.s.xscale) .= ";"\r\n
      \t"`sysfvar[.fYSCALE] = " .= `fToS(`c.s.yscale) .= ";"\r\n
      \t"`sysivar[.iGROUND_BACK] = "
      .= .s.iToS(`c.s.ground_back) .= ";"\r\n
      \t"`sysivar[.iGROUND_FRONT] = "
      .= .s.iToS(`c.s.ground_front) .= ";"\r\n
      \t"`sysivar[.iAIR_BACK] = " .= .s.iToS(`c.s.air_back) .= ";"\r\n
      \t"`sysivar[.iAIR_FRONT] = "
      .= .s.iToS(`c.s.air_front) .= ";"\r\n
      \t"`sysivar[.iHEIGHT] = " .= .s.iToS(`c.s.height) .= ";"\r\n
      \t"`sysivar[.iATTACK_DIST] = "
      .= .s.iToS(`c.s.attack_dist) .= ";"\r\n
      \t"`sysivar[.iPROJ_ATTACK_DIST] = "
      .= .s.iToS(`c.s.proj_attack_dist) .= ";"\r\n
      \t"`sysivar[.iPROJ_DOSCALE] = "
      .= .s.iToS(`c.s.proj_doscale) .= ";"\r\n
      \t"`sysivar[.iHEAD_POSX] = "
      .= .s.iToS(`c.s.head_posx) .= ";"\r\n
      \t"`sysivar[.iHEAD_POSY] = "
      .= .s.iToS(`c.s.head_posy) .= ";"\r\n
      \t"`sysivar[.iMID_POSX] = " .= .s.iToS(`c.s.mid_posx) .= ";"\r\n
      \t"`sysivar[.iMID_POSY] = " .= .s.iToS(`c.s.mid_posy) .= ";"\r\n
      \t"`sysivar[.iSHADOWOFFSET] = "
      .= .s.iToS(`c.s.shadowoffset) .= ";"\r\n
      \t"`sysivar[.iDRAW_OFFSETX] = "
      .= .s.iToS(`c.s.draw_offsetx) .= ";"\r\n
      \t"`sysivar[.iDRAW_OFFSETY] = "
      .= .s.iToS(`c.s.draw_offsety) .= ";"\r\n
      \t"`sysfvar[.fWALK_FWD] = " .= `fToS(`c.v.walk_fwd) .= ";"\r\n
      \t"`sysfvar[.fWALK_BACK] = "
      .= `fToS(`c.v.walk_back) .= ";"\r\n
      \t"`sysfvar[.fRUN_FWDX] = " .= `fToS(`c.v.run_fwdx) .= ";"\r\n
      \t"`sysfvar[.fRUN_FWDY] = " .= `fToS(`c.v.run_fwdy) .= ";"\r\n
      \t"`sysfvar[.fRUN_BACKX] = "
      .= `fToS(`c.v.run_backx) .= ";"\r\n
      \t"`sysfvar[.fRUN_BACKY] = "
      .= `fToS(`c.v.run_backy) .= ";"\r\n
      \t"`sysfvar[.fJUMP_NEUX] = "
      .= `fToS(`c.v.jump_neux) .= ";"\r\n
      \t"`sysfvar[.fJUMP_NEUY] = "
      .= `fToS(`c.v.jump_neuy) .= ";"\r\n
      \t"`sysfvar[.fJUMP_BACK] = "
      .= `fToS(`c.v.jump_back) .= ";"\r\n
      \t"`sysfvar[.fJUMP_FWD] = " .= `fToS(`c.v.jump_fwd) .= ";"\r\n
      \t"`sysfvar[.fRUNJUMP_BACKX] = "
      .= `fToS(`c.v.runjump_backx) .= ";"\r\n
      \t"`sysfvar[.fRUNJUMP_BACKY] = "
      .= `fToS(`c.v.runjump_backy) .= ";"\r\n
      \t"`sysfvar[.fRUNJUMP_FWDX] = "
      .= `fToS(`c.v.runjump_fwdx) .= ";"\r\n
      \t"`sysfvar[.fRUNJUMP_FWDY] = "
      .= `fToS(`c.v.runjump_fwdy) .= ";"\r\n
      \t"`sysfvar[.fAIRJUMP_NEUX] = "
      .= `fToS(`c.v.airjump_neux) .= ";"\r\n
      \t"`sysfvar[.fAIRJUMP_NEUY] = "
      .= `fToS(`c.v.airjump_neuy) .= ";"\r\n
      \t"`sysfvar[.fAIRJUMP_BACK] = "
      .= `fToS(`c.v.airjump_back) .= ";"\r\n
      \t"`sysfvar[.fAIRJUMP_FWD] = "
      .= `fToS(`c.v.airjump_fwd) .= ";"\r\n
      \t"`sysivar[.iAIRJUMP_CNT] = 0;"\r\n
      \t"`sysivar[.iAIRJUMP_NUM] = "
      .= .s.iToS(`c.m.airjump_num) .= ";"\r\n
      \t"`sysivar[.iAIRJUMP_HEIGHT] = "
      .= .s.iToS(`c.m.airjump_height) .= ";"\r\n
      \t"`sysfvar[.fYACCEL] = " .= `fToS(`c.m.yaccel) .= ";"\r\n
      \t"`sysfvar[.fSTAND_FRICTION] = "
      .= `fToS(`c.m.stand_friction) .= ";"\r\n
      \t"`sysfvar[.fCROUCH_FRICTION] = "
      .= `fToS(`c.m.crouch_friction) .= ";"\r\n
      \t"`state_1 = `s_1_" .= .s.iToS(`playerno) .= "P;"\r\n
      \t"`state_2 = `s_2_" .= .s.iToS(`playerno) .= "P;"\r\n
      \t"`state_3 = `s_3_" .= .s.iToS(`playerno) .= "P;"\r\n
      \t"`state_4 = `s_4_" .= .s.iToS(`playerno) .= "P;"\r\n
      \t"`clearSpSysVar();"\r\n
      \t"`cmd.bufReset(`key);"\r\n
      "}"\r\n;
    {
      &.file.File f;
      %char fn;
      f.open(fn .= "ssz/state" .= .s.iToS(`playerno) .= "p.ssz", "wb");
      f.writeAry!ubyte?(.s.sToU8(buf));
    }
    ret true;
  }
}


