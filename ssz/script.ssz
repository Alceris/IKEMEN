

lib tbl = <table.ssz>;
lib s = <string.ssz>;
lib consts = <consts.ssz>;
lib se = <alpha/sdlevent.ssz>;
lib file = <file.ssz>;
lib sdl = <alpha/sdlplugin.ssz>;
lib mes = <alpha/mesdialog.ssz>;
lib m = <math.ssz>;
lib soc = <socket.ssz>;
lib sff = "sff.ssz";
lib bg = "bg.ssz";
lib cmd = "command.ssz";
lib fnt = "font.ssz";
lib com = "common.ssz";
lib cfg = "config.ssz";
lib snd = "sound.ssz";
lib chr = "char.ssz";
lib lua = <alpha/lua.ssz>;
lib sys = "system.ssz";


^/char listenPort = "7500";

public &sys.System syst;


public double numArg(&.lua.State L=, int re=, int argc=, int nresults)
{
  double num = 0.0;
  argc++;
  if(!L.isNumber(argc)){
    L.pushString(.s.iToS(argc) + "番目の引数が数ではありません。");
    re = -1;
    ret num;
  }
  num = L.toNumber(argc);
  re = nresults;
  ret num;
}

public bool blArg(&.lua.State L=, int re=, int argc=, int nresults)
{
  bool b = false;
  argc++;
  if(!L.isBoolean(argc)){
    L.pushString(.s.iToS(argc) + "番目の引数が論理値ではありません。");
    re = -1;
    ret b;
  }
  b = L.toBoolean(argc);
  re = nresults;
  ret b;
}

public ^char strArg(&.lua.State L=, int re=, int argc=, int nresults)
{
  ^char str;
  argc++;
  if(!L.isString(argc)){
    L.pushString(.s.iToS(argc) + "番目の引数が文字列ではありません。");
    re = -1;
    ret str;
  }
  str = L.toString(argc);
  re = nresults;
  ret str;
}

public ..refArg<_t>(&.lua.State L=, int re=, int argc=, int nresults) ^_t
{
  ^_t obj;
  argc++;
  ref r = L.toRef(argc);
  r.cast(obj=);
  if(#obj == 0){
    L.pushString(.s.iToS(argc) + "番目の引数が不正です。");
    re = -1;
    ret obj;
  }
  re = nresults;
  ret obj;
}

public &Sff
{
  ^&.sff.Sff sff;
  public ^&.sff.Sff getSff()
  {
    ret `sff;
  }
  public bool load(^/char file)
  {
    `sff.new(1);
    ret `sff~loadFile(file, false);
  }
}
void sffNew(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^/char file = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^&.Sff sff.new(1);
  if(!sff~load(file)){
    L.pushString(file + "のロードに失敗しました。");
    re = -1;
    ret;
  }
  L.pushRef(sff);
}


public &Snd
{
  ^&.snd.Snd snd;
  public ^&.snd.Snd getSnd()
  {
    ret `snd;
  }
  public bool load(^/char file)
  {
    `snd.new(1);
    ret `snd~loadFile(file);
  }
  public bool play(int g, int n)
  {
    if(#`snd == 0) ret false;
    ^&.snd.Sound c = .snd.getChannel(-1);
    if(#c == 0) ret false;
    c~sound = `snd~getSound(g, n);
    ret #c~sound > 0;
  }
}
void sndNew(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^/char file = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^&.Snd snd.new(1);
  if(!snd~load(file)){
    L.pushString(file + "のロードに失敗しました。");
    re = -1;
    ret;
  }
  L.pushRef(snd);
}
void sndPlay(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Snd snd = .refArg!&.Snd?(L=, re=, argc=, nret); if(re < 0) ret;
  int g = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int n = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  snd~play(g, n);
}


public &Font
{
  ^&.fnt.Font fnt;
  public ^&.fnt.Font getFont()
  {
    ret `fnt;
  }
  public bool load(^/char file)
  {
    `fnt.new(1);
    ret `fnt~loadFile(file);
  }
}
void fontNew(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^/char file = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^&.Font font.new(1);
  if(!font~load(file)){
    L.pushString(file + "のロードに失敗しました。");
    re = -1;
    ret;
  }
  L.pushRef(font);
}


public &Command
{
  ^&.cmd.CommandList cmd;
  new()
  {
    `cmd.new(1);
    `cmd~buffer.new(1);
  }
  public void input(int pn)
  {
    `cmd~step(pn-1, 1, false, false);
  }
  public bool getState(^/char name)
  {
    ^&.cmd.Command cl = `cmd~get(name);
    loop{index i = 0; while; do:
      if(cl[i].curbuftime > 0) ret true;
      i++;
    while i < #cl:
    }
    ret false;
  }
  public void addCommand(^/char name, ^/char com, int time)
  {
    &.cmd.Command c;
    c.name = name;
    .cmd.resetReadKeymap();
    c.readCmd(com);
    c.time = time;
    `cmd~add(c=);
  }
  public void bufReset(int pn)
  {
    `cmd~bufReset(pn-1);
  }
}
void commandNew(&.lua.State L=, int re=)
{
  re = 1;
  ^&.Command command.new(1);
  L.pushRef(command);
}
void commandAdd(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Command command = .refArg!&.Command?(L=, re=, argc=, nret);
  if(re < 0) ret;
  ^/char name = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^/char com = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  int time = 1;
  if(L.getTop() > argc){
    time = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  command~addCommand(name, com, time);
}
void commandGetState(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^&.Command command = .refArg!&.Command?(L=, re=, argc=, nret);
  if(re < 0) ret;
  ^/char name = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  L.pushBoolean(command~getState(name));
}
void commandInput(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Command command = .refArg!&.Command?(L=, re=, argc=, nret);
  if(re < 0) ret;
  int pn = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  command~input(pn);
}
void commandBufReset(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Command command = .refArg!&.Command?(L=, re=, argc=, nret);
  if(re < 0) ret;
  int pn = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  command~bufReset(pn);
}


public &TextImg
{
  ^/char text;
  ^&.fnt.Font fnt;
  int bank = 0, align = 0;
  float x = 0.0, y = 0.0;
  float xscl = 1.0, yscl = 1.0;
  public void setFont(^&.fnt.Font fo)
  {
    `fnt = fo;
  }
  public void draw()
  {
    if(.se.fskip || #`fnt == 0) ret;
    `fnt~drawText(`x, `y, `xscl, `yscl, `bank, `align, `text);
  }
  public void setText(^/char t)
  {
    `text = t;
  }
  public void setBank(int b)
  {
    `bank = b;
  }
  public void setAlign(int a)
  {
    `align = a;
  }
  public void setPos(float x, float y)
  {
    `x = x;
    `y = y;
  }
  public void setScale(float x, float y)
  {
    `xscl = x;
    `yscl = y;
  }
}
void textImgNew(&.lua.State L=, int re=)
{
  re = 1;
  ^&.TextImg textImg.new(1);
  L.pushRef(textImg);
}
void textImgSetFont(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  ^&.Font font = .refArg!&.Font?(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setFont(font~getFont());
}
void textImgSetBank(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  int b = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setBank(b);
}
void textImgSetAlign(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  int a = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setAlign(a);
}
void textImgSetText(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  ^/char text = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setText(text);
}
void textImgSetPos(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  float x = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setPos(x, y);
}
void textImgSetScale(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  float x = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setScale(x, y);
}
void textImgDraw(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  textImg~draw();
}


public &Anim
{
  ^&.sff.Anim!&.bg.Frame? ani;
  &.sdl.Rect window;
  float x = 0.0, y = 0.0;
  float xscl = 1.0, yscl = 1.0;
  new()
  {
    `ani.new(1);
    `ani~mask = 0;
    `window = .com.scrrect;
  }
  public void setSff(^&.sff.Sff sf)
  {
    `ani~sff = sf;
  }
  public bool setAction(^/char str)
  {
    ^^/char lines = .s.splitLines(str);
    index i = 0;
    &.bg.Action act;
    act.read(lines, i=);
    `ani~reset();
    `ani~setFrames(act.frames, act.loopstart);
    ret #act.frames > 0;
  }
  public int animTime()
  {
    ret `ani~animTime();
  }
  public void update()
  {
    `ani~action();
  }
  public void draw()
  {
    if(.se.fskip) ret;
    `ani~draw(
      `window=, `x + (float)(.com.GameWidth-320)/2.0,
      `y + (float)(.com.GameHeight-240), 1.0, 1.0,
      `xscl, `xscl, `yscl, 0.0, 0.0, .consts.null!&.com.PalFX?(), false); 
  }
  public void setPos(float x, float y)
  {
    `x = x;
    `y = y;
  }
  public void addPos(float x, float y)
  {
    `x += x;
    `y += y;
  }
  public void setScale(float x, float y)
  {
    `xscl = x;
    `yscl = y;
  }
  public void setTile(ushort x, ushort y)
  {
    `ani~tile.w = x;
    `ani~tile.h = y;
  }
  public void setColorKey(int ck)
  {
    `ani~mask = ck;
  }
  public void setAlpha(short sa, short da)
  {
    `ani~salpha = sa;
    `ani~dalpha = da;
  }
  public void setWindow(float x, float y, float w, float h)
  {
    `window.x = (short)((x+(float)(.com.GameWidth-320)/2.0)*.com.WidthScale);
    `window.y = (short)((y+(float)(.com.GameHeight-240))*.com.HeightScale);
    `window.w = (ushort)(w * .com.WidthScale + 0.5);
    `window.h = (ushort)(h * .com.HeightScale + 0.5);
  }
}
void animNew(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^&.Anim anim.new(1);
  ^&.Sff sff = .refArg!&.Sff?(L=, re=, argc=, nret); if(re < 0) ret;
  ^/char action = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setSff(sff~getSff());
  if(!anim~setAction(action)){
    L.pushString(
      \r\n + action[0..4096] + \r\n\r\n"データの読み込みに失敗しました。");
    re = -1;
    ret;
  }
  L.pushRef(anim);
}
void animSetPos(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setPos(x, y);
}
void animAddPos(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~addPos(x, y);
}
void animSetTile(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  uint x = (uint).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  uint y = (uint).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setTile(x, y);
}
void animSetColorKey(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  int ck = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setColorKey(ck);
}
void animSetAlpha(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  int x = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int y = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setAlpha(x, y);
}
void animSetScale(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setScale(x, y);
}
void animSetWindow(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float w = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float h = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setWindow(x, y, w, h);
}
void animUpdate(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  anim~update();
}
void animDraw(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  anim~draw();
}


void inputThread(^/char title, ^^char str, ^bool done)
{
  .mes.InputStr(:title, str<>=:);
  done<> = true;
}
public &InputDialog
{
  thread!.inputThread? inth;
  ^^char str;
  ^bool done;
  new()
  {
    `str.new(1);
    `done.new(1);
    `done<> = true;
  }
  public bool popup(^/char title)
  {
    if(!`done<>) ret false;
    .sdl.fullScreen(.se.full = false);
    `done<> = false;
    `inth..(title, `str, `done);
    ret true;
  }
  public bool isDone()
  {
    ret `done<>;
  }
  public ^char getStr()
  {
    if(!`done<>) ret .consts.null!char?();
    ret `str<>;
  }
}
void inputDialogNew(&.lua.State L=, int re=)
{
  re = 1;
  ^&.InputDialog inputDialog.new(1);
  L.pushRef(inputDialog);
}
void inputDialogPopup(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.InputDialog inputDialog = .refArg!&.InputDialog?(L=, re=, argc=, nret);
  if(re < 0) ret;
  ^/char title = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  inputDialog~popup(title);
}
void inputDialogIsDone(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^&.InputDialog inputDialog = .refArg!&.InputDialog?(L=, re=, argc=, nret);
  if(re < 0) ret;
  L.pushBoolean(inputDialog~isDone());
}
void inputDialogGetStr(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^&.InputDialog inputDialog = .refArg!&.InputDialog?(L=, re=, argc=, nret);
  if(re < 0) ret;
  L.pushString(inputDialog~getStr());
}


void playBGM(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char file = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .sdl.playBGM("plugins", file);
}

void esc(&.lua.State L=, int re=)
{
  re = 1;
  L.pushBoolean(.se.esc);
}

void enterNetPlay(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char host = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(#.cmd.net > 0){
    L.pushString("すでに通信中です。");
    re = -1;
    ret;
  }
  .chr.chars.new(4);
  .cmd.net.new(1);
  .cmd.net~openReplayFile("replay/netplay.replay");
  branch{
  cond #host > 0:
    .cmd.net~connect(host, .listenPort);
  else:
    .cmd.net~accept(.listenPort);
  }
}

void exitNetPlay(&.lua.State L=, int re=)
{
  re = 0;
  .cmd.net.new(0);
}

void enterReplay(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char file = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .chr.chars.new(4);
  .cmd.replay.new(1);
  .cmd.replay~open(file);
}

void exitReplay(&.lua.State L=, int re=)
{
  re = 0;
  .cmd.replay.new(0);
}

void setCom(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pn = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, 4, pn)){
    L.pushString("プレイヤー番号が不正です。");
    re = -1;
    ret;
  }
  int ai = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .m.limMin!int?(ai=, 0);
  .com.com[pn-1] = ai;
}

void setAutoLevel(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool b = .blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.autolevel = b;
}

void getListenPort(&.lua.State L=, int re=)
{
  re = 1;
  L.pushString(.listenPort);
}

void connected(&.lua.State L=, int re=)
{
  re = 1;
  L.pushBoolean(#.cmd.net > 0 && .cmd.net~isConnected());
}

void setListenPort(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char port = .strArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(#port > 0) .listenPort = port;
}

void synchronize(&.lua.State L=, int re=)
{
  re = 0;
  if(!.cmd.synchronize()){
    L.pushString("同期エラーです。");
    re = -1;
    ret;
  }
}

void addChar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^^/char lines = .s.splitLines(.strArg(L=, re=, argc=, nret));
  if(re < 0) ret;
  loop{index i = 0; while; do:
    .syst.selinf.sel.addChar(lines[i]);
    i++;
  while i < #lines:}
}

void addStage(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^^/char lines = .s.splitLines(.strArg(L=, re=, argc=, nret));
  if(re < 0) ret;
  loop{index i = 0; while; do:
    .syst.selinf.sel.addStage(lines[i]);
    i++;
  while i < #lines:}
}

void setRandomSpr(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Sff sff = .refArg!&.Sff?(L=, re=, argc=, nret); if(re < 0) ret;
  int g = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int n = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xs = .syst.selinf.sel.randxscl, ys = .syst.selinf.sel.randyscl;
  if(L.getTop() > argc){
    xs = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    ys = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  ^&.sff.Sff sf = sff~getSff();
  if(#sf > 0) .syst.selinf.sel.randomspr = sf~getOwnPalSprite(g, n);
  .syst.selinf.sel.randxscl = xs;
  .syst.selinf.sel.randyscl = ys;
}

void setSelColRow(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int c = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int r = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.selinf.sel.columns = c;
  .syst.selinf.sel.rows = r;
}

void setSelCellSize(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float x = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.selinf.sel.cellsizex = x;
  .syst.selinf.sel.cellsizey = y;
}

void setSelCellScale(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float x = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.selinf.sel.cellscalex = x;
  .syst.selinf.sel.cellscaley = y;
}

void setStage(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int n = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  L.pushNumber((double).syst.selinf.sel.setStageNo(n));
}

void setTeamMode(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pn = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, 2, pn)){
    L.pushString("プレイヤー番号が不正です。");
    re = -1;
    ret;
  }
  int tm = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(0, 2, tm)){
    L.pushString("モード番号が不正です。");
    re = -1;
    ret;
  }
  int nt = 1;
  if(tm == 2){
    nt = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
    if(!.m.inRange!int?(1, 4, nt)){
      L.pushString("チーム人数が不正です。");
      re = -1;
      ret;
    }
  }
  .syst.selinf.p[pn-1].selchr.new(0);
  .com.tmode[pn-1] = tm;
  .com.numturns[pn-1] = nt;
}

void getCharName(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int n = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
  L.pushString(#c > 0 ? c~name : "");
}

void selectChar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int pn = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, 2, pn)){
    L.pushString("プレイヤー番号が不正です。");
    re = -1;
    ret;
  }
  int cn = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int pl = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int retval = 0;
  if(.m.inRange!int?(1, 12, pl) && .syst.selinf.addSelchr(pn-1, cn, pl)){
    switch(.com.tmode[pn-1]){
    case (int).com.TeamMode::Single:
      retval = 2;
    case (int).com.TeamMode::Simul:
      retval = #.syst.selinf.p[pn-1].selchr >= 2 ? 2 : 1;
    case (int).com.TeamMode::Turns:
      retval = #.syst.selinf.p[pn-1].selchr >= .com.numturns[pn-1] ? 2 : 1;
    }
  }
  L.pushNumber((double)retval);
}

void getStageName(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int n = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  L.pushString(.syst.selinf.sel.getStageName(n));
}

void refresh(&.lua.State L=, int re=)
{
  re = 0;
  if(!.se.fskip){
  /?/*.cfg.OpenGL:
    .sdl.GlSwapBuffers(::);
  /*true:
    .sdl.screen.flip();
    .com.screenFill(0x00000000);
  /*?*/
  }
  .snd.playSound();
  if(!.cmd.update()) .se.end = true;
  if(.se.end){
    L.pushString("<game end>");
    re = -1;
  }
}

void drawPortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){
    ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
    if(#c > 0 && #c~lportrait > 0){
      c~lportrait~draw(x, y, xscl, yscl, c~lportrait~colorPallet);
    }
  }
}

void drawFace(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float x = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int offset = 0;
  if(L.getTop() > argc){
    offset = (int).numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip) loop{
    int j = 0;
    ^&.sys.Select::Char c;
    while;
  do:
    loop{int i = 0; while; do:
      c = .syst.selinf.sel.getChar(offset++);
      if(#c > 0) branch{
      cond #c~sportrait > 0:
        c~sportrait~draw(
          x + (float)i*.syst.selinf.sel.cellsizex,
          y + (float)j*.syst.selinf.sel.cellsizey,
          .syst.selinf.sel.cellscalex, .syst.selinf.sel.cellscaley,
          c~sportrait~colorPallet);
      cond .s.equ(c~def, "randomselect") && #.syst.selinf.sel.randomspr > 0:
        .syst.selinf.sel.randomspr~draw(
          x + (float)i*.syst.selinf.sel.cellsizex,
          y + (float)j*.syst.selinf.sel.cellsizey,
          .syst.selinf.sel.randxscl, .syst.selinf.sel.randxscl,
          .syst.selinf.sel.randomspr~colorPallet);
      }
      i++;
    while i < .syst.selinf.sel.columns:
    }
    j++;
  while j < .syst.selinf.sel.rows:
  }
}

public void init(&.lua.State L=)
{
  L.register("sffNew", .sffNew);
  L.register("sndNew", .sndNew);
  L.register("sndPlay", .sndPlay);
  L.register("fontNew", .fontNew);
  L.register("commandNew", .commandNew);
  L.register("commandAdd", .commandAdd);
  L.register("commandGetState", .commandGetState);
  L.register("commandInput", .commandInput);
  L.register("commandBufReset", .commandBufReset);
  L.register("textImgNew", .textImgNew);
  L.register("textImgSetFont", .textImgSetFont);
  L.register("textImgSetBank", .textImgSetBank);
  L.register("textImgSetAlign", .textImgSetAlign);
  L.register("textImgSetText", .textImgSetText);
  L.register("textImgSetPos", .textImgSetPos);
  L.register("textImgSetScale", .textImgSetScale);
  L.register("textImgDraw", .textImgDraw);
  L.register("animNew", .animNew);
  L.register("animSetPos", .animSetPos);
  L.register("animAddPos", .animAddPos);
  L.register("animSetTile", .animSetTile);
  L.register("animSetColorKey", .animSetColorKey);
  L.register("animSetAlpha", .animSetAlpha);
  L.register("animSetScale", .animSetScale);
  L.register("animSetWindow", .animSetWindow);
  L.register("animUpdate", .animUpdate);
  L.register("animDraw", .animDraw);
  L.register("inputDialogNew", .inputDialogNew);
  L.register("inputDialogPopup", .inputDialogPopup);
  L.register("inputDialogIsDone", .inputDialogIsDone);
  L.register("inputDialogGetStr", .inputDialogGetStr);
  L.register("playBGM", .playBGM);
  L.register("esc", .esc);
  L.register("enterNetPlay", .enterNetPlay);
  L.register("exitNetPlay", .exitNetPlay);
  L.register("enterReplay", .enterReplay);
  L.register("exitReplay", .exitReplay);
  L.register("setCom", .setCom);
  L.register("setAutoLevel", .setAutoLevel);
  L.register("getListenPort", .getListenPort);
  L.register("setListenPort", .setListenPort);
  L.register("connected", .connected);
  L.register("synchronize", .synchronize);
  L.register("addChar", .addChar);
  L.register("addStage", .addStage);
  L.register("setRandomSpr", .setRandomSpr);
  L.register("setSelColRow", .setSelColRow);
  L.register("setSelCellSize", .setSelCellSize);
  L.register("setSelCellScale", .setSelCellScale);
  L.register("setStage", .setStage);
  L.register("setTeamMode", .setTeamMode);
  L.register("getCharName", .getCharName);
  L.register("selectChar", .selectChar);
  L.register("getStageName", .getStageName);
  L.register("refresh", .refresh);
  L.register("drawPortrait", .drawPortrait);
  L.register("drawFace", .drawFace);
}


