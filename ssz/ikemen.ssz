
lib mes = <alpha/mesdialog.ssz>;
lib sdl = <alpha/sdlplugin.ssz>;
lib ssz = <ssz.ssz>;
lib s = <string.ssz>;
lib m = <math.ssz>;
lib file = <file.ssz>;
lib se = <alpha/sdlevent.ssz>;
lib stb = "statebuilder.ssz";
lib cfg = "config.ssz";
lib chr = "char.ssz";
lib com = "common.ssz";
lib stage = "stage.ssz";
lib sys = "system.ssz";
lib sha = "share.ssz";
lib sff = "sff.ssz";
lib sc = "script.ssz";
lib cmd = "command.ssz";
lib snd = "sound.ssz";
lib fnt = "font.ssz";
lib lua = <alpha/lua.ssz>;
lib al = <alert.ssz>;


public void error<_t>(^/char m)
{
  .al.alert!_t?(m);
}

void scGame(&.lua.State L=, int re=)
{
  re = 1;
  L.pushNumber((double).match());
}

bool init(&.lua.State L=)
{
  .sc.init(L=);
  L.register("game", .scGame);
  ret true;
}

void loadCharacter(^&.chr.Char p, ^/char file, ^int end)
{
  ^/char error;
  &.stb.StateBuilder chara;
  if(#chara.build(p~playerno, file)=>error > 0 || #p~load(file)=>error > 0){
    .error!.self?(error);
    end<> = -1;
    ret;
  }
  end<> = 1;
}

void loadStage(^/char file, ^int end)
{
  ^/char error = .chr.stg~load(file);
  if(#error > 0){
    .error!.self?(error);
    end<> = -1;
    ret;
  }
  end<> = 1;
}

int match()
{
  ^/char stag;
  branch{
  cond .sc.syst.selinf.sel.curStageNo == 0:
    stag =
      .sc.syst.selinf.sel.stagelist[
        .m.rand(0, #.sc.syst.selinf.sel.stagelist-1)].def;
  else:
    stag = .sc.syst.selinf.sel.stagelist[.sc.syst.selinf.sel.curStageNo-1].def;
  }
  ^int ldend.new(1);
  .chr.stg.new(1);
  ldend<> = 0;
/?/*.cfg.OpenGL:
  .loadStage(stag, ldend);
  if(ldend<> <= 0) ret -1;
/*true:
  thread!.loadStage? lstage;
  lstage..(stag, ldend);
  loop{do:
    if(ldend<> > 0) break;
  while ldend<> >= 0 && .se.event():
    ret -1;
  }
/*?*/
  int retval;
  loop{do: retval = .game(); while retval == -2:}
  if(retval < 0) .chr.chars.new(4);
  ret retval;
}
int game()
{
  int winp = 0;
  if(.se.end) ret -1;
  ^^/char cha.new(4);
  ^int pal.new(4);
  ^int ldend.new(1);
  cha[0] = .sc.syst.selinf.sel.charlist[.sc.syst.selinf.p[0].selchr[0].i].def;
  pal[0] = .sc.syst.selinf.p[0].selchr[0].pal;
  cha[1] = .sc.syst.selinf.sel.charlist[.sc.syst.selinf.p[1].selchr[0].i].def;
  pal[1] = .sc.syst.selinf.p[1].selchr[0].pal;
  if(.com.tmode[0] == (int).com.TeamMode::Simul){
    cha[2] =
      .sc.syst.selinf.sel.charlist[.sc.syst.selinf.p[0].selchr[1].i].def;
    pal[2] = .sc.syst.selinf.p[0].selchr[1].pal;
  }
  if(.com.tmode[1] == (int).com.TeamMode::Simul){
    cha[3] =
      .sc.syst.selinf.sel.charlist[.sc.syst.selinf.p[1].selchr[1].i].def;
    pal[3] = .sc.syst.selinf.p[1].selchr[1].pal;
  }
  .chr.fight = .sc.syst.fig;
  bool loadChar(^&.chr.Char p, ^/char cha, int pal)
  {
    if(#p~sf == 0){
      `ldend<> = 0;
    /?/*.cfg.OpenGL:
      .loadCharacter(p, cha, `ldend);
      if(`ldend<> <= 0) ret false;
    /*true:
      thread!.loadCharacter? lcha..(p, cha, `ldend);
      loop{do:
        if(`ldend<> > 0) break;
      while `ldend<> >= 0 && .se.event():
        ret false;
      }
    /*?*/
    }
    p~loadPallet(cha, pal);
    ret true;
  }
  void pset(^&.chr.Char p=, int no)
  {
    branch{
    cond #p == 0:
      p = .chr.create(no);
    else:
      p~id = .chr.id++;
      .chr.chars[no].new[0] = p;
      .chr.players.add(p);
    }
  }
  bool foo(^&.chr.Char p, int pn)
  {
    ^/char error;
    branch{
    cond #p > 0:
      .chr.fight~fa[.com.tmode[pn]][pn+2].face_spr =
        p~sf~getOwnPalSprite(
          .chr.fight~fa[.com.tmode[pn]][pn+2].face_sprg,
          .chr.fight~fa[.com.tmode[pn]][pn+2].face_spri);
    cond .com.tmode[pn] == (int).com.TeamMode::Turns:
      .chr.fight~fa[.com.tmode[pn]][pn].numko = 0;
      loop{
        index i = 0;
        .chr.fight~fa[.com.tmode[pn]][pn].teammate_face_spr.new(
          #.sc.syst.selinf.p[pn].selchr);
        ^/char tmp;
        while;
      do:
        tmp =
          .sc.syst.selinf.sel.charlist[
            .sc.syst.selinf.p[pn].selchr[i].i].sprite;
        error = .com.loadFile(
          .sc.syst.selinf.sel.charlist[.sc.syst.selinf.p[pn].selchr[i].i].def,
          tmp=,
          [^/char(^/char f){
              ^&.sff.Sprite s.new(1);
              if(
                #s~loadFromSff(
                  f, .chr.fight<>
                    .fa[(int).com.TeamMode::Turns][pn].teammate_face_sprg,
                  .chr.fight<>
                    .fa[(int).com.TeamMode::Turns][pn].teammate_face_spri
                )=>error > 0)
              {
                ret error;
              }
              .chr.fight~fa[.com.tmode[pn]][pn].teammate_face_spr[i] = s;
              ret "";
            }]);
        i++;
      while i < #.sc.syst.selinf.p[pn].selchr:
      }
    }
    ret true;
  }
  int fight(^char ss=, ^&.sha.Share share)
  {
    .mes.SetSharedString(:ss:);
    bool b = .lua.runSsz("ssz/fighting.ssz");
    .sdl.shareScreen(.cfg.OpenGL);
    share~push();
    bool w1 = .com.p1wins >= .com.p1mw;
    bool w2 = .com.p2wins >= .com.p2mw;
    `winp = 0;
    if(w1 != w2){
      `winp++;
      if(w2) `winp++;
    }
    .mes.GetSharedString(:ss=:);
    if(.s.equ(ss, "end")) .se.end = true;
    if(.s.equ(ss, "reload")){
      .chr.chars.new(4);
      ret -2;
    }
    ret b && !.s.equ(ss, "esc") ? `winp : -1;
  }
  {
    if(#.cmd.net > 0) .cmd.net~stop();
    ^^&.chr.Char p;
    p.new(4);
    loop{index i = 0; while; do:
      if(#.chr.chars[i] > 0 && .s.equ(cha[i], .chr.chars[i][0]~def)){
        p[i] = .chr.chars[i][0];
        p[i]~key = .com.com[i] != 0 ? !i : i;
      }
      i++;
    while i < #p:
    }
    .chr.id = .cfg.HelperMax;
    .chr.players.clear();
    .chr.chars.new(4);
    .com.rexisted[0] = .com.rexisted[1] = 0;
    pset(p[0]=, 0);
    pset(p[1]=, 1);
    if(.com.tmode[0] == (int).com.TeamMode::Simul) pset(p[2]=, 2);
    if(.com.tmode[1] == (int).com.TeamMode::Simul) pset(p[3]=, 3);
    if(!loadChar(p[0], cha[0], pal[0])) ret -1;
    if(!loadChar(p[1], cha[1], pal[1])) ret -1;
    branch{
    cond #p[2] > 0:
      if(!loadChar(p[2], cha[2], pal[2])) ret -1;
    else:
      {
        &.file.File f;
        f.open("ssz/state2p.ssz", "wb");
        f.writeAry!ubyte?(
          .s.sToU8(
            \xfeff
            "lib c="\""char.ssz"\"";public void c.Char::stateInit2P(){}"));
      }
    }
    branch{
    cond #p[3] > 0:
      if(!loadChar(p[3], cha[3], pal[3])) ret -1;
    else:
      {
        &.file.File f;
        f.open("ssz/state3p.ssz", "wb");
        f.writeAry!ubyte?(
          .s.sToU8(
            \xfeff
            "lib c="\""char.ssz"\"";public void c.Char::stateInit3P(){}"));
      }
    }
    .chr.fight~fa[.com.tmode[0]][0].face_spr =
      p[0]~sf~getOwnPalSprite(
        .chr.fight~fa[.com.tmode[0]][0].face_sprg,
        .chr.fight~fa[.com.tmode[0]][0].face_spri);
    .chr.fight~fa[.com.tmode[1]][1].face_spr =
      p[1]~sf~getOwnPalSprite(
        .chr.fight~fa[.com.tmode[1]][1].face_sprg,
        .chr.fight~fa[.com.tmode[1]][1].face_spri);
    foo(p[2], 0);
    foo(p[3], 1);
    .chr.fight~wi[0].clear();
    .chr.fight~wi[1].clear();
    .com.home = 0;
    .com.round = 1;
    .com.p1mw =
      .com.tmode[1] == (int).com.TeamMode::Turns
      ? .com.numturns[1] : .chr.fight~ro.match_wins;
    .com.p2mw =
      .com.tmode[0] == (int).com.TeamMode::Turns
      ? .com.numturns[0] : .chr.fight~ro.match_wins;
    .com.p1wins = 0;
    .com.p2wins = 0;
    .com.draws = 0;
    ^&.sha.Share share.new(1);
    share~copy();
    share~stt = 0;
    &.com.SuperDangerousRef sdr;
    sdr.copyRef!&.sha.Share?(share=);
    %char buf .= "gt<>" .= .s.iToS(sdr.p);
    ^char ss = buf;
    int res = fight(ss=, share);
    if(res < 0) ret res;
    if(
      .com.tmode[0] == (int).com.TeamMode::Turns
      || .com.tmode[1] == (int).com.TeamMode::Turns)
    {
      loop{while; do:
        if(p[0]~sysivar[.chr.iLIFE] <= 0){
          if(.com.p2wins >= .com.p2mw) break, break;
          if(.com.tmode[0] == (int).com.TeamMode::Turns){
            .chr.fight~fa[.com.tmode[0]][0].numko++;
            cha[0] =
              .sc.syst.selinf.sel.charlist[
                .sc.syst.selinf.p[0].selchr[.com.p2wins].i].def;
            pal[0] = .sc.syst.selinf.p[0].selchr[.com.p2wins].pal;
            p[0]~sf.new(0);
            if(!loadChar(p[0], cha[0], pal[0])) ret -1;
            .chr.fight~fa[.com.tmode[0]][0].face_spr =
              p[0]~sf~getOwnPalSprite(
                .chr.fight~fa[.com.tmode[0]][0].face_sprg,
                .chr.fight~fa[.com.tmode[0]][0].face_spri);
            .com.rexisted[0] = 0;
          }
        }
        if(p[1]~sysivar[.chr.iLIFE] <= 0){
          if(.com.p1wins >= .com.p1mw) break, break;
          if(.com.tmode[1] == (int).com.TeamMode::Turns){
            .chr.fight~fa[.com.tmode[1]][1].numko++;
            cha[1] =
              .sc.syst.selinf.sel.charlist[
                .sc.syst.selinf.p[1].selchr[.com.p1wins].i].def;
            pal[1] = .sc.syst.selinf.p[1].selchr[.com.p1wins].pal;
            p[1]~sf.new(0);
            if(!loadChar(p[1], cha[1], pal[1])) ret -1;
            .chr.fight~fa[.com.tmode[1]][1].face_spr =
              p[1]~sf~getOwnPalSprite(
                .chr.fight~fa[.com.tmode[1]][1].face_sprg,
                .chr.fight~fa[.com.tmode[1]][1].face_spri);
            .com.rexisted[1] = 0;
          }
        }
        ss = buf;
        
        if((res = fight(ss=, share)) < 0) ret res;
      while !.se.end:
      }
    }
  break:
    .cmd.synchronize();
  }
  ret winp;
}

void main()
{//Itumademo Kanseishinai Eienni Mikansei ENgine
  if(!.sdl.init("I.K.E.M.E.N", .cfg.Width, .cfg.Height, .cfg.OpenGL)){
    .error!.self?("初期化に失敗");
    ret;
  }
/?/*.cfg.OpenGL:
  if(!.sdl.InitMugenGl(::)){
    .error!.self?("OpenGL 3.1 の初期設定に失敗");
    ret;
  }
/*?*/
  .sdl.showCursor(false);
  &.lua.State L;
  if(!.init(L=)) ret;
  if(!L.runFile(.cfg.system)){
    ^/char err = L.toString(-1);
    if(!.s.equ(err[#err-10..-1], "<game end>")) .error!self?(err);
  }
}

main();
.sdl.End(::);
