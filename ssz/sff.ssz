
lib file = <file.ssz>;
lib s = <string.ssz>;
lib sdl = <alpha/sdlplugin.ssz>;
lib consts = <consts.ssz>;
lib m = <math.ssz>;
lib tbl = <table.ssz>;
lib cfg = "config.ssz";
lib com = "common.ssz";


const int NumCharPalletes = 12;

public ^&com.PalFX allPalFX;
allPalFX.new(1);

public &SffHeader
{
  public ubyte ver0, ver1, ver2, ver3;
  public uint firstSpriteHeaderOffset, firstPaletteHeaderOffset;
  public uint numberOfPalettes, numberOfSprites;
  public ^/char read(&.file.File f=, uint lofs=, uint tofs=)
  {
    ubyte ub;
    loop{
      index i = 0;
      %char s;
    do:
      if(!f.read!ubyte?(ub=)) ret .com.FileReadError;
      s .= (char)ub;
      i++;
    while i < 12:
      if(!.s.equ(s, "ElecbyteSpr"\0)){
        ret "ElecbyteSprじゃない";
      }
    }
    if(!f.read!ubyte?(`ver3=)) ret .com.FileReadError;
    if(!f.read!ubyte?(`ver2=)) ret .com.FileReadError;
    if(!f.read!ubyte?(`ver1=)) ret .com.FileReadError;
    if(!f.read!ubyte?(`ver0=)) ret .com.FileReadError;
    uint dummy;
    switch(`ver0){
    case 0d1:
      if(!f.read!uint?(dummy=)) ret .com.FileReadError;
      `numberOfPalettes = 0x0;
      if(!f.read!uint?(`numberOfSprites=)) ret .com.FileReadError;
      if(!f.read!uint?(`firstSpriteHeaderOffset=)) ret .com.FileReadError;
      if(!f.read!uint?(dummy=)) ret .com.FileReadError;
      `firstPaletteHeaderOffset = 0x0;
    case 0d2:
      if(!f.read!uint?(dummy=)) ret .com.FileReadError;
      if(!f.read!uint?(dummy=)) ret .com.FileReadError;
      if(!f.read!uint?(dummy=)) ret .com.FileReadError;
      if(!f.read!uint?(dummy=)) ret .com.FileReadError;
      if(!f.read!uint?(dummy=)) ret .com.FileReadError;
      if(!f.read!uint?(`firstSpriteHeaderOffset=)) ret .com.FileReadError;
      if(!f.read!uint?(`numberOfSprites=)) ret .com.FileReadError;
      if(!f.read!uint?(`firstPaletteHeaderOffset=)) ret .com.FileReadError;
      if(!f.read!uint?(`numberOfPalettes=)) ret .com.FileReadError;
      if(!f.read!uint?(lofs=)) ret .com.FileReadError;
      if(!f.read!uint?(dummy=)) ret .com.FileReadError;
      if(!f.read!uint?(tofs=)) ret .com.FileReadError;
    default:
      ret "バージョンが不正です";
    }
    ret "";
  }
}

&PalleteList
{
  %^uint palletes;
  %index palidxs;
  public &.tbl.IntTable!uint, index? palTable;
  public void clear()
  {
    `palletes.new(0);
    `palidxs.new(0);
    `palTable.clear();
  }
  public ^uint newPal(index pi=)
  {
    `palidxs.new[#`palletes] = (pi = #`palletes);
    `palletes.new[-1].new(256);
    ret `palletes[-1];
  }
  public void setSource(index pi, ^uint pal)
  {
    `palidxs.new[pi] = pi;
    `palletes.new[pi] = pal;
  }
  public ^uint get(index pi)
  {
    ret `palletes[`palidxs[pi]];
  }
  public void remap(index source, index dest)
  {
    `palidxs[source] = dest;
  }
  public void resetRemap()
  {
    loop{index i = 0; while; do: `palidxs[i] = i; i++; while i < #`palidxs:}
  }
}

public &Sprite
{
  public ^uint colorPallet;
/?/*.cfg.OpenGL:
  public ^&.sdl.GlTexture pxl;
/*true:
  public ^ubyte pxl;
  public %byte pluginbuf;
/*?*/
  public &.sdl.Rect rct;
  public short imageGroup, imageNumber;
  public index palidx = -1, link = -1;
  public int rle = 0;
  public void shareCopy(`self sp=)
  {
    `colorPallet = sp.colorPallet;
    `pxl = sp.pxl;
    `rct.w = sp.rct.w;
    `rct.h = sp.rct.h;
    `palidx = sp.palidx;
    `rle = sp.rle;
  }
  public void copy(`self sp=)
  {
    `shareCopy(sp=);
  /?/*!.cfg.OpenGL:
    `pluginbuf = sp.pluginbuf;
  /*?*/
    `rct = sp.rct;
    `imageGroup = sp.imageGroup;
    `imageNumber = sp.imageNumber;
    `link = sp.link;
  }
  public ^uint getPal(&.PalleteList pl=)
  {
    if(#`colorPallet > 0) ret `colorPallet;
    ret pl.get(`palidx);
  }
  public bool readHeader(&.file.File f=)
  {
    if(!f.read!short?(`rct.x=)) ret false;
    if(!f.read!short?(`rct.y=)) ret false;
    if(!f.read!short?(`imageGroup=)) ret false;
    if(!f.read!short?(`imageNumber=)) ret false;
    ret true;
  }
  public ^/char readPcxHeader(&.file.File f=, long offset)
  {
    f.seek(offset, .file.Seek::SET);
    ubyte dummy, encoding, bpp;
    if(!f.read!ubyte?(dummy=)) ret .com.FileReadError;
    if(!f.read!ubyte?(dummy=)) ret .com.FileReadError;
    if(!f.read!ubyte?(encoding=)) ret .com.FileReadError;
    if(!f.read!ubyte?(bpp=)) ret .com.FileReadError;
    if(bpp != 0d8){
      ret "256色じゃない";
    }
    ushort x, y, w, h;
    if(!f.read!ushort?(x=)) ret .com.FileReadError;
    if(!f.read!ushort?(y=)) ret .com.FileReadError;
    if(!f.read!ushort?(w=)) ret .com.FileReadError;
    if(!f.read!ushort?(h=)) ret .com.FileReadError;
    f.seek(offset+66, .file.Seek::SET);
    ushort bpl;
    if(!f.read!ushort?(bpl=)) ret .com.FileReadError;
    `rct.w = w - x + 0x1;
    `rct.h = h - y + 0x1;
    `rle = encoding == 0x1 ? (int)bpl : 0;
    ret "";
  }
  public bool readHeaderV2(
    &.file.File f=, uint ofs=, uint siz=,
    uint lofs, uint tofs, ushort idxlnked=)
  {
    if(!f.read!short?(`imageGroup=)) ret false;
    if(!f.read!short?(`imageNumber=)) ret false;
    if(!f.read!ushort?(`rct.w=)) ret false;
    if(!f.read!ushort?(`rct.h=)) ret false;
    if(!f.read!short?(`rct.x=)) ret false;
    if(!f.read!short?(`rct.y=)) ret false;
    if(!f.read!ushort?(idxlnked=)) ret false;
    ubyte fmt, dummy;
    if(!f.read!ubyte?(fmt=)) ret false;
    `rle = -(int)fmt;
    if(!f.read!ubyte?(dummy=)) ret false;
    if(!f.read!uint?(ofs=)) ret false;
    if(!f.read!uint?(siz=)) ret false;
    ushort pali, flg;
    if(!f.read!ushort?(pali=)) ret false;
    `palidx = (index)pali;
    if(!f.read!ushort?(flg=)) ret false;
    ofs += (flg & 0d1) == 0x0 ? lofs : tofs;
    ret true;
  }
  public ^/char read(
    &.file.File f=, &.SffHeader sh=, long offset, uint loh, uint nsh,
    ^`self prev, bool palletSame=, &.PalleteList pl=, bool c00)
  {
    ^/char error;
    uint lenghtOfSubheader = loh;
    if(nsh > (uint)offset) lenghtOfSubheader = nsh - (uint)offset;//lohを無視
    byte ps;
    if(!f.read!byte?(ps=)) ret .com.FileReadError;
    palletSame = ps != 0;
    if(#prev == 0) palletSame = false;
    if(#`readPcxHeader(f=, offset)=>error > 0) ret error;
    f.seek(offset + 128, .file.Seek::SET);
    ^ubyte px.new((index)lenghtOfSubheader - (128+(c00||palletSame?0:768)));
    f.readAry!ubyte?(px);
    loop{
      index i = 0;
      ubyte r, g, b;
      if(palletSame){
        if(#prev > 0) `palidx = prev~palidx;
        if(`palidx < 0) pl.newPal(`palidx=);
        break, break;
      }
      ^uint pal = pl.newPal(`palidx=);
      if(c00) f.seek(offset + (long)lenghtOfSubheader - 768, .file.Seek::SET);
    do:
      if(!f.read!ubyte?(r=)) ret .com.FileReadError;
      if(!f.read!ubyte?(g=)) ret .com.FileReadError;
      if(!f.read!ubyte?(b=)) ret .com.FileReadError;
      pal[i] = (uint)r<<0d16 | (uint)g<<0d8 | (uint)b;
      i++;
    while i < 256:
    }
    if(
      !.cfg.SaveMemory || .cfg.OpenGL
      || (index)`rct.w*(index)`rct.h
      < (`rct.w >= 0d256 ? (#px/256)*(index)`rct.w : #px))
    {
      `rlePcxDecode(px=);
    }
    `setPxl(px);
    ret "";
  }
  public ^/char readV2(&.file.File f=, long ofs, uint dsz)
  {
    f.seek(ofs+4, .file.Seek::SET);
    ^ubyte px.new((index)dsz);
    f.readAry!ubyte?(px);
    if(`rle < 0) switch(-`rle){
    case 2:
      `rle8Decode(px=);
    case 3:
      `rle5Decode(px=);
    case 4:
      `lz5Decode(px=);
    default:
      ret "不明な形式です";
    }
    `setPxl(px);
    ret "";
  }
  public void setPxl(^ubyte px)
  {
  /?/*.cfg.OpenGL:
    `pxl.new(1);
    `pxl~load8bitTexture(px, `rct.w, `rct.h);
  /*true:
    `pxl = px;
  /*?*/
  }
  public void rlePcxDecode(^ubyte px=)
  {
    if(#px == 0 || `rle <= 0) ret;
    ^/ubyte rle = px;
    px.new((index)((uint)`rct.w * `rct.h));
    loop{
      int w = (int)`rct.w;
      int leng = #px;
      index i = 0, j = 0, k = 0;
    do:
      loop{
        int size;
        ubyte d = rle[i++];
        branch{
        cond d >= 0xC0:
          size = (int)(d & 0x3F);
          d = rle[i++];
        else:
          size = 1;
        }
        while;
      do:
        px[j] = d;
        j += (int)(k < w);
        if(++k == `rle){
          k = 0;
          size = 0;
        }
      while --size >= 0:
      }
    while j < leng:
    }
    `rle = 0;
  }
  public void rle8Decode(^ubyte px=)
  {
    if(#px == 0) ret;
    ^/ubyte rle = px;
    px.new((index)((uint)`rct.w * `rct.h));
    loop{
      int leng = #px;
      index i = 0, j = 0;
      while;
    do:
      loop{
        int size;
        ubyte d = rle[i++];
        branch{
        cond (d&0xC0) == 0x40:
          size = (int)(d & 0x3F);
          d = rle[i++];
        else:
          size = 1;
        }
        while;
      do:
        px[j++] = d;
      while --size >= 0:
      }
    while j < leng:
    }
    `rle = 0;
  }
  public void rle5Decode(^ubyte px=)
  {
    if(#px == 0) ret;
    ^/ubyte rle = px;
    px.new((index)((uint)`rct.w * `rct.h));
    loop{
      int leng = #px;
      index i = 0, j = 0;
      while;
    do:
      loop{
        int rlen = (int)rle[i++];
        int dlen = (int)(rle[i] & 0x7F);
        ubyte c = rle[i++]>>0d7 != 0x0 ? rle[i++] : 0x0;
      do:
        px[j++] = c;
      while --rlen >= 0:
        if(--dlen >= 0){
          c = rle[i] & 0x1F;
          rlen = (int)(rle[i++]>>0d5);
          break, do;
        }
      }
    while j < leng:
    }
    `rle = 0;
  }
  public void lz5Decode(^ubyte px=)
  {
    if(#px == 0) ret;
    ^/ubyte rle = px;
    px.new((index)((uint)`rct.w * `rct.h));
    loop{
      int leng = #px;
      index i = 0, j = 0;
      uint s = 0x0, rbc = 0x0;
      ubyte ct = rle[i++], rb = 0x0;
      while;
    do:
      branch{
        int size;
        uint d;
      cond (ct & 0d1<<s) != 0x0:
        loop{
          d = rle[i++];
          branch{
          cond (d&0x3F) == 0x00:
            d = (d<<0d2 | rle[i++]) + 0d1;
            size = (int)rle[i++] + 2;
          else:
            rb |= (d&0xC0) >> rbc;
            rbc += 0d2;
            size = (int)(d & 0x3F);
            branch{
            cond rbc < 0d8:
              d = (uint)rle[i++] + 0x1;
            else:
              d = (uint)rb + 0d1;
              rbc = 0x0;
              rb = 0x0;
            }
          }
        do:
          px[j] = px[j-(index)d];
          j++;
        while --size >= 0:
        }
      else:
        loop{
          d = rle[i++];
          branch{
          cond (d&0xE0) == 0x00:
            size = (int)rle[i++] + 8;
          else:
            size = (int)(d >> 0d5);
            d &= 0x1F;
          }
          while;
        do:
          px[j++] = d;
        while --size >= 0:
        }
      }
      if(++s >= 0d8){
        s = 0x0;
        ct = rle[i++];
      }
    while j < leng:
    }
    `rle = 0;
  }
  public ^/char loadFromSff(^/char fn, short ig, short in)
  {
    ^/char error;
    &.file.File f;
    if(!f.open(fn, "rb")) ret .com.FileOpenError;
    &.SffHeader h;
    uint lofs, tofs;
    if(#h.read(f=, lofs=, tofs=)=>error > 0) ret error;
    uint shofs = h.firstSpriteHeaderOffset, misc, size;
    ushort indexOfPrevious;
    &.PalleteList pl;
    loop{
      index i = 0;
      %uint newSubHeaderOffset .= shofs;
      bool palletSame;
      ~$bool() foo = [bool(){
        switch(h.ver0){
        case 0d1:
          if(!f.read!uint?(misc=)) ret false;
          if(!f.read!uint?(size=)) ret false;
          if(!`readHeader(f=)) ret false;
          if(!f.read!ushort?(indexOfPrevious=)) ret false;
        case 0d2:
          if(
            !`readHeaderV2(
              f=, misc=, size=, lofs, tofs, indexOfPrevious=)) ret false;
        }
        ret true;
      }];
      ^`self dummy;
      while;
    do:
      newSubHeaderOffset .= shofs;
      f.seek((long)shofs, .file.Seek::SET);
      if(!foo(::)) ret .com.FileReadError;
      if(`palidx >= 0 && (`imageGroup != ig || `imageNumber != in)) continue;
      loop{
        uint ip = (uint)#newSubHeaderOffset, ipmax;
        while;
      do:
        ipmax = ip - 0x1;
        if(indexOfPrevious > ipmax) ret "linkが不正です";
        ip = indexOfPrevious;
        shofs =
          h.ver0 == 0d1 ? newSubHeaderOffset[(index)ip]
          : h.firstSpriteHeaderOffset + ip*0d28;
        f.seek((long)shofs, .file.Seek::SET);
        if(!foo(::)) ret .com.FileReadError;
      while size == 0d0:
      }
      switch(h.ver0){
      case 0d1:
        if(
          #`read(
            f=, h=, (long)(shofs + 0d32), size,
            misc, dummy, palletSame=, pl=, false)=>error
          > 0) ret error;
      case 0d2:
        if(#`readV2(f=, (long)misc, size)=>error > 0) ret error;
      }
      if(`imageGroup == ig && `imageNumber == in) break;
      dummy.new(1);
      dummy~palidx = `palidx;
    continue:
      shofs = h.ver0 == 0d1 ? misc : shofs + 0d28;
      i++;
    while i < (index)h.numberOfSprites:
      ret .s.iToS(ig)+","+.s.iToS(in)+"のスプライトが見つかりません";
    }
    if(h.ver0 == 0d1){
      `colorPallet = pl.get(`palidx);
      `palidx = -1;
      ret "";
    }
    loop{
      uint ip;
      indexOfPrevious = (uint)`palidx;
    do:
      ip = indexOfPrevious;
      shofs = h.firstPaletteHeaderOffset + ip*0d16;
      f.seek((long)shofs + 6, .file.Seek::SET);
      if(!f.read!ushort?(indexOfPrevious=)) ret .com.FileReadError;
      if(!f.read!uint?(misc=)) ret .com.FileReadError;
      if(!f.read!uint?(size=)) ret .com.FileReadError;
    while size == 0d0 && ip != indexOfPrevious:
    }
    f.seek((long)(lofs+misc), .file.Seek::SET);
    `colorPallet.new(256);
    loop{
      index i = 0, l = (index)size / 4;
      ubyte r, g, b, dummy;
    do:
      if(!f.read!ubyte?(r=)) ret .com.FileReadError;
      if(!f.read!ubyte?(g=)) ret .com.FileReadError;
      if(!f.read!ubyte?(b=)) ret .com.FileReadError;
      if(!f.read!ubyte?(dummy=)) ret .com.FileReadError;
      `colorPallet[i] = (uint)r<<0d16 | (uint)g<<0d8 | (uint)b;
      i++;
    while i < l:
    }
    if(#`colorPallet == 0) `colorPallet.new(256);
    `palidx = -1;
    ret "";
  }
  public void draw(float x, float y, float xscale, float yscale, ^uint pal)
  {
    &.sdl.Rect tile;
    tile.set(0, 0, 0d0, 0d0);
    float x2 = x - xscale*(float)`rct.x + (float)(.com.GameWidth-320)/2.0;
    float y2 = y - yscale*(float)`rct.y + (float)(.com.GameHeight-240);
    if(xscale < 0.0) x2 *= -1.0;
    if(yscale < 0.0) y2 *= -1.0;
  /?/*.cfg.OpenGL:
    if(#`pxl > 0){
      .sdl.RenderMugenGl(:
        `pxl<>, pal<>=, 0, `rct=, -x2*.com.WidthScale, -y2*.com.HeightScale,
        tile=, xscale*.com.WidthScale, xscale*.com.WidthScale,
        yscale*.com.HeightScale, 1.0, 0.0, 0.0, 255, .com.scrrect=, 0.0, 0.0:);
    }
  /*true:
    .sdl.screen.renderMugenZoom(
      .com.scrrect=, 0.0, 0.0,
      `pxl, pal, 0, `rct=, -x2*.com.WidthScale, -y2*.com.HeightScale,
      tile=, xscale*.com.WidthScale, xscale*.com.WidthScale,
      yscale*.com.HeightScale, 0.0, 0x0, 255, `rle, `pluginbuf=);
  /*?*/
  }
}


public &Sff
{
  public &.SffHeader head;
  public &.tbl.IntTable!uint, &.Sprite? spriteTable;
  public &.PalleteList palList;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `spriteTable.clear();
    `palList.clear();
    loop{
      index i = 0, foo;
      ^index idx;
      while;
    do:
      `palList.newPal(foo=);
      i++;
      idx.new(1);
      idx<> = foo;
      `palList.palTable.set(0d1<<0d16 | (uint)i, idx);
    while i < .NumCharPalletes:
    }
  }
  public ^/char loadFile(^/char filename, bool chr)
  {
    ^/char error;
    &.file.File f;
    if(!f.open(filename, "rb")) ret .com.FileOpenError;
    `clear();
    uint lofs, tofs;
    if(#`head.read(f=, lofs=, tofs=)=>error > 0) ret error;
    if(`head.ver0 != 0d1) loop{
       index i = 0;
       ^uint pal;
       ushort group, item, link, dummy;
       uint ofs, siz;
       ^index idx;
       `palList.clear();
       while;
    do:
      f.seek((long)`head.firstPaletteHeaderOffset + 16*i, .file.Seek::SET);
      if(!f.read!ushort?(group=)) ret .com.FileReadError;
      if(!f.read!ushort?(item=)) ret .com.FileReadError;
      if(!f.read!ushort?(dummy=)) ret .com.FileReadError;
      if(!f.read!ushort?(link=)) ret .com.FileReadError;
      if(!f.read!uint?(ofs=)) ret .com.FileReadError;
      if(!f.read!uint?(siz=)) ret .com.FileReadError;
      idx.new(1);
      branch{
      cond siz == 0x0:
        pal = `palList.get((index)link);
        idx<> = (index)link;
      else:
        f.seek((long)(lofs+ofs), .file.Seek::SET);
        pal.new(256);
        loop{
          index i = 0, l = (index)siz / 4;
          ubyte r, g, b, dummy8;
        do:
          if(!f.read!ubyte?(r=)) ret .com.FileReadError;
          if(!f.read!ubyte?(g=)) ret .com.FileReadError;
          if(!f.read!ubyte?(b=)) ret .com.FileReadError;
          if(!f.read!ubyte?(dummy8=)) ret .com.FileReadError;
          pal[i] = (uint)r<<0d16 | (uint)g<<0d8 | (uint)b;
          i++;
        while i < l:
        }
        idx<> = i;
      }
      `palList.setSource(i, pal);
      `palList.palTable.set((uint)group<<0d16 | item, idx);
      i++;
    while i < (index)`head.numberOfPalettes:
    }
    uint shofs = `head.firstSpriteHeaderOffset, size;
    loop{
      index i = 0;
      uint misc;
      ^&.Sprite spriteList;
      spriteList.new((index)`head.numberOfSprites);
      ushort indexOfPrevious;
      index prev = -1;
      while;
    do:
      f.seek((long)shofs, .file.Seek::SET);
      switch(`head.ver0){
      case 0d1:
        if(!f.read!uint?(misc=)) ret .com.FileReadError;
        if(!f.read!uint?(size=)) ret .com.FileReadError;
        if(!spriteList[i].readHeader(f=)) ret .com.FileReadError;
        if(!f.read!ushort?(indexOfPrevious=)) ret .com.FileReadError;
      case 0d2:
        if(
          !spriteList[i].readHeaderV2(
            f=, misc=, size=, lofs, tofs, indexOfPrevious=))
          {
            ret .com.FileReadError;
          }
      }
      branch{
        bool ps;
      cond size != 0d0:
        switch(`head.ver0){
        case 0d1:
          if(
            #spriteList[i].read(
              f=, `head=, (long)(shofs + 0d32),
              size, misc, spriteList[prev..prev+1], ps=, `palList=,
              chr && (
                (
                  spriteList[i].imageGroup == 0
                  && spriteList[i].imageNumber == 0)
                || prev < 0))=>error
            > 0) ret error;
        case 0d2:
          if(#spriteList[i].readV2(f=, (long)misc, size)=>error > 0){
            ret error;
          }
        }
        prev = i;
      else:
        spriteList[i].shareCopy(spriteList[(index)indexOfPrevious]=);
        spriteList[i].link = (index)indexOfPrevious;
      }
      `spriteTable.operate(
        (uint)spriteList[i].imageGroup
        | (uint)spriteList[i].imageNumber<<0d16,
        [void(^&.Sprite s=){if(#s == 0) s = spriteList[i..i+1];}]);
      shofs = `head.ver0 == 0d1 ? misc : shofs + 0d28;
      i++;
    while i < (index)`head.numberOfSprites:
    }
    ret "";
  }
  public ^&.Sprite getSprite(short group, short number)
  {
    if(group < 0 || number < 0) ret .consts.null!&.Sprite?();
    ret `spriteTable.get((uint)group | (uint)number<<0d16);
  }
  public ^&.Sprite getOwnPalSprite(short group, short number)
  {
    ^&.Sprite sp = `spriteTable.get((uint)group | (uint)number<<0d16);
    if(#sp == 0) ret sp;
    ^&.Sprite ops.new(1);
    ops~copy(sp<>=);
    ops~colorPallet = .s.clone!uint?(sp~getPal(`palList=));
    ret ops;
  }
}

public &FrameMethods<_t>
{
  public void _t::action(`anim_t ani=)
  {
    ani.time++;
    if(ani.time >= `time){
      if(ani.totaltime == -1 && ani.current == #ani.frames-1) break;
      ani.time = 0;
      ani.newframe = true;
      loop{do:
        ani.current++;
        if(ani.totaltime == -1 && ani.current == #ani.frames-1) break;
      while ani.frames[ani.current].time <= 0 && ani.current < #ani.frames:
      }
      if(ani.current >= #ani.frames) ani.current = ani.loopstart;
    }
    if(ani.totaltime != -1 && ani.sumtime >= ani.totaltime){
      ani.sumtime = ani.totaltime - ani.looptime;
    }
    ani.sumtime++;
    if(ani.totaltime != -1 && ani.sumtime >= ani.totaltime) ani.loopend = true;
  }
  public void _t::readData(^/int ary, ^/char line)
  {
    `group = ary[0];
    `number = ary[1];
    `x = ary[2];
    `y = ary[3];
    `time = ary[4];
    ^^/char spl = @s.split(",", line);
    if(#spl < 6) ret;
    loop{index i = 0; while; do:
      switch(spl[5][i]){
      case 'H', 'h':
        `h = -1;
      case 'V', 'v':
        `v = -1;
      }
      i++;
    while i < #spl[5]:
    }
    if(`h < 0) `x *= -1;
    if(`v < 0) `y *= -1;
    if(#spl < 7) ret;
    ^/char a;
    loop{index i = 6; while; do:
      if(#(a = @s.trim(spl[i])) > 0) break;
      i++;
    while i < #spl:
    }
    a = @s.toLower(a);
    branch{
    cond @s.equ(a, "a1"):
      `salpha = 0d255;
      `dalpha = 0d128;
    cond @s.equ(a[0..1], "s"):
      `salpha = 0d1;
      `dalpha = 0d255;
    cond @s.equ(a[0..2], "as"):
      {
        index di = @s.find("d", a);
        if(di < 0) break;
        ushort tmp = .com.aton!ushort?(a[2..di]);
        `salpha = (tmp > 0d255 ? 0d255 : tmp);
        tmp = .com.aton!ushort?(a[di+1..-1]);
        `dalpha = (tmp > 0d255 ? 0d255 : tmp);
        if(`salpha == 0d1 && `dalpha == 0d255) `salpha = 0d0;
      }
    cond @s.equ(a[0..1], "a"):
      `salpha = 0d255;
      `dalpha = 0d255;
    }
  }
}

public &AirFileMethods<_t>
{
  public .._t::readAction(^^/char lines, index i=) ^`action_t
  {
    ^`action_t act;
    ^/char sec = lines[i];
    ^/char name = @com.sectionName(sec=);
    if(#name == 0) ret act;
    i++;
    if(!@s.equ(name, "begin ")) ret act;
    index fnd = @s.cFind(" ", sec);
    if(fnd < 0) fnd = -2;
    name = @s.toLower(sec[0..fnd+1]);
    sec = sec[fnd+1..-1];
    if(!@s.equ(name, "action ")) ret act;
    int no;
    no = @com.aton!int?(sec);
    act = `getAction(no);
    if(#act > 0) ret act;
    `actionList.new[-1].no = no;
    act = `actionList[#`actionList-1..-1];
    act~read(lines, i=);
    if(#act~numFrames() > 0) ret act;
    loop{
      ^`action_t linkact;
      while;
    do:
      linkact = self(lines, i=);
      if(#linkact > 0){
        int oldno = act~no;
        act~copy(linkact<>=);
        act~no = oldno;
        break, break;
      }
      i++;
    while i < #lines:
    }
    ret act;
  }
}

public &Anim<frame_t>
{
  public ^&.Sff sff;
  public ^&.Sprite spr;
  public %frame_t frames;
  public &.sdl.Rect tile;
  public index loopstart = 0, current = 0, drawidx = 0;
  public int time = 0;
  public int sumtime = 0;
  public int totaltime = 0;
  public int looptime = 0;
  public int nazotime = 0;
  public int mask = -1;
  public short salpha = -1, dalpha = 0;
  public byte h = 1, v = 1;
  public bool newframe = true, loopend = false;
  new()
  {
    `tile.set(0, 0, 0d0, 0d0);
  }
  public void reset()
  {
    `current = 0;
    `drawidx = 0;
    `time = 0;
    `sumtime = 0;
    `newframe = true;
    `loopend = false;
    `spr.new(0);
  }
  public void copy(`self a=)
  {
    `sff = a.sff;
    `spr = a.spr;
    `frames = a.frames;
    `tile = a.tile;
    `loopstart = a.loopstart;
    `current = a.current;
    `drawidx = a.drawidx;
    `time = a.time;
    `sumtime = a.sumtime;
    `totaltime = a.totaltime;
    `looptime = a.looptime;
    `nazotime = a.nazotime;
    `mask = a.mask;
    `salpha = a.salpha;
    `dalpha = a.dalpha;
    `h = a.h;
    `v = a.v;
    `newframe = a.newframe;
    `loopend = a.loopend;
  }
  public void setFrames(%`frame_t f, index l)
  {
    `totaltime = `looptime = `nazotime = 0;
    if(#f > 0) loop{
      if(f[-1].time == -1){
        `totaltime = -1;
        break, break;
      }
      index i = 0;
      int tmp = 0;
      while;
    do:
      branch{
      cond f[i].time == -1:
        `totaltime = -1;
        `looptime = -tmp - (int)(i >= l);
        `nazotime = -(int)(i < l);
      else:
        `totaltime += f[i].time;
        if(i >= l) `looptime += f[i].time;
        if(i < l) `nazotime += f[i].time;
      }
      if(i < l) tmp += f[i].time;
      i++;
    while i < #f:
      if(`totaltime == -1) `nazotime = 0;
    }
    `frames = f;
    `loopstart = l;
  }
  public ^frame_t currentFrame()
  {
    ret `frames[`current..`current+1];
  }
  public ^frame_t drawFrame()
  {
    ret `frames[`drawidx..`drawidx+1];
  }
  public int animTime()
  {
     ret `sumtime - `totaltime;
  }
  public int animElemTime(int elem)
  {
    int t;
    if(elem > #`frames){
      t = `animTime();
      ret t > 0 ? 0 : t;
    }
    int e = .m.max!int?(0, elem) - 1;
    t = `sumtime;
    loop{index i = 0; while; do:
      t -= .m.max!int?(0, `frames[i].time);
      i++;
    while i < e:}
    ret t;
  }
  public int animElemNo(int time)
  {
    if(#`frames > 0) branch{
      int t = time, oldt = 0;
    cond t < 0:
      loop{
        index i = `current;
        t += `time;
        bool lp = false;
        continue;
      do:
        t += .m.max!int?(0, `frames[i].time);
      continue:
        if(lp && (i == #`frames-1 && `frames[i].time == -1)) ret i + 1;
        if(t >= 0) ret i + 1;
        i--;
      while i >= 0 && (`current < `loopstart || i >= `loopstart):
        if(t == oldt) break;
        oldt = t;
        lp = true;
        i = #`frames - 1;
        do;
      }
    else:
      loop{
        index i = `current;
        t -= .m.max!int?(0, `frames[i].time) - `time;
        continue;
      do:
        t -= .m.max!int?(0, `frames[i].time);
      continue:
        if(t <= 0 || (i == #`frames-1 && `frames[i].time == -1)) ret i + 1;
        i++;
        if(i >= #`frames){
          if(t == oldt) break, break;
          oldt = t;
          i = `loopstart;
        }
      while true:
      }
    }
    ret #`frames;
  }
  public void setAnimElem(int e)
  {
    `current = .m.max!index?(0, e-1);
    if(`current >= #`frames) branch{
    cond `totaltime == -1:
      `current = #`frames - 1;
    else:
      `current = `loopstart + (`current-`loopstart) % (#`frames-`loopstart);
    }
    `drawidx = `current;
    `time = 0;
    `newframe = true;
    `updateSprite();
    `loopend = false;
    `sumtime = 0;//animElemTime内で使用
    `sumtime = -`animElemTime(`current+1);
  }
  public void animSeek(index elem)
  {
    loop{
      bool foo = true;
      continue;
    do:
      loop{while; do:
        if(`current == #`frames-1 && `frames[`current].time == -1) break;
        `current++;
      while `frames[`current].time <= 0 && `current < #`frames:
      }
      if(`current < #`frames) break;
      if(!!foo){
        `current = #`frames-1;
        break, break;
      }
    continue:
      `current = .m.max!index?(0, elem);
    while true:
    }
    .m.limRange!index?(`current=, 0, #`frames-1);
  }
  public void updateSprite()
  {
    if(#`frames == 0) ret;
    if(`totaltime > 0){
      if(`sumtime >= `totaltime){
        `time = 0;
        `newframe = true;
        `current = `loopstart;
      }
      `animSeek(`current);
      if(
        `nazotime < 0
        && (
          `sumtime >= `totaltime + `nazotime
          && `sumtime >= `totaltime - `looptime)
        && (
          `sumtime == `totaltime + `nazotime
          || `sumtime == `totaltime - `looptime))
      {
        `time = 0;
        `newframe = true;
        `current = 0;
      }
    }
    if(`newframe && #`sff > 0){
      `spr = `sff~getSprite(`frames[`current].group, `frames[`current].number);
    }
    `newframe = false;
    `drawidx = `current;
  }
  public void action()
  {
    if(#`frames == 0){
      `loopend = true;
      ret;
    }
    `updateSprite();
    `frames[`current].action(`=);
  }
  int alphaFoo()
  {
    ubyte sa, da;
    branch{
    cond `salpha >= 0:
      sa = (ubyte)`salpha;
      da = (ubyte)`dalpha;
    else:
      sa = `frames[`drawidx].salpha;
      da = `frames[`drawidx].dalpha;
    }
    branch{
    cond sa == 0d1 && da == 0d255:
      ret -2;
    else:
      sa = (ubyte)((int)sa * .com.brightness >> 8);
      branch{
      cond sa < 0d5 && da == 0d255:
        ret 0;
      cond sa == 0d255 && da == 0d255:
        ret -1;
      }
    }
    int alpha = (int)sa;
    if((uint)sa+da < 0d254 || 0d256 < (uint)sa+da){
      alpha |= (int)da << 10 | 1 << 9;
    }
    ret alpha;
  }
  ^uint palFoo(^&.com.PalFX fx)
  {
    ^uint pal = `spr~getPal(`sff~palList=);
    branch{
    cond #fx > 0 && fx~time != 0 && .allPalFX~time != 0:
      {
        &.com.PalFX synth = fx<>;
        synth.synthesize(.allPalFX<>, `alphaFoo() == -2);
        pal = synth.getFxPal(pal, `alphaFoo() == -2);
      }
    cond #fx > 0 && fx~time != 0:
      pal = fx~getFxPal(pal, `alphaFoo() == -2);
    cond .allPalFX~time != 0:
      pal = .allPalFX~getFxPal(pal, `alphaFoo() == -2);
    }
    ret pal;
  }
  public void draw(
    &.sdl.Rect rect=, float x, float y, float cscalex, float cscaley,
    float xtscale, float xbscale, float yscale, float rasterxadd,
    float rx, ^&.com.PalFX fx, bool oVer)
  {
    if(#`spr == 0 || #`spr~pxl == 0) ret;
    int h = `h*`frames[`drawidx].h, v = `v*`frames[`drawidx].v;
    float xs = (float)h*cscalex*xtscale, ys = (float)v*cscaley*yscale;
    float bs = xbscale;
  /?/*!.cfg.OpenGL:
    .m.limRange!float?(xs=, -16000.0/.com.WidthScale, 16000.0/.com.WidthScale);
    .m.limRange!float?(
      ys=, -16000.0/.com.HeightScale, 16000.0/.com.HeightScale);
    .m.limRange!float?(bs=, -16000.0/.com.WidthScale, 16000.0/.com.WidthScale);
  /*?*/
    float x2 =
      cscalex*x - xs*(float)(`spr~rct.x - `frames[`drawidx].x) + rx;
    float y2 = cscaley*y - ys*(float)(`spr~rct.y - `frames[`drawidx].y);
    if(xs < 0.0){
      x2 *= -1.0;
      x2 += rx*2.0;
      if(oVer) x2 += xs;
    }
    if(ys < 0.0){
      y2 *= -1.0;
      if(oVer) y2 += ys;
    }
    if(`tile.w == 0x1){
      float tmp =
        xs * ((float)`tile.x + (`tile.x > 0 ? 0.0 : (float)`spr~rct.w));
      x2 -= (float)(int)(x2 / tmp) * tmp;
    }
    if(`tile.h == 0x1){
      float tmp =
        ys * ((float)`tile.y + (`tile.y > 0 ? 0.0 : (float)`spr~rct.h));
      y2 -= (float)(int)(y2 / tmp) * tmp;
    }
  /?/*.cfg.OpenGL:
    ^uint pal = `palFoo(fx);
    .sdl.RenderMugenGl(:
      `spr~pxl<>, pal<>=, `mask, `spr~rct=, (rx-x2)*.com.WidthScale,
      -y2*.com.HeightScale, `tile=, xs*.com.WidthScale,
      cscalex*bs*(float)h*.com.WidthScale, ys*.com.HeightScale, 1.0,
      cscalex*rasterxadd*(.com.WidthScale/.com.HeightScale),
      0.0, `alphaFoo(), rect=, rx*.com.WidthScale, 0.0:);
  /*true:
    .sdl.screen.renderMugenZoom(
      rect=, rx*.com.WidthScale, 0.0, `spr~pxl, `palFoo(fx), `mask, `spr~rct=,
      (rx-x2)*.com.WidthScale, -y2*.com.HeightScale,
      `tile=, xs*.com.WidthScale,
      cscalex*bs*(float)h*.com.WidthScale, ys*.com.HeightScale,
      cscalex*rasterxadd*(.com.WidthScale/.com.HeightScale),
      0x0, `alphaFoo(), `spr~rle, `spr~pluginbuf=);
  /*?*/
  }
  public void angleDraw(
    float x, float y, float xscale, float yscale, float angle, bool angleset,
    float axscl, float ayscl, ^&.com.PalFX fx, bool oVer)
  {
    if(#`spr == 0 || #`spr~pxl == 0) ret;
    float rx = x + (float).com.GameWidth/2.0;
    int h = `h*`frames[`drawidx].h;
    int v = `v*`frames[`drawidx].v;
    float xs = xscale * axscl, ys = yscale * ayscl;
    float agl =
      angle*(float)(`h * `v * (xs < 0.0 ? -1: 1) * (ys < 0.0 ? -1: 1));
    uint uagl = (uint)((512.0/.m.PI)*agl + 0.5) & 0x3ff;
    if(uagl == 0x0) branch{
    cond angleset:
      `draw(
        .com.scrrect=, x - xs*(float)(h*`frames[`drawidx].x), y,
        1.0, 1.0, xs, xs, ys, 0.0, (float).com.GameWidth/2.0, fx, false);
    else:
      `draw(
        .com.scrrect=,
        x, y, 1.0, 1.0, xs, xs, ys, 0.0, (float).com.GameWidth/2.0, fx, oVer);
    comm:
      ret;
    }
  /?/*.cfg.OpenGL:
    ^uint pal = `palFoo(fx);
    .sdl.RenderMugenGl(:
      `spr~pxl<>, pal<>=, `mask, `spr~rct=,
      #xs*(float)`spr~rct.x*.com.WidthScale,
      #ys*(float)`spr~rct.y*.com.HeightScale, `tile=,
      xs*(float)h*.com.WidthScale, xs*(float)h*.com.WidthScale,
      ys*(float)v*.com.HeightScale, 1.0, 0.0, (double)uagl*.m.PI/512.0,
      `alphaFoo(), .com.scrrect=, rx*.com.WidthScale,
      (y+ys*(float)(v*`frames[`drawidx].y))*.com.HeightScale:);
  /*true:
    .m.limRange!float?(xs=, -16000.0/.com.WidthScale, 16000.0/.com.WidthScale);
    .m.limRange!float?(
      ys=, -16000.0/.com.HeightScale, 16000.0/.com.HeightScale);
    .sdl.screen.renderMugenZoom(
      .com.scrrect=, rx*.com.WidthScale,
      (y+ys*(float)(v*`frames[`drawidx].y))*.com.HeightScale,
      `spr~pxl, `palFoo(fx), `mask, `spr~rct=,
      #xs*(float)`spr~rct.x*.com.WidthScale,
      #ys*(float)`spr~rct.y*.com.HeightScale,
      `tile=, xs*(float)h*.com.WidthScale,
      xs*(float)h*.com.WidthScale, ys*(float)v*.com.HeightScale,
      0.0, uagl, `alphaFoo(), `spr~rle, `spr~pluginbuf=);
  /*?*/
  }
  public void shadowDraw(
    float x, float y, float xscale, float yscale, float vscale, float angle,
    bool angleset, float axscl, float ayscl, ^&.com.PalFX fx, bool oVer,
    uint color, int alpha)
  {
    if(#`spr == 0 || #`spr~pxl == 0) ret;
    float x2 = x, y2 = y;
    int h = `h*`frames[`drawidx].h;
    int v = `v*`frames[`drawidx].v;
    float xs = xscale * axscl, ys = yscale * ayscl;
    float agl =
      angle*(float)(`h * `v * (xs < 0.0 ? -1: 1) * (ys < 0.0 ? -1: 1));
    uint uagl = (uint)((512.0/.m.PI)*agl + 0.5) & 0x3ff;
    if(uagl == 0x0 && !angleset){
      x2 += xs*(float)(h*`frames[`drawidx].x);
      if(xs < 0.0 && oVer) x2 -= xs;
      if(ys*vscale < 0.0 && oVer) y2 -= ys*vscale;
    }
  /?/*.cfg.OpenGL:
    if(color != 0x0) loop{index i = 0; do:
      .com.tmppl[i] = color;
    while ++i < 256:}
    ~$void(int) draw = [void(int alp){
      .sdl.RenderMugenGl(:
        `spr~pxl<>, .com.tmppl<>=, `mask, `spr~rct=,
        #xs*(float)`spr~rct.x*.com.WidthScale,
        #ys*(float)`spr~rct.y*.com.HeightScale, `tile=,
        xs*(float)h*.com.WidthScale, xs*(float)h*.com.WidthScale,
        ys*(float)v*.com.HeightScale, vscale, 0.0, (double)uagl*.m.PI/512.0,
        alp, .com.scrrect=, (x2+(float).com.GameWidth/2.0)*.com.WidthScale,
        (y2+ys*(float)(v*`frames[`drawidx].y))*.com.HeightScale:);
    }];
    if((int)color > 0) draw(:-2:);
    if(alpha > 0) draw(:(256-alpha) << 10 | 1 << 9:);
  /*true:
    .m.limRange!float?(xs=, -16000.0/.com.WidthScale, 16000.0/.com.WidthScale);
    .m.limRange!float?(
      ys=, -16000.0/.com.HeightScale, 16000.0/.com.HeightScale);
    .sdl.screen.renderMugenShadow(
      .com.scrrect=, (x2+(float).com.GameWidth/2.0)*.com.WidthScale,
      (y2+ys*(float)(v*`frames[`drawidx].y))*.com.HeightScale,
      `spr~pxl, color, `spr~rct=,
      #xs*(float)`spr~rct.x*.com.WidthScale,
      #ys*(float)`spr~rct.y*.com.HeightScale,
      xs*(float)h*.com.WidthScale, ys*(float)v*.com.HeightScale, vscale,
      uagl, alpha, `spr~rle, `spr~pluginbuf=);
  /*?*/
  }
  public void setup(^&.Sff sff)
  {
    `sff = sff;
  }
}

