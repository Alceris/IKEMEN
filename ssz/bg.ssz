

lib s = <string.ssz>;
lib sdl = <alpha/sdlplugin.ssz>;
lib m = <math.ssz>;
lib sff = "sff.ssz";
lib cfg = "config.ssz";
lib com = "common.ssz";

public ^^/char splitParams(^/char paramStr)
{
  %^/char params;
  loop{
    ^/char tmp = paramStr;
    index cidx, bidx;
  do:
    tmp = .s.trim(tmp);
    cidx = .s.find(",", tmp);
    bidx = .s.cFind(.s.blank, tmp);
    if(bidx >= 0 && bidx < cidx){
      params .= tmp[0..bidx];
      break, break;
    }
    params .= .s.trim(tmp[0..cidx]);
    if(cidx < 0) break;
    tmp = tmp[cidx+1 .. -1];
  while true:
  }
  ret params;
}

public ..csvToAry<_t>(^/char csv) ^_t
{
  ^^/char spl = .splitParams(csv);
  ^_t ary.new(#spl);
  loop{index i = 0; while; do:
    ary[i] = (*_t).com.atof(spl[i]);
    i++;
  while i < #ary:
  }
  ret ary;
}

public void readPair<_t>(_t x=, _t y=, ^/char data)
{
  ^_t xy = .csvToAry!_t?(data);
  x = xy[0];
  if(#xy >= 2) y = xy[1];
}


public &Frame
{
  public int time = -1;
  public short group = -1, number = 0;
  public short x = 0, y = 0;
  public ubyte salpha = 255, dalpha = 0;
  public byte h = 1, v = 1;
  type anim_t = &.sff.Anim!self?;
  &.sff.FrameMethods!self? fam;
}


public &BGAction
{
  public float xoffset, yoffset, sinxoffset, sinyoffset;
  public float x, y, vx, vy;
  public float xradius, yradius;
  public int sinxtime, sinytime;
  public int sinxlooptime, sinylooptime;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `xoffset = 0.0; `yoffset = 0.0;
    `sinxoffset = 0.0; `sinyoffset = 0.0;
    `x = 0.0; `y = 0.0; `vx = 0.0; `vy = 0.0;
    `xradius = 0.0; `yradius = 0.0;
    `sinxtime = 0; `sinytime = 0;
    `sinxlooptime = 0; `sinylooptime = 0;
  }
  public void action()
  {
    `x += `vx;
    if(`sinxlooptime > 0){
      `sinxoffset =
        `xradius*.m.sin(.m.PI*(double)`sinxtime / (double)`sinxlooptime);
      `sinxtime++;
      if(`sinxtime >= `sinxlooptime) `sinxtime = 0;
    }
    `xoffset = `x + `sinxoffset;
    //
    `y += `vy;
    if(`sinylooptime > 0){
      `sinyoffset =
        `yradius*.m.sin(.m.PI*(double)`sinytime / (double)`sinylooptime);
      `sinytime++;
      if(`sinytime >= `sinylooptime) `sinytime = 0;
    }
    `yoffset = `y + `sinyoffset;
  }
}

public &Action
{
  public int no;
  public %&.Frame frames;
  public index loopstart = 0;
  /index numFrames()
  {
    ret #`frames;
  }
  public void copy(`self a=)
  {
    `no = a.no;
    `frames = a.frames;
    `loopstart = a.loopstart;
  }
  public void read(^^/char lines, index i=)
  {
    `frames.new(0);
    index ols = 0;
    loop{
      ^int ary;
      ^/char line;
      while;
    do:
      if(#lines[i] > 0 && lines[i][0] == '['){
        i--;
        break, break;
      }
      line = .s.trim(lines[i][0...s.find(";", lines[i])]);
      branch{
      cond #line > 0 && ((line[0] >= '0' && line[0] <= '9') || line[0] == '-'):
        ary = .com.csvToAry!int?(line);
        if(#ary < 5) break;
        ols = `loopstart;
        `frames.new[-1].readData(ary, line);
      else:
        line = .s.toLower()<, line;
        if(.s.equ("loopstart")<, line[0..9]) `loopstart = #`frames;
      }
      i++;
    while i < #lines:
    }
    if(`loopstart >= #`frames) `loopstart = ols;
  }
}

public &BackGround
{
  public &.sff.Anim!&.Frame? anim;
  public &.BGAction bga;
  public int id = 0;
  public float startx = 0.0, starty = 0.0, camstartx = 0.0;
  public float deltax = 1.0, deltay = 1.0;
  public float xtscale = 1.0, xbscale = 1.0;
  public float rasterxtspeed = 1.0, rasterxbspeed = 1.0;
  public float yscalestart = 1.0;
  public float yscaledelta = 0.0;
  public int actionno = -1;
  public float startvx = 0.0, startvy = 0.0;
  public float startxrad = 0.0, startyrad = 0.0;
  public int startsinxt = 0, startsinyt = 0;
  public int startsinxlt = 0, startsinylt = 0;
  public ushort twidth = 0, bwidth = 0;
  public bool visible = true, active = true;
  public bool positionlink = false, toplayer = false;
  public &.sdl.Rect startrect;
  public float windowdeltax = 0.0, windowdeltay = 0.0;
  new()
  {
    `startrect.set(
      -.com.GameWidth*2, -.com.GameHeight*2,
      (ushort)(.com.GameWidth*4), (ushort)(.com.GameHeight*4));
  }
  public void reset()
  {
    `anim.reset();
    `bga.clear();
    `bga.vx = `startvx;
    `bga.vy = `startvy;
    `bga.xradius = `startxrad;
    `bga.yradius = `startyrad;
    `bga.sinxtime = `startsinxt;
    `bga.sinytime = `startsinyt;
    `bga.sinxlooptime = `startsinxlt;
    `bga.sinylooptime = `startsinylt;
  }
  public void read(&.com.Section sc=, ^/`self link)
  {
    int typ = 4;//0:normal, 1:anim, 2:parallax, 3:dummy, 4:error
    ^/char data;
    if(#(data = sc.get("type")) > 0){
      data = .s.toLower(data);
      branch{
      cond .s.equ(data[0..1], "n"):
        typ = 0;
      cond .s.equ(data[0..1], "a"):
        typ = 1;
      cond .s.equ(data[0..1], "p"):
        typ = 2;
      cond .s.equ(data[0..1], "d"):
        typ = 3;
      }
    }
    if(typ == 4) ret;
    if((typ == 0 || typ == 2) && #(data = sc.get("spriteno")) > 0){
      `anim.frames.new(1);
      .readPair!short?(`anim.frames~group=, `anim.frames~number=, data);
      `anim.frames[0].time = -1;
    }
    if(typ == 1 && #(data = sc.get("actionno")) > 0){
      `actionno = .com.atoi(data);
      `anim.mask = 0;
    }
    if(#(data = sc.get("positionlink")) > 0){
      `positionlink = .com.atoi(data) != 0;
      if(`positionlink = #link > 0){
        `startvx = link~startvx;
        `startvy = link~startvy;
        `deltax = link~deltax;
        `deltay = link~deltay;
      }
    }
    if(#(data = sc.get("layerno")) > 0) `toplayer = .com.atoi(data) != 0;
    if(#(data = sc.get("start")) > 0){
      .readPair!float?(`startx=, `starty=, data);
    }
    if(#(data = sc.get("delta")) > 0){
      .readPair!float?(`deltax=, `deltay=, data);
    }
    if(typ != 1 && #(data = sc.get("trans")) > 0){
      branch{
        ^char d = .s.toLower(data);
      cond .s.equ(d, "add"):
        `anim.salpha = 255;
        `anim.dalpha = 255;
      cond .s.equ(d, "add1"):
        `anim.salpha = 255;
        `anim.dalpha = 128;
      cond .s.equ(d, "addddalpha"):
        if(#(data = sc.get("alpha")) > 0){
          ^int sd = .csvToAry!int?(data);
          if(#sd >= 2){
            `anim.salpha = sd[0];
            if(`anim.salpha > 255) `anim.salpha = 255;
            `anim.dalpha = sd[1];
            if(`anim.dalpha > 255) `anim.dalpha = 255;
            if(`anim.salpha == 1 && `anim.dalpha == 255) `anim.salpha = 0;
          }
        }
      cond .s.equ(d, "sub"):
        `anim.salpha = 1;
        `anim.dalpha = 255;
      cond .s.equ(d, "none"):
        `anim.salpha = -1;
        `anim.dalpha = 0;
      }
    }
    if(#(data = sc.get("mask")) > 0){
      if(`actionno < 0 && `anim.salpha < 0) branch{
      cond (.com.atoi(data) != 0):
        `anim.mask = 0;
      else:
        `anim.mask = -1;
      }
    }
    if(#(data = sc.get("tile")) > 0){
      .readPair!ushort?(`anim.tile.w=, `anim.tile.h=, data);
    }
    if(#(data = sc.get("tilespacing")) > 0){
      `anim.tile.x = `anim.tile.y = .com.atoi(data);
    }
    if(typ == 2 && #(data = sc.get("width")) > 0){
      .readPair!ushort?(`twidth=, `bwidth=, data);
    }
    if(typ == 2 && #(data = sc.get("xscale")) > 0){
      .readPair!float?(`rasterxtspeed=, `rasterxbspeed=, data);
    }
    if(typ == 2 && #(data = sc.get("yscalestart")) > 0){
      `yscalestart = 100.0 / .com.atof(data);
    }
    if(typ == 2 && #(data = sc.get("yscaledelta")) > 0){
      `yscaledelta = .com.atof(data);
    }
    if(#(data = sc.get("window")) > 0){
      ^int ltrb = .csvToAry!int?(data);
      `startrect.x = .m.max!int?(-.com.GameWidth, .m.min!int?(32767, ltrb[0]));
      if(#ltrb < 2) break;
      `startrect.y =
        .m.max!int?(-.com.GameHeight, .m.min!int?(32767, ltrb[1]));
      if(#ltrb < 3) break;
      `startrect.w =
        .m.min!uint?(
          (uint)(65535.0/.com.WidthScale),
          (uint).m.max!int?(0, ltrb[2]+1 - `startrect.x));
      if(#ltrb < 4) break;
      `startrect.h =
        .m.min!uint?(
          (uint)(65535.0/.com.HeightScale),
          (uint).m.max!int?(0, ltrb[3]+1 - `startrect.y));
    }
    if(#(data = sc.get("windowdelta")) > 0){
      .readPair!float?(`windowdeltax=, `windowdeltay=, data);
      `windowdeltax *= .com.WidthScale;
      `windowdeltay *= .com.HeightScale;
    }
    if(#(data = sc.get("id")) > 0) `id = .com.atoi(data);
    if(#(data = sc.get("velocity")) > 0){
      .readPair!float?(`startvx=, `startvy=, data);
    }
    if(#(data = sc.get("sin.x")) > 0){
      ^float rp = .csvToAry!float?(data);
      if(#rp < 2) break;
      `startxrad = `bga.xradius = rp[0];
      `startsinxlt = `bga.sinxlooptime = (int)rp[1];
      if(#rp < 3) break;
      if(`bga.sinxlooptime > 0){
        `bga.sinxtime = (int)((float)rp[2]*rp[1]/360.0) % `bga.sinxlooptime;
        if(`bga.sinxtime < 0) `bga.sinxtime += `bga.sinxlooptime;
        `startsinxt = `bga.sinxtime;
      }
    }
    if(#(data = sc.get("sin.y")) > 0){
      ^float rp = .csvToAry!float?(data);
      if(#rp < 2) break;
      `startyrad = `bga.yradius = rp[0];
      `startsinylt = `bga.sinylooptime = (int)rp[1];
      if(#rp < 3) break;
      if(`bga.sinylooptime > 0){
        `bga.sinytime = (int)((float)rp[2]*rp[1]/360.0) % `bga.sinylooptime;
        if(`bga.sinytime < 0) `bga.sinytime += `bga.sinylooptime;
        `startsinyt = `bga.sinytime;
      }
    }
  }
  public void setup(
    ^&.sff.Sff sf, bool hires, float camstartx, bool verticalfollow,
    ~$void(^&.Action=, int) getact)
  {
    `camstartx = camstartx;
    ^&.sff.Sprite spr;
    if(#`anim.frames > 0 && (`twidth != 0d0 || `bwidth != 0d0)){
      spr = sf~getSprite(`anim.frames[0].group, `anim.frames[0].number);
      if(#spr == 0) break;
      `xtscale = (float)`twidth / (float)spr~rct.w;
      `xbscale = (float)`bwidth / (float)spr~rct.w;
    }
    branch{
    cond `actionno >= 0:
      {
        ^&.Action act;
        getact(:act=, `actionno:);
        if(#act == 0) break, else;
        `anim.setFrames(act~frames, act~loopstart);
      }
    else:
      if(
        #spr > 0 || (
          #`anim.frames > 0 && #(
            spr = sf~getSprite(
              `anim.frames[0].group, `anim.frames[0].number)) > 0))
      {
        `anim.tile.x += (int)spr~rct.w;
        `anim.tile.y += (int)spr~rct.h;
      }
    }
    if(!verticalfollow){
      `deltay = 1.0;
      `windowdeltay = `yscaledelta = 0.0;
    }
    if(hires){
      `windowdeltax *= 0.5;
      `windowdeltay *= 0.5;
    }
    float mulx = .com.WidthScale * (hires ? 0.5 : 1.0);
    float muly = .com.HeightScale * (hires ? 0.5 : 1.0);
    `startrect.x =
      (short)(
        (float)`startrect.x*mulx
        + .com.WidthScale*(float)(.com.GameWidth-320)/2.0);
    `startrect.y =
      (short)(
        (float)`startrect.y*muly
        + .com.HeightScale*(float)(.com.GameHeight-240));
    `startrect.w = (ushort)((float)`startrect.w*mulx + 0.5);
    `startrect.h = (ushort)((float)`startrect.h*muly + 0.5);
    `anim.setup(sf);
  }
  public void draw(
    float posx, float posy, float scl, ^&.com.PalFX fx, float bgscl)
  {
    float x = .cfg.Zoom ? posx : .m.ceil(posx-0.5);
    float y = .cfg.Zoom ? posy : .m.ceil(posy-0.5);
    &.sdl.Rect rect;
    rect = `startrect;
    rect.x += -(short).m.floor((x+`camstartx) * `windowdeltax + 0.5);
    rect.y += -(short).m.floor(y * `windowdeltay + 0.5);
    float xras = ((`rasterxbspeed-`rasterxtspeed) / `rasterxtspeed);
    float xbs = `xbscale;
    float sclx = scl, scly = scl, dx = .m.max!float?(0.0, `deltax*bgscl);
    sclx = .m.max!float?(0.0, scl + (1.0 - scl)*(1.0 - dx));
    if(sclx != 0.0){
      float tmp = 1.0 / sclx;
      xbs *= 
        .m.max!float?(0.0, scl + (1.0 - scl)*(1.0 - dx*(xbs/`xtscale))) * tmp;
      tmp = .m.max!float?(0.0, scl + (1.0 - scl)*(1.0 - dx*(xras+1.0))) * tmp;
      xras -= tmp - 1.0;
      xbs *= tmp;
    }
    scly =
      .m.max!float?(
        0.0, scl + (1.0 - scl)*(1.0 - .m.max!float?(0.0, `deltay*bgscl)));
    float x2 = `startx - ((x+`camstartx) * `deltax - `bga.xoffset);
    float y2 =
      `starty - (y * `deltay - `bga.yoffset) + (float)(.com.GameHeight - 240)
      + (1.0/scly - 1.0)*(float).com.GameHeight;
    if(!.cfg.Zoom){
      x2 = .m.ceil(x2 - 0.5);
      y2 = .m.ceil(y2 - 0.5);
    }
    float ys = (`yscalestart - y * (scly/scl)*`yscaledelta*(1.0/100.0));
    x2 *= bgscl;
    y2 *= bgscl;
    ys *= bgscl;
    `anim.draw(
      rect=, x2, y2, sclx, scly, `xtscale*bgscl, xbs*bgscl, ys, xras * x2
      / (#ys*(float)`anim.spr~rct.h), (float).com.GameWidth/2.0, fx);
  }
}

|BgcType
{
  Null, Anim, Visible, Enable, PosSet, PosAdd, SinX, SinY, VelSet, VelAdd
}

public &BGCtrl
{
  public %^&.BackGround ctrlbg;
  public int currenttime = 0, starttime = 0, endtime = 0, looptime = -1;
  public |.BgcType typ = .BgcType::Null;
  public float x = 0.0, y = 0.0;
  public int n = 0;
  public bool setx = false, sety = false;
  public bool positionlink = false, flag = false;
  /index idx = 0;
  public void read(&.com.Section sc=, index idx)
  {
    `idx = idx;
    ^/char data;
    if(#(data = sc.get("type")) > 0){
      branch{
        ^char typ = .s.toLower(data);
      cond .s.equ(typ, "anim"):
        `typ = .BgcType::Anim;
      cond .s.equ(typ, "visible"):
        `typ = .BgcType::Visible;
      cond .s.equ(typ, "enable"):
        `typ = .BgcType::Enable;
      cond .s.equ(typ, "null"):
        `typ = .BgcType::Null;
      cond .s.equ(typ, "posset"):
        `typ = .BgcType::PosSet;
      cond .s.equ(typ, "posadd"):
        `typ = .BgcType::PosAdd;
      cond .s.equ(typ, "sinx"):
        `typ = .BgcType::SinX;
      cond .s.equ(typ, "siny"):
        `typ = .BgcType::SinY;
      cond .s.equ(typ, "velset"):
        `typ = .BgcType::VelSet;
      cond .s.equ(typ, "veladd"):
        `typ = .BgcType::VelAdd;
      }
    }
    if(#(data = sc.get("time")) > 0){
      ^int times = .csvToAry!int?(data);
      if(#times < 1) break;
      `starttime = `endtime = times[0];
      if(#times < 2) break;
      `endtime = times[1];
      if(#times < 3) break;
      `looptime = times[2];
    }
    if(#(data = sc.get("positionlink")) > 0){
      `positionlink = .com.atoi(data) != 0;
    }
    if(#(data = sc.get("value")) > 0){
      ^float val = .csvToAry!float?(data);
      if(#val < 1) break;
      `x = val[0];
      if(#val < 2) break;
      `y = val[1];
      if(#val < 3) break;
      `n = (int)val[1];
    }
    if(#(data = sc.get("x")) > 0){
      `setx = true;
      `x = .com.atof(data);
    }
    if(#(data = sc.get("y")) > 0){
      `sety = true;
      `y = .com.atof(data);
    }
  }
}

public &ActiveCtrlList
{
  &Cell
  {
    public ^&.BGCtrl bgc;
    public ^self next;
  }
  ^&Cell top;
  public void add(^&.BGCtrl bgc)
  {
    bgc~currenttime = bgc~starttime;
    if(#`top == 0){
      `top.new(1);
      `top~bgc = bgc;
      ret;
    }
    if(bgc~idx < `top~bgc~idx){
      ^&`Cell tmp;
      tmp.new(1);
      tmp~bgc = bgc;
      tmp~next = `top;
      `top = tmp;
      ret;
    }
    loop{
      ^&`Cell tmp = `top;
      while;
    do:
      tmp = tmp~next;
      if(bgc~idx < tmp~bgc~idx){
        ^&`Cell tmp2;
        tmp2.new(1);
        tmp2~bgc = tmp~bgc;
        tmp2~next = tmp~next;
        tmp~bgc = bgc;
        tmp~next = tmp2;
        break, break;
      }
    while #tmp~next > 0:
      tmp~next.new(1);
      tmp~next~bgc = bgc;
    }
  }
  public ^^&.BGCtrl act<_t>(_t s=)
  {
    %^&.BGCtrl endlist;
    loop{
      ^&`Cell tmp = `top, pre;
      while;
    do:
      s.bgCtrl(tmp~bgc<>=);
      branch{
      cond tmp~bgc~currenttime > tmp~bgc~endtime:
        endlist.new[-1] = tmp~bgc;
        branch{
        cond tmp == `top:
          `top = `top~next;
          tmp = `top;
          break, break;
        else:
          pre~next = tmp~next;
          if(#pre == 0) break, break, break;
         }
      else:
        pre = tmp;
      comm:
       tmp = pre~next;
      }
    while #tmp > 0:
    }
    ret endlist;
  }
  public void clear()
  {
    `top.new(0);
  }
}

public &BGCTimeLine
{
  &BGCTLNode
  {
    public ^self nextnode;
    public %^&.BGCtrl bgcList;
    public int waittime = 0;
  }
  ^&BGCTLNode top;
  &.ActiveCtrlList al;
  public void add(^&.BGCtrl bgc)
  {
    if(bgc~looptime >= 0 && bgc~endtime > bgc~looptime){
      bgc~endtime = bgc~looptime;
    }
    if(
      #bgc == 0 || bgc~starttime < 0 || bgc~starttime > bgc~endtime
      || (bgc~looptime >= 0 && bgc~starttime >= bgc~looptime)) ret;
    int wtime = 0;
    if(bgc~currenttime != 0){
      if(bgc~looptime < 0) ret;
      wtime += bgc~looptime - bgc~currenttime;
    }
    wtime += bgc~starttime;
    if(#`top == 0){
      `top.new(1);
      `top~waittime = wtime;
      `top~bgcList.new[-1] = bgc;
      ret;
    }
    loop{
      ^&`BGCTLNode tmp = `top;
      while;
    do:
      wtime -= tmp~waittime;
      if(#tmp~nextnode == 0){
        tmp~nextnode.new(1);
        tmp~nextnode~waittime = wtime;
        tmp~nextnode~bgcList.new[-1] = bgc;
        break, break;
      }
      tmp = tmp~nextnode;
    while wtime > tmp~waittime:
      branch{
      cond wtime == tmp~waittime:
        tmp~bgcList.new[-1] = bgc;
      else:
        {
          ^&`BGCTLNode tmp2;
          tmp2.new(1);
          tmp2~waittime = tmp~waittime - wtime;
          tmp2~bgcList = tmp~bgcList;
          tmp2~nextnode = tmp~nextnode;
          tmp~waittime = wtime;
          tmp~bgcList.new(1);
          tmp~bgcList[0] = bgc;
          tmp~nextnode = tmp2;
        }
      }
    }
  }
  public void step<_t>(_t s=)
  {
    if(#`top != 0 && `top~waittime <= 0) loop{
      index i = 0;
      while;
    do:
      `al.add(`top~bgcList[i]);
      i++;
    while i < #`top~bgcList:
      `top = `top~nextnode;
    }
    if(#`top != 0) `top~waittime--;
    ^^&.BGCtrl el = `al.act!_t?(s=);
    loop{index i = 0; while; do:
      `add(el[i]);
      i++;
    while i < #el:
    }
  }
  public void clear()
  {
    `top.new(0);
    `al.clear();
  }
}

